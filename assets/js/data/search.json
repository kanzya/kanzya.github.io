[ { "title": "ACSC 2023 crypto jenga", "url": "/posts/jenga/", "categories": "writeup", "tags": "writeup", "date": "2024-04-02 00:00:00 +0900", "snippet": "Jengaã“ã®å•é¡Œã¯AESã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ãŸå•é¡Œã§å¤‰æ›´ç‚¹ã¯2ç‚¹ã‚ã‚Šã¾ã™ã€‚ ShiftRowsãŒhoriã¨ã„ã†é–¢æ•°ã«ã€MixColumnsãŒvertã¨ã„ã†é–¢æ•°ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚ï¼ˆå†…å®¹ã®å·®ç•°ã¯å¾Œã§ï¼‰ æ›´ã«å¥‡æ•°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã¯horiã®ã¿ä½¿ã‚ã‚Œã€é€†ã«å¶æ•°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã¯vertãŒä½¿ã‚ã‚Œã¾ã™ã€‚AESã®æ”»æ’ƒã£ã¦åŸºæœ¬çš„ã«ã„ã‚ã„ã‚ã‚ã‚Šã¾ã™ãŒã€ä»£è¡¨çš„ãªã‚‚ã®ã¨ã—ã¦ã€ç·šå½¢è§£èª­æ³•(linear cryptanalysis)ã‚„å·®åˆ†è§£èª­æ³•(different cryptanalysis)ã€Sboxã‚’Affineã¨ã—ã¦linearã¨ã¨ã‚‰ãˆã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã‚ˆã­ã€‚ã“ã®å•é¡Œã§ã¯ã€AESã§è§£æã§ã‚ˆãç”¨ã„ã‚‰ã‚Œã¦ã„ã‚‹square attackã¨ã„ã†ã‚‚ã®ã‚’ç”¨ã„ã¦æ”»æ’ƒã‚’è¡Œã„ã¾ã™ã€‚æ³¨æ„ã¨ã—ã¦ã“ã®å•é¡Œã§ã¯3Ã—3ã®è¡Œåˆ—ã‚„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒç•°ãªã‚‹ã‚‚ã®ã‚’æ‰±ã£ã¦ã„ã‚‹éƒ½åˆã€AESã¨ã¯ä¸€éƒ¨æ”»æ’ƒæ–¹æ³•ãŒç•°ãªã‚‹éƒ¨åˆ†ãŒã‚ã‚Šã¾ã™ã€‚å„é–¢æ•°ã«ã¤ã„ã¦horiAESã§è¨€ã†ã¨ShiftRowsã«ã‚ãŸã‚‹éƒ¨åˆ†ã§ã€æ•°å¼ã§ã¯$HORI$ã¨ã—ã¦ã€é€†é–¢æ•°ã‚’$HORI_INV$ã¨ã—ã¦ãŠãã¾ã™ã€‚horiã¯æ°´å¹³ã«3å›è¡Œã„ã¾ã™ãŒç°¡ç•¥åŒ–ã®ãŸã‚1è¡Œã®ã¿è¨˜è¼‰ã—ã¦ã„ã¾ã™ã€‚\\(HORI(x) = (4\\*x_0+2\\*x_1+x_2,x_0+4\\*x_1+2\\*x_2,2\\*x_0+x_1+4\\*x_2)\\)â€‹ã•ã‚‰ã«ã€\\(HORI(x\\oplus y) = (4\\*(x_0\\oplus y_0)+2\\*(x_1\\oplus y_1)+(x_2\\oplus y_2),(x_0\\oplus y_0)+4\\*(x_1\\oplus y_1)+2\\*(x_2\\oplus y_2),2\\*(x_0\\oplus y_0)+(x_1\\oplus y_1)+4\\*(x_2\\oplus y_2) =\\\\((4\\*x_0+2\\*x_1+x_2)\\oplus (4\\*y_0+2\\*y_1+y_2),(x_0+4\\*x_1+2\\*x_2) \\oplus (y_0+4\\*y_1+2\\*y_2),(2\\*x_0+x_1+4\\*x_2)\\oplus(2\\*y_0+y_1+4\\*y_2))=\\\\HORI(x)\\oplus HORI(y)\\)ã¨ã„ã†åˆ†é…å‰‡ã‚‚æˆã‚Šç«‹ã¡ã¾ã™ã€‚vertAESã§è¨€ã†ã¨MixColumnsã«ã‚ãŸã‚‹éƒ¨åˆ†ã§ã€æ•°å¼ã§ã¯$VERT$ã¨ã—ã€é€†é–¢æ•°ã‚’$VERT_INV$ã¨ã—ã¦ãŠãã¾ã™ã€‚ä»Šå›ã®é–¢æ•°ã«ãŠã„ã¦ã€vertã¯å‚ç›´ã«3å›è¡Œã„ã¾ã™ãŒè¨ˆç®—å†…å®¹ã¯horiã¨åŒã˜ãŸã‚çœç•¥ã—ã¾ã™ã€‚ã¾ãŸåˆ†é…å‰‡ã‚‚æˆç«‹ã—ã¾ã™ã€‚xorAESã§è¨€ã†ã¨AddRoundKeyã«ã‚ãŸã‚‹éƒ¨åˆ†ã§ã€æ•°å¼ã§ã¯$i$ roundã®xorã‚’$XOR_i$ã¨ã—ã€é€†é–¢æ•°ã‚’$XOR_i_INV$ã¨ã—ã¦ãŠãã¾ã™ã€‚sboxAESã§è¨€ã†ã¨SubBytesã«ã‚ãŸã‚‹éƒ¨åˆ†ã§ã€æ•°å¼ã§ã¯$sbox$ã€é€†é–¢æ•°ã‚’$sbox_INV$ã¨ã—ã¾ã™ã€‚Square attack1byteã ã‘å¤‰ãˆãŸå…¥åŠ›ã‚’ç¹°ã‚Šè¿”ã—è¡Œã„å‡ºåŠ›ã®é–¢ä¿‚æ€§ã‚’è¦‹ã‚‹ã“ã¨ã§éµã‚’æ±‚ã‚ã¦ã¿ã‚ˆã†ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚round 11roundã ã‘è¦‹ã¦ã„ãã¾ã™ã€‚å…¥åŠ›ã¨ã—ã¦ã€ç·‘ã®éƒ¨åˆ†ã ã‘å¤‰ãˆã¦ã€å¾Œã¯å›ºå®šã®å€¤ã‚’ä¸ãˆã‚‹ã¨ã—ã¾ã™ã€‚å…·ä½“çš„ã«ã¯[bytes([i])+b\"\\x00\"*8 for i in range(256)]ã¿ãŸã„ãªæ„Ÿã˜ã§ã™ã€‚çµæœã¨ã—ã¦ã€ä¸‹ã®å›³ã®ã‚ˆã†ã«å¤‰åŒ–ã•ã›ãŸéƒ¨åˆ†ãŒç·‘ã®éƒ¨åˆ†ã¸å½±éŸ¿ã‚’åŠã¼ã—ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚ãŸã ã€ã“ã®ã†ã¡6ã¤åˆ†ã®å€¤ã¯å½±éŸ¿ã‚’å—ã‘ãªã„ãŸã‚å›ºå®šãªãŸã‚ç™½ã«ã—ã¦ã„ã¾ã™ã€‚ã“ã“ã§ã‚ã‹ã£ã¦ã„ã‚‹éƒ¨åˆ†ã‚„è¨ˆç®—å¯èƒ½ãªéƒ¨åˆ†ã‚’é’ã§å¡—ã‚Šã¤ã¶ã—ã¾ã™ã€‚horiã¨sboxã¯é€†é–¢æ•°ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã§çµæœçš„ã«ã¯å…¨ã¦ã®çŠ¶æ…‹ã®å€¤ãŒã‚ã‹ã‚Šã¾ã™ã€‚ã¨ã„ã†ã“ã¨ã¯xorã®å€¤ã‚‚ã‚ã‹ã‚‹ã®ã§1roundã¯ç°¡å˜ã«éµãŒæ±‚ã¾ã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚å¼ã§è¡¨ã›ã°ã“ã‚“ãªæ„Ÿã˜ã«ãªã‚Šã¾ã™ã€‚\\[SBOX(XOR_1(HORI(input)))=output \\Leftrightarrow XOR_1(HORI(input)) = SBOX\\\\_INV(output)\\]Round 2æ¬¡ã«2roundã‚’è¦‹ã¦ã„ãã¾ã™ã€‚å…¥åŠ›ã¯1 roundã¨åŒæ§˜ã«ç·‘ã®éƒ¨åˆ†ã ã‘å¤‰ãˆã¦ã€å¾Œã¯å›ºå®šã®å€¤ã‚’ä¸ãˆãŸçµæœã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚åŒæ§˜ã«ã‚ã‹ã£ã¦ã„ã‚‹éƒ¨åˆ†ã‚’é’ã§åŸ‹ã‚ã¦ã„ãã¾ã™ã€‚ã¨ã„ã†ã‚ã‘ã§ã€1roundã¨æ¯”è¼ƒã—ã¦ã™ã¹ã¦ã®çŠ¶æ…‹ãŒã‚ã‹ã‚‹ã‚ã‘ã§ã¯ãªã„ã¨ã“ã¨ã«ãªã£ã¦ã„ã¾ã™ã€‚ãŸã ã€ä»®ã«1roundç›®ã®sboxã®ã‚«ã‚®ã‚’æ±ºã‚æ‰“ã¡ã§æ±ºå®šã§ãã‚‹ã¦ã€æ›´ã«ç™½ã®éƒ¨åˆ†ã®å€¤ã‚‚å…·ä½“çš„ã«ã‚ã‹ã‚‹ã¨ä»®å®šã—ãŸå ´åˆã€2roundç›®ã®sboxç›´å‰ã®å…¨ã¦ã®å€¤ãŒã‚ã‹ã‚‹ã®ã§ã€vertã‚‚ã™ã¹ã¦ã®å€¤ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚çµæœçš„ã«ã€1roundã¨åŒã˜ã‚ˆã†è¨ˆç®—ã—ã¦ã„ã‘ã°2Rã®ã‚«ã‚®ã‚‚ã‚ã‹ã‚Šãã†ã§ã™ã­ã€‚ãŸã å•é¡Œã¯ä»®å®šã®éƒ¨åˆ†ã§ã€ 1roundç›®ã®éµç©ºé–“ã¯$2^{8Ã—3}$â€‹ã‚ã‚‹ã®ã§ã€ã¡ã‚‡ã£ã¨è¨ˆç®—ãŒé‡ã„ã‹ã‚‚ ç™½ã®éƒ¨åˆ†ã®å€¤ã®å›ºå®šã‚’ã©ã†ã™ã‚‹ã®ã‹â€¦ä¸€ç•ªã®å•é¡Œã¯ç™½ã®éƒ¨åˆ†ã®å€¤ã®å›ºå®šã‚’ã©ã†ã™ã‚‹ã®ã‹ã¨ã„ã†éƒ¨åˆ†ã“ã‚“ãªæ™‚ã¯2ã¤ã®å…¥åŠ›ã‚’ä½¿ã£ã¦è§£æ±ºã—ã¾ã™ã€‚ä¾¿å®œä¸Šã€å…¥åŠ›ã‚’$input_1,input_2$â€‹ã¨ã—ã¾ã™ã€‚ã“ã®æ™‚ã™ã¹ã¦ã®çŠ¶æ…‹ã§$input_1,input_2$â€‹ã®XORã‚’å–ã‚Šã¾ã™ã€‚ã™ã‚‹ã¨ã€ç™½éƒ¨åˆ†ãŒ\\x00ã«ãªã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚ä½•ãŒã†ã‚Œã—ã„ã®ã‹ã¨ã„ã†ã¨ã€sboxå¾Œã‚‚0ã«ãªã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã§ã€vertéƒ¨åˆ†ãŒè¨ˆç®—ã§ãã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚Round 3å½±éŸ¿ãŒ2å›è¢«ã‚‹éƒ¨åˆ†ã‚’èµ¤ã§ç¤ºã—ã¦ã„ã¾ã™ã€‚ã“ã“ã¾ã§ãã‚‹ã¨ã¡ã‚‡ã£ã¨ãã¤ã„ã§ã™ã­â€¦å°‘ã—ã€å·¥å¤«ã‚’ã™ã‚‹ã¨1roundå‰Šæ¸›ã§ãã¾ã™ã€‚å…·ä½“çš„ã«ã¯ä»Šã¾ã§å…¥åŠ›ã¨ã—ã¦ä¸ãˆã¦ã„ãŸã‚‚ã®ã¯input=\\x01+\\x00*8ã¿ãŸã„ãªã‚‚ã®ã§ã—ãŸã€‚ã“ã‚Œã«$HORI(input)^{-1}$ã¨ã—ãŸã‚‚ã®ã‚’ä¸ãˆã‚‹ã¨1roundç›®ã®horiã«ã¦1ã¤ã®å€¤ã«ã®ã¿å½±éŸ¿ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Š1roundç›®ã®sboxç›´å¾Œã®å€¤ãŒ1ã¤ã®ã¿ã«ã¨ã©ã¾ã‚‹ã®ã§2Roundã¨åŒã˜æ”»æ’ƒãŒèµ·ã“ãªã†ã“ã¨ãŒã§ãã¾ã™ã€‚Round 4ä»Šå›ã¯Round 3ã§è¡Œã£ãŸãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã¯ç”¨ã„ãšè€ƒå¯Ÿã—ã¦ã„ãã¾ã™ã€‚Round2ã§ã¯ç™½ã®éƒ¨åˆ†ã‚’1ã¤ã®å…¥åŠ›ç”¨ã„ã¦å›ºå®šã—ã¦ã„ã¾ã—ãŸã€‚ã“ã‚Œã‚’æ‹¡å¼µã™ã‚‹æ–¹å‘æ€§ã§è€ƒãˆã¦ã„ãã¾ã™ã€‚å…·ä½“çš„ã«ã¯2Rã®sboxç›´å¾Œã¾ã§ã¯inputã®ç·‘ã«ã‚ˆã£ã¦åˆ¶å¾¡ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã€‚ãã‚Œä»¥é™ã¯ç·‘ãŒé‡è¤‡ã™ã‚‹ãŸã‚åˆ¶å¾¡ã¯å³ã—ãã†ã§ã™ã€‚ãªã®ã§ã€ã“ã‚Œã‚‰ã‚’ã†ã¾ãåˆ¶å¾¡ã—ã¦è¨ˆç®—é€”ä¸­ã¯ã‚ã‹ã‚‰ãªã„ãŒè¨ˆç®—çµæœã‚’ã‚ã‹ã‚Œã°ã‚ˆã„ã¨ã„ã†æ–¹å‘æ€§ã§2Rã®sboxç›´å¾Œã¾ã§æ±‚ã‚ã¦ã„ãã¾ã™ã€‚å…·ä½“çš„ã«ã¯ä»¥ä¸‹ã®å¼ã‚’è€ƒãˆã¾ã™ã€‚\\(\\oplus_{0\\leq i \\leq 255} SBOX(XOR_2(VERT(SBOX(XOR_1(HORI(input_i))))))\\)ã¨ã¯ã„ã£ã¦ã‚‚é•·ã„ã®ã§1ã¤ãšã¤è¦‹ã¦ã„ãã¾ã™ã€‚ 1Rã®inputã®æ™‚ã®ç·‘(å·¦ä¸Šã®ã¿) $\\oplus_{0\\leq i \\leq 255} input_i = 0$ã«ãªã‚Šã¾ã™ 1Rã®horiç›´å¾Œã®ç·‘(ä¸Šæ®µã®ã¿ã§å·¦ã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’$0\\leq j \\leq 2$â€‹ã¨ã—ã¾ã™)åˆ†é…å‰‡ã¨1.ã‚ˆã‚Š$\\oplus_{0\\leq i \\leq 255} HORI(input) = 0$â€‹â€‹ã«ãªã‚Šã¾ã™ã€‚ 2.ã¨1Rã®KEYã‚’å¶æ•°å›XORã™ã‚‹ã“ã¨ã«ãªã‚‹ã®ã§$\\oplus_{0\\leq i \\leq 255} XOR_1(input) = 0$ã«ãªã‚Šã¾ã™ã€‚ 3.ã«ãŠã„ã¦ç·‘ã®å ´æ‰€ã«å‡ºç¾ã—ã¦ã„ã‚‹å€¤ã¯256å€‹ã‚ã‚‹ãŸã‚ã€$\\oplus_{0\\leq i \\leq 255} SBOX(input) = 0$ã«ãªã‚Šã¾ã™ã€‚ åŒæ§˜ã®è­°è«–ã‚’çœç•¥ã—ã¾ã™ãŒã€3Rã®xorç›´å¾Œã¾ã§è¡Œã†ã“ã¨ãŒã§ãã€ã¾ãŸãã‚Œã¾ã§ã™ã¹ã¦ã®å…¥åŠ›ã«å¯¾ã—ã¦xorã‚’å–ã£ãŸå€¤ã¯0ã«ãªã‚‹éƒ¨åˆ†ã‚’é’ã§ç¤ºã—ã¾ã™ã€‚é€†ã«ã€outputå´ã‹ã‚‰é€†ç®—ã§ãã‚‹éƒ¨åˆ†ã‚’æ°´è‰²ã§ç¤ºã™ã¨ã€ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚å¼ã¨ã—ã¦ä»¥ä¸‹ã®å½¢ã«ãªã‚Šã¾ã™ã€‚\\[\\oplus_{0\\leq i \\leq 255} SBOX\\\\_INV(VERT\\\\_INV(XOR_4\\\\_INV(SBOX\\\\_INV(output_i)))) = 0\\]ä¸€åº¦ã€$SBOX\\_INV(VERT\\_INV(XOR_4\\_INV(SBOX\\_INV(output_i))))$ã«é–¢ã—ã¦è€ƒãˆã¦ã¿ã¾ã™ã€‚$SBOX\\_INV(output_i))$ã¯ç¢ºå®Ÿã«å€¤ãŒã‚ã‹ã‚‹ã®ã§$SBOX\\_INV(output_i))=outputâ€™$ã¨ã—ã¦ãŠãã¾ã™ã€‚\\[\\begin{eqnarray*}SBOX\\_INV(VERT\\_INV(XOR_4\\_INV(output'))) &amp;=SBOX\\_INV(VERT\\_INV(output' \\oplus KEY_4))\\\\&amp;= SBOX\\_INV(VERT\\_INV(output') \\oplus VERT\\_INV(KEY_4))\\end{eqnarray*}\\]$VERT\\_INV(outputâ€™)$ã¯è¨ˆç®—å¯èƒ½ã ãŒã€$VERT_INV(KEY_4)$ã¯è¨ˆç®—ã§ããªã„ãŸã‚ã“ã‚Œã®è¨ˆç®—çµæœã‚’$KEY_4â€™$ã¨ç½®ãã¨$\\oplus_{0\\leq i \\leq 255}ã€€SBOX\\_INV(VERT\\_INV(outputâ€™) \\oplus KEY_4â€™)$ã¨ãªã‚Š$SBOX\\_INV$ã¯ãã‚Œãã‚Œã®å€¤ã«å¯¾ã—ã¦æ¼”ç®—ã‚’è¡Œã†ã“ã¨ã‚’è€ƒæ…®ã™ã‚Œã°ã€$KEY_4â€™$ã®ãã‚Œãã‚Œã®å€¤ã‚’ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹ã§æ±‚ã‚ã‚Œã°ã‚ˆã„ã“ã¨ã«ãªã‚‹ã€‚ãã®æ±‚ã‚ãŸçµæœã‹ã‚‰$KEY_4$ã‚’å¾©å…ƒã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ãŸã ã„ãã¤ã‹ã®å€™è£œãŒã‚ã‚‹ãŸã‚ã©ã®éµãŒã‚ã£ã¦ã„ã‚‹ã®ã‹æœ€çµ‚çš„ã«ãƒ†ã‚¹ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚Round 5round5ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ãŒround2,4ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§è§£æ±ºã§ãã‚‹ã€‚ã“ã®ã‚ˆã†ã«ãªã‚Šã€è§£æ±ºå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚ã‚„ã£ãŸã­æœ€çµ‚çš„ãªã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚from Jenga import *from ptrlib import *import refrom itertools import productimport functoolsdef hori_inv_ret(b): for i in range(0, 9, 3): x, y, z = b[i:i+3] b[i:i+3] = ( gf_mul(x, 0x9e) ^ gf_mul(y, 0x4f), gf_mul(y, 0x9e) ^ gf_mul(z, 0x4f), gf_mul(z, 0x9e) ^ gf_mul(x, 0x4f), ) return bdef vert_inv_ret(b): for i in range(3): x, y, z = b[i], b[i + 3], b[i + 6] b[i], b[i + 3], b[i + 6] = ( gf_mul(x, 0x9e) ^ gf_mul(y, 0x4f), gf_mul(y, 0x9e) ^ gf_mul(z, 0x4f), gf_mul(z, 0x9e) ^ gf_mul(x, 0x4f), ) return bdef hori(b): for i in range(0, 9, 3): x, y, z = b[i:i+3] b[i:i+3] = ( gf_mul(x, 4) ^ gf_mul(y, 2) ^ z, gf_mul(y, 4) ^ gf_mul(z, 2) ^ x, gf_mul(z, 4) ^ gf_mul(x, 2) ^ y, ) return b def sbox_inv(b): for i in range(9): b[i] = SBOX_inv[b[i]] return bdef recover_key(last_key): last_key = last_key[::-1] for i in range(36): last_key.append(SBOX_inv[last_key[i]]^last_key[i+1]) return last_key[::-1][:9]# preparepts = [bytes(hori_inv_ret(list(bytes([i])+b\"\\x00\"*8))).hex() for i in range(256)]regex = re.compile(\"[0-9a-f]{18}\")last_key = [[] for i in range(9)]io = remote(\"nc jenga.chal.2024.ctf.acsc.asia 39425\")# io = process([\"python3\",\"task.py\"])io.sendline(\"\\n\".join(pts))print(\"SENDED\")ret = regex.findall(io.recvuntil(b\"pt? \").decode())TEST = ret[0] AIM = ret[-1]known_part = [hori_inv_ret(sbox_inv(vert_inv_ret(list(bytes.fromhex(ct))))) for ct in ret[:-1]]print(\"RECVED\")last_key = []for index in range(9): ret = [] for i in range(256): if functools.reduce(lambda x, y: x ^ y, [SBOX_inv[ct[index]^i] for ct in known_part])==0: ret.append(i) last_key.append(ret)# recover_last keyfor cand in product(*last_key): test_key = recover_key(hori(list(cand))) if Jenga(test_key).encrypt(b\"\\x00\"*9).hex() == TEST: a = Jenga(test_key).decrypt(bytes.fromhex(AIM)).hex() print(a) io.sendline(a) io.sh() print(\"found\") break# ACSC{b40a78c51c581b7478e910df9ede1f50c036eb60a1fcd9b4146c5f92c6fdd348}" }, { "title": "æœ€æ–°ç‰ˆã®sagemathã¨pythonã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«", "url": "/posts/install_sagemath/", "categories": "writeup", "tags": "tech", "date": "2024-01-22 00:00:00 +0900", "snippet": "Sagemath SageMathã¯æ•°å­¦ã®å¹…åºƒã„å‡¦ç†ã‚’æ‰±ã†ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã§ã‚ã‚‹ã€‚æ‰±ã†å‡¦ç†ã¯è¨ˆç®—æ©Ÿä»£æ•°ã€çµ„ã¿åˆã‚ã›ã€æ•°å€¤è¨ˆç®—ãªã©å¤šå²ã«åŠã¶ã€‚å·¥å­¦çš„å¿œç”¨ã«åŠ ãˆåŸºç¤ç§‘å­¦ã®ç ”ç©¶ã‚‚å¯¾å¿œã—ã¦ã„ã‚‹ã€‚ã‚ˆãCTFã§ã¤ã‹ã†ã‚„ã¤çŠ¶æ³2024å¹´3æœˆ22æ—¥ç¾åœ¨ã€Sagemathã®æœ€æ–°ç‰ˆã¯10.3, pythonã¯python3.12.2ãŒå®‰å®šãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã®æœ€æ–°ã¿ãŸã„ã§ã™ã€‚ã—ã‹ã—ã€Ubuntuã§ã¯sudo apt install sagemathã§ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã¨9.5ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã‚‹ã¯ãšã§ã™ã€‚ã“ã‚Œã¯ã¡ã‚‡ã£ã¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå¤ã„ã®ã§æœ€æ–°ã®Sagemath10.3Ã—python3.12.2ã§ç’°å¢ƒä½œã£ã¦ã„ãã¾ã™ã€‚(ç§ã¯python3.12.0ã§ã‚„ã£ã¦ã—ã¾ã£ãŸã‚“ã§ã™ãŒã€ã¾ãå¤§ä¸ˆå¤«ã‹ã¨â€¦)æ§‹ç¯‰å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªä¸€å¼ã‚’installã—ã¦ã„ãã¾ã™ã€‚æ³¨æ„ã¨ã—ã¦ã€python3ã‚’installã™ã‚‹å‰ã«è¡Œã£ã¦ãã ã•ã„(ä¸€éƒ¨ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒsagemathã®ãƒ“ãƒ«ãƒ‰ã§å¿…é ˆã¨ãªã‚Šã‚‚ã†ä¸€åº¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ç¾½ç›®ã«ãªã‚‹ã®ã§â€¦)sudo apt updatesudo apt install bc binutils bzip2 ca-certificates cliquer cmake curl ecl eclib-tools fflas-ffpack flintqs g++ gengetopt gfan gfortran git glpk-utils gmp-ecm lcalc libatomic-ops-dev libboost-dev libbraiding-dev libbrial-dev libbrial-groebner-dev libbz2-dev libcdd-dev libcdd-tools libcliquer-dev libcurl4-openssl-dev libec-dev libecm-dev libffi-dev libflint-arb-dev libflint-dev libfreetype6-dev libgc-dev libgd-dev libgf2x-dev libgiac-dev libgivaro-dev libglpk-dev libgmp-dev libgsl-dev libhomfly-dev libiml-dev liblfunction-dev liblrcalc-dev liblzma-dev libm4rie-dev libmpc-dev libmpfi-dev libmpfr-dev libncurses5-dev libntl-dev libopenblas-dev libpari-dev libpcre3-dev libplanarity-dev libppl-dev libprimesieve-dev libpython3-dev libqhull-dev libreadline-dev librw-dev libsingular4-dev libsqlite3-dev libssl-dev libsuitesparse-dev libsymmetrica2-dev libz-dev libzmq3-dev libzn-poly-dev m4 make nauty openssl palp pari-doc pari-elldata pari-galdata pari-galpol pari-gp2c pari-seadata patch perl pkg-config planarity ppl-dev python3-distutils python3-venv r-base-dev r-cran-lattice singular sqlite3 sympow tachyon tar tox xcas xz-utils tcl-dev tk-devæ¬¡ã«ã€python3.12ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ã„ãã¾ã™ã€‚Python-3.12.XXX.tgzã®XXXã¯ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã‚‚ã®ã«åå‰ã‚’å¤‰ãˆã¦ãã ã•ã„mkdir ./python &amp;&amp; cd ./pythonwget https://www.python.org/ftp/python/3.12.0/Python-3.12.XXX.tgztar -xvf Python-3.12.XXX.tgzcd Python-3.12.XXX./configure --enable-optimizationssudo make installã“ã‚Œã§pythonã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¯çµ‚ã‚ã‚Šsagemathã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’è¡Œã£ã¦ã„ãã¾ã™ã€‚sudo apt install autoconf automake libtool pkg-configwget https://ftp.riken.jp/sagemath/src/sage-10.3.tar.gztar xf sage-10.3.tar.gzcd sagegit checkout develop./configure --with-python=python3.12MAKE=\"make -j8\" makesudo ln -sf $(pwd)/sage /usr/local/binã“ã‚Œã§Sagemath10.3ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒçµ‚ã‚ã‚Šã¾ã™ã€‚æœ€å¾Œã«sageã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç¢ºèªã™ã‚Œã°å•é¡Œãªãèµ·å‹•ã—ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã¯ãšã§ã™ã€‚" }, { "title": "MAPNACTF 2024", "url": "/posts/MAPNACTF/", "categories": "writeup", "tags": "writeup", "date": "2024-01-22 00:00:00 +0900", "snippet": "MAPNACTFI participated in this CTF with team BunkyoWersterns. Our team got 1st place.I solved 5 crypto challs [Shibs, GLNQ, Be Fast, What next?, What next â…¡?] and I got 3 first blood, 1 second blood, 1 third blood.I felt interesting for all crypto chall, so I appreciate for organizer to hold this CTF event thx a lot!!Shibs [crypto 10 solves]chall#!/usr/bin/env python3from Crypto.Util.number import *from flag import flagdef shift(s, B):\tassert s &lt; len(B)\treturn B[s:] + B[:s]def gen_key(nbit):\twhile True:\t\tp = getPrime(nbit)\t\tB = bin(p)[2:]\t\tfor s in range(1, nbit):\t\t\tq = int(shift(s, B), 2)\t\t\tif isPrime(q):\t\t\t\tn = p * q\t\t\t\treturn n, p, snbit = 1024n, p, _ = gen_key(nbit)q = n // pdna = p &amp; qm = bytes_to_long(flag)c = pow(m, 65537, n)print(f'n = {n}')print(f'dna = {dna}')print(f'enc = {c}')solveIâ€™m so lazy this time, so I camp up with an idea which is â€œMAYBE WE CAN SOLVE USEING Z3â€so i created test data, concretely value of shift is 1. z3 solved this data in 5 min.if we use single thread, take time is 85 hours. but if we can use 128 thread and high power pc, estimate is 24 minutes. OK, LETS TRY.finally I got first blood. and the flag says b'MAPNA{Br4nch_&amp;_prun3_Or_4Nother_ApprOacH???}'. WE FOUND ANOTHER APPROACH ITS USE Z3.from z3 import *from subprocess import check_outputfrom multiprocessing import Pool, cpu_countfrom tqdm import tqdmn = 20316898932195904153277570911129808751568815578115203862825426326247688399447840960418077345063791379522152467572219078649052797300815169624324245983590614914067269781160218800744443132820786495383622657350005442865119235171347222481549171383138463856866590153226706585323109487068718209302113471433380661465050751463957327192775767168671487596946840993911799696944069759277414133632444513772210700794949276020219498655982617016744321984479076362225276288530893635176013522707993482886351558163399233902562390621254309853983712254751850630385079750216639722676398376824903099579116864460998259826947136455660974737633dna = 112981924875557500958025001180130494828271302148393893025039250618449754880107262891213034570290994460680732065864408219699255537220809236513831561599199136870056419874815435027857448315805793914961273026882116413167515833581245087132919209478091324962372324771986076010340277554904109601589334046901209670673enc = 3045339581292945711130813005351003100918522557110757541588006962379795819964889960982006172396478992403763951169397699477604011489683403206194674478676115307579754281253958928474112104087602753563505848223560038859380782692201785087834133116953880301903767021262497807797262966215767967235011554145888668721199447563741572273525508047234141844260401652933196055533764562153454963082569500478073362290691632890264262315099050876574517869170470080069161301450816555901477760392115210762498464643598219802952797283932722013302922244300834587051779128033516492433437534261890143822056118794447406885925957834712258842422nbit = 1024dna_ = bin(dna)[2:].zfill(nbit)p = BitVec(\"p\",nbit)q = BitVec(\"q\",nbit)def solver(i): s = Solver() s.add(q == RotateLeft(p, i)) s.add(n == p*q) s.add(p&amp;q == dna_) print(i, s.check()) if s.check() == sat: print(s.model()) _i = [i for i in range(1,nbit)]with Pool(cpu_count()) as pool: for results in tqdm(pool.imap_unordered(solver, _i), total=len(_i)): pass q = 118627270647424424141514783307481285886258073029116821903046590278901771054287488093459396876753105609837026655906589077937738668295841155401318912730133481985678923364535216697903225159999957216575823849034786092435988869550296395479754426578068176634670446795305597283053006032071267819138579464710410086097p = 171266681103878322117424575175361468379674209043813157946561665043786388947203228350875263109216690282197981858022233522587435146007011089350418152369819924630928608372164838867715907687708478655112024432448453837808032774893387899232268630799449237496392996637407630619155994281854191089804529710230573475089phi = (q-1)*(p-1)e = 0x10001d = pow(e,-1,phi)from Crypto.Util.number import *print(long_to_bytes(pow(enc,d,n)))exit()b'MAPNA{Br4nch_&amp;_prun3_Or_4Nother_ApprOacH???}'GLNQ [crypto 13 solve]chall#!/usr/bin/env sagefrom Crypto.Util.number import *from flag import flagF, k = GF(2**8), 14while True:\tG = random_matrix(F, k)\tif G.is_invertible():\t\tbreakflag = flag.lstrip(b'MAPNA{').rstrip(b'}')m = bytes_to_long(flag)H = G ** mprint(f'G = {G}')print(f'H = {H}')solvethis matrix has b-smooth order.so, we can calc discrete log for pohlig-hellman algorithm.finally I got second blood.from Crypto.Util.number import *F, k = GF(2**8), 14z8 = F.gens()[0]G = ---[sinpped]---H = ---[sinpped]---G = Matrix(F,G)H = Matrix(F,H)r = 79229371458530696292133175295def babystep_giantstep(g, y, p): m = int((p-1)**0.5 + 0.5) table = {} gr = 1 for r in range(m): table[str(gr)] = r gr = gr * g gm = g^(-m) ygqm = y for q in range(m): if str(ygqm) in table: return q * m + table[str(ygqm)] ygqm = ygqm * gm return Nonedef Pohlig_Hellman_DLP(P,sP,order): primes = [] for i,k in factor(order): primes.append(i^k) dlogs = [] for fac in primes: t = int(order) // int(fac) dlog = babystep_giantstep(P^t, sP^t, fac) assert (P^t)^dlog == sP^t dlogs += [dlog] print(\"factor: \"+str(fac)+\", Discrete Log: \"+str(dlog)) return crt(dlogs, primes )flag = int(Pohlig_Hellman_DLP(G,H,r))assert G^flag == Hprint(flag)# MAPNA{6424379811053277573417442136}Be FastğŸƒ [crypto 34 solve]chall#!/usr/bin/env python3from random import *from binascii import *from Crypto.Cipher import DESfrom signal import *import sys, osfrom flag import flagdef die(*args):\tpr(*args)\tquit()def pr(*args):\ts = \" \".join(map(str, args))\tsys.stdout.write(s + \"\\n\")\tsys.stdout.flush()def sc():\treturn sys.stdin.buffer.readline()def shift(msg, l):\tassert l &lt; len(msg)\treturn msg[l:] + msg[:l]def pad(text):\tif len(text) % 8 != 0:\t\ttext += (b'\\xff' * (8 - len(text) % 8))\treturn textdef encrypt(msg, key):\tmsg = pad(msg)\tassert len(msg) % 8 == 0\tassert len(key) == 8\tdes = DES.new(key, DES.MODE_ECB)\tenc = des.encrypt(msg)\treturn encdef main():\tborder = \"+\"\tpr(border*72)\tpr(border, \".:: Hi all, you should be fast, I mean super fact!! ::.\", border)\tpr(border, \"You should send twenty 8-byte keys to encrypt the secret message and\", border)\tpr(border, \"just decrypt the ciphertext to get the flag, Are you ready to start?\", border)\tpr(border*72)\tsecret_msg = b'TOP_SECRET:' + os.urandom(40)\t\tcnt, STEP, KEYS = 0, 14, []\tmd = 1\twhile True:\t\tpr(border, \"please send your key as hex: \")\t\t# alarm(md + 1)\t\tans = sc().decode().strip()\t\t# alarm(0)\t\ttry:\t\t\tkey = unhexlify(ans)\t\t\tif len(key) == 8 and key not in KEYS:\t\t\t\tKEYS += [key]\t\t\t\tcnt += 1\t\t\telse:\t\t\t\tdie(border, 'Kidding me!? Bye!!')\t\texcept:\t\t\tdie(border, 'Your key is not valid! Bye!!')\t\tif len(KEYS) == STEP:\t\t\tHKEY = KEYS[:7]\t\t\tshuffle(HKEY)\t\t\tNKEY = KEYS[-7:]\t\t\tshuffle(NKEY)\t\t\tfor h in HKEY: NKEY = [key, shift(key, 1)] + NKEY\t\t\tenc = encrypt(secret_msg, NKEY[0])\t\t\tfor key in NKEY[1:]:\t\t\t\tenc = encrypt(enc, key)\t\t\tpr(border, f'enc = {hexlify(enc)}')\t\t\tpr(border, f'Can you guess the secret message? ')\t\t\talarm(md + 1)\t\t\tmsg = sc().strip()\t\t\talarm(0)\t\t\tif msg == hexlify(secret_msg):\t\t\t\tdie(border, f'Congrats, you deserve the flag: {flag}')\t\t\telse:\t\t\t\tdie(border, f'Sorry, your input is incorrect! Bye!!')if __name__ == '__main__':\tmain()solvewe can send 8keys, and server makes kyes = [key, shift(key, i) for i in range(7)] + NKEY.so I send keys = [long_to_bytes(i)*8 for i in range(8)], kyes = [key, key for i in range(7)] + shuffle(kyes[-7:]).we can calc all because key patterns are 7!I got first blood!!from pwn import *from Crypto.Util.number import *from Crypto.Cipher import DESfrom itertools import permutationsdef pad(text):\tif len(text) % 8 != 0:\t\ttext += (b'\\xff' * (8 - len(text) % 8))\treturn textdef encrypt(msg, key):\tmsg = pad(msg)\tdes = DES.new(key, DES.MODE_ECB)\tenc = des.encrypt(msg)\treturn encdef decrypt(msg, key):\tdes = DES.new(key, DES.MODE_ECB)\tenc = des.decrypt(msg)\treturn enc_key = []keys_all = []for i in range(7): _key.append(long_to_bytes(i)*8)secret_msg = b'TOP_SECR'cands = []for i in permutations(_key): msg = secret_msg keys = [] for _ in range(14): msg = encrypt(msg, b\"\\x00\"*8) keys.append(b\"\\x00\"*8) print(i) for _i in i: msg = encrypt(msg, _i) keys.append(_i) cands.append(msg.hex()) keys_all.append(keys)key = \"\"for i in range(13,-1,-1): key += (long_to_bytes(i)*8).hex()+\"\\n\"io = remote(\"3.75.180.117\",37773)io.send(key)io.recvuntil(b\"enc = \")a = io.recvline().decode()enc = eval(a)enc = bytes.fromhex(enc.decode())for i in keys_all[cands.index(enc[:8].hex())][::-1]: enc = decrypt(enc,i)io.sendline(enc[:-5].hex().encode())io.interactive()# MAPNA{DES_h4s_A_f3W_5pec1f!c_kEys_7eRm3d_we4K_k3Ys_And_Sem1-wE4k_KeY5!}What next? [crypto 326 solve]chall#!/usr/bin/env python3from random import *from Crypto.Util.number import *from flag import flagdef encrypt(msg, KEY):\tm = bytes_to_long(msg)\tc = KEY ^ m\treturn cn = 80TMP = [getrandbits(256) * _ ** 2 for _ in range(n)]KEY = sum([getrandbits(256 &gt;&gt; _) for _ in range(8)]) enc = encrypt(flag, KEY)print(f'TMP = {TMP}')print(f'KEY = {KEY}')print(f'enc = {enc}')solveFirst, I donâ€™t know provide KEY, so I thought that we need to recover MTâ€™s state lol.I got third blood.import randomfrom extend_mt19937_predictor import ExtendMT19937Predictorfrom random import *from Crypto.Util.number import *predictor = ExtendMT19937Predictor()TMP = [0, 60532113298156934035006892408508955361282411773999112364347341111075018147927, 389708033651020865401865717693397865196213972164600460902422823183461779915980, 405918065202512971659130608346843374237984902589139232574420604120059844720341, 1221288278415504784467034784431436409217396366988324269872668238978249045586368, 227272449199630828507165833400505281743840056074337728659380026370174597983400, 3253503829229933909142928710502222745989372185283055446591180092486412602783216, 5285988746830110954075248573612981420829816533804399404046882938020472042330356, 1595336926944568705525401229738700126737605961193041889427425025694023495226176, 7954983836536199412561303342870946300319308569704526681942922892057412417369996, 9131160911707622814886835054526857850430982962993746463098999466544684215014000, 7533615981375704965377803926757920571133747559444638616597692539324665788824241, 9066823514420452679519089047747738557989264923523328666138044339979172532091952, 11067455968068371535244972547693443476921719558645991175617294899803940399861323, 14537042287558789972327728985738890609505033466725608088977070967810362118279248, 4572250646126446008858673089127752592787335839144590539404665629413086318239650, 6294362797378922374391238457327978545276595686984712745478781562202157935775488, 22747367842710135893711619452307079245750111941624369856170309106764880998100552, 6004893915710283480070189414407284168050988366555745204074130859740178577433240, 14420752900418475271133573248938786225809597358248108049760284685159047602036537, 43733009974069364671572839996339051940609184658654624940598489171524524051944400, 35346194693613025068395009821809884943769752588359988505793537720962714260019869, 42204169462513802238599356946318680734527685184414356760365290489529820960713072, 34277378263896547381266820799512178423239236243790865361707633583497481357796407, 65716310119362366398237218525711748744052085839683547702975404773566674635748352, 46557817276176359993118228055060795747091243514590105677103910660112788974583750, 77490786359937960192983922284789298329689351038928181926278354279011358030727124, 80111990003818834469282875276984278230143118837645016537448310618261479083651342, 20554557048628019672240583641369145446540900712224309311213526066135949044952288, 62735818615066536453205944582471026825278180907531123883210362947117955616343781, 86042719783890082289653687251665836736491344225760521302063306208331002685576500, 25965698487671814117818570753889366721907386924362900403011501627358460499758383, 29616377817002001833630895361629451907964508596441826676791174072122929285049344, 15021399892362753107059884462124333866295538287397369553705410328403621774185468, 38002604304046319679742306015002655608233191413179528560874731009946042988120788, 93295366307461634335632781504982997626366942447637302439067556300965151557831725, 13540230203788528048897000123546822994874145971630139618336417120723676174022384, 154432198666672358575141914680506005090971687803151597762263520020713308780579072, 72136447292935153078321891268785033320056922245403740454889157780753773717242568, 25501852421215926138677841658578129717118066368151623403551273037829983575243468, 126735578787059666358271681647457626985119387894943043206239792071598867033556800, 135202944925842633454294137881609034393280829104975826296437659832444402212706990, 195878634803984461306574869979621981219794907747012161075921193902109987239350696, 70016262426074427215170249788098050659024805306136436354383469618536112786361350, 35956258331474238072248600117735641962702369830606009799455005594969570110652976, 22225110718496125427125444008161845696087660990666988086936919846739655848747525, 27548874118316168690466237353230253832267098824834641381166573208182433313572936, 217350749041695488338708373584952864553819378993764330831653495907756867001916100, 257655749972831097290040240403045642767794308639832322802465135822003512301701120, 170931799252374463455850569878339599585582089254513276315581340035784063404547904, 260648666226967018693658250893274370482164362954223893135614467834502818278817500, 69425639907308137984060966310312800675576800616943121851698019398372874074587564, 38272797691322675978111710027833013466477209475584360707344650868692232767605712, 159989233909295381868776328891896676159494718709642790902586750185703386017519100, 239424076217975267533547688379482794244638593887104216992730670874367591889686424, 235805166260230600224517436738096467578276265139558424271706458619605152151155650, 312887850933221623827051251636459958804378796969233372438708909260471396708839360, 226254410804533566347737443581029620895018482953889083109343308899334155214465084, 75663356945666060728297569858199894519238029780108571803169998187745851675033696, 379521198853533961681034095706543224338730654829393858931702778389925326037905581, 146969137746310211928872994682693200202368153046275429574482720738790962130698000, 294260825765970965744028560390675570627618373545459966200549616640279283196332026, 319516693693602451939925738770832547195167488538421484010981799971938667101170272, 235996689233669489969452603688581556879686306558426802897567227857894956933720385, 129860515531400644974201481565448922647210002409167735625695108262182647544782848, 434775250558913676954052533315009488640533958618010407554959841056206485055286800, 22149580084411886515787074680813749427656731151235741580693077660337965563693340, 250909616829332329061530688103059354065323867429954924090541815760594873142372389, 190341994069073757182537956898692121864681766192223013320579410693514741018663328, 498585070302128781878557564834342148816012866139626477296471773760922822044892275, 263835635996152386059834449296099627577713122650362830498873071118489986876211700, 225673582284037816919955555063840997388361787112308169031986640074367056949780747, 361331112554037421979550439774599874333938415297694314983681794489970792139813248, 254546085100670719262378937737022676839283545191763458089424319101240909887973785, 253610597769560898884657084492335380622121458721155827380866680741694312733007816, 457274233985553849774588573500169926255994068617887370590713102886816853234873125, 449778455880514807591245873496025212715825137347886177910517238904962733456694256, 401484248501670039446475341305100595322092268787582033086127175618422362454931911, 22016053572627515851711195096973390151818785168234961407013202935121714403513020, 199223592692197859565380631569896354958045929491349287395617253114895842147327801]KEY = 23226475334448992634882677537728533150528705952262010830460862502359965393545enc = 2290064970177041546889165766737348623235283630135906565145883208626788551598431732TMP = [ t//((i+1)**2) for i, t in enumerate(TMP[1:])]print(TMP)for T in TMP: predictor.setrandbits(T, 256) KEY = sum([predictor.predict_getrandbits(256 &gt;&gt; _) for _ in range(8)]) def encrypt(msg, KEY):\tm = msg\tc = KEY ^ m\treturn cprint(long_to_bytes(encrypt(enc,KEY)))b'MAPNA{R_U_MT19937_PRNG_Predictor?}'What next II? [crypto 69 solve]chall#!/usr/bin/env python3from random import *from Crypto.Util.number import *from flag import flagdef encrypt(msg, KEY):\tm = bytes_to_long(msg)\tc = KEY ^ m\treturn cn = 80TMP = [getrandbits(256) * _ ** 2 for _ in range(n)]KEY = sum([getrandbits(256 &gt;&gt; _) ** 2 for _ in range(8)]) enc = encrypt(flag, KEY)print(f'TMP = {TMP}')print(f'enc = {enc}')solveok, version 2 donâ€™t provide a Key, but unluckily I solved this type in previous chall.so, i copied my sol lol.I got first blood in 2 minutes lmfao.import randomfrom extend_mt19937_predictor import ExtendMT19937Predictorfrom random import *from Crypto.Util.number import *predictor = ExtendMT19937Predictor()TMP = [0, 22330693840234311255135949029444484409546667648719176405826663892267656641027, 127168478027482847709328807841325386271927515479937061237117195618823278578116, 182258311374053859620888699680212168010665323374548870180038645090147843867373, 1120044041165490856498692287111236626472260308631093314161690677868431277653536, 1983473421395194676263973602935227753154638099492341714205203280778040675593450, 1574768551732085861078069762534699936995654652684634077104498873387111232412816, 4988773041677976257517254491234335651753610239922582254283447205154548743632904, 869738033317159039287197189670964123964466628318970710545560734535418094431872, 716771557072892076589368879721160406613516964478389692662921907034616035095047, 2841054733362182186252458286741823726277405165099408732758691872324732479956600, 6200268989316199565071790593244237980113705529543497656127585449937778556282311, 10670728743047162087774896911955052588177734200772863764402582886370432879158720, 7713906922622752752151916696524419287963819641354815269293605765422900017233866, 13689077681405838115291939958594572280593102467042881661528817316126253635857444, 23677404931618939684375357302211056316481456538100460743428412550112769975941300, 22334702277647520331031971258896634990832479997228972554803329027443498276011264, 24695994670269108821474844143270568317378271123560130717104045624895774803117988, 10726839246587772223823222881528936091917884797218227418638385365176143122217812, 1312747277711228023681888222399668996816715931126782050057534166588569071642948, 14829434912751138825019062212374862054511849430113519894438429231649766515851600, 4917180643387964007287001238070594020985844865025196727991425387470641537875518, 50772176246766546694026388399540445347088279634906123947563600159509306535585300, 20680598744337311676861190641592800456437920078216405214477640693225317242487078, 57560623230262776939750106414721715686651269149245752162663251361023294801081600, 63941301709699592129851769466238327968731332723117779339939586823464299930335000, 30248094445348087425063737332624900285689080519537666953907462011122884602991780, 9774708715683840095021685805936771586028623975773332766526807054152590972465402, 61228751294246951869891671407294469506401133460669313068369993608651062307301536, 41981261972157910420555352577742115252749734931422260886610665615142932761250238, 92332289648534120255700799585162857690611895814212622902006472593032842219422300, 102090694836612045964656351247645673041342905792690679450732518780700786595757872, 8465306744686231379969736050689382339949995071265316552433666241539252681451520, 114072153081233359084524715014825650254537286682603109151986752844288607088786066, 39946361462751138749261511325777846481011288953117931061771127396007551287911208, 51243479474799144289518571031495536096625532453885999576052634625243425716758700, 132356504405092579871543186323238530972479261975470487510352508943760068475015440, 109077835346013498228568867183016137777644328620298812835459712256002833220195417, 52635267919343130972014005273289555808336337947193348140410148289978267235415648, 9568343438735227407132147420705807168258684366618511035784505242511446472528193, 136103745592722122037143341370556407561964415802887285393102934361453911394982400, 15501324115571167305412632833471884183641743683875758176471163573103721210677697, 124579054262159655532164017523017564697199759561416452868759873217906475930663652, 69331433672201876294056448428159828327113921951663941374636039203754564050923557, 134825790087045765574290263555594553874136924161813224135475519279020442040026864, 127098236196925756090074171499128508507461799729629969599917408442298996799214250, 120716315173788627251671396349879537684221828425501013413665864262612928100844788, 246230945837378885729579613348413794121875158206606559652651668292953179058653508, 182436930868427241575608788617950343128628563937798409868187047670441481734494464, 2216307326510769061988701188806623458793041637834505792592287312459658319545700, 217778196427604121810125555838576095983026719310491477185297193068203986197977500, 200042153662024093707446037685450040433674498805614787040971237961725493946807124, 55096521527758008435839474651130444687406648424301616531387151625485823586357376, 315911207494925949742212443025101639383551363855632617410391325922132118052280432, 160608721274889447938606989650810386105243008009388938737103600719751998405695052, 80485718020426913778898398898436382386718914865993732581279132006386834763843750, 175256027423949464821148437330609889703365513530429385704635213979205690543187968, 312494592697141143680238564093947039458907138790072672218576868913190841311490441, 12551558878313236197845748627693664902436846005140074555532691630477757920400492, 368163678666609325358026149200535116090648801749210267074911311082497122727619418, 132244486142872991925346591101049195464960273281071718729683433268064480383763200, 187524820546739515326467479985404725103464284941528452333038247179114024353648176, 283320427018968981710753682470612392210145925235229015984823155988278867852342424, 273076274412276025537791810337835157311632197268182698230310819989050497776963263, 327014096802403962955714851262399814244813548393488285833127238998882721132883968, 206832690482752439833856322955815020186765387390104398292271480795930880106073325, 104167288428075991079921385804154376915444422785935287020330329091692992364020356, 468442878028756757484855000070722747267796721762231179211069666438706434848755245, 13006681553773847728990900149289800641720551387610802780788594468812438984199760, 199716185379958028413200192962692404940513822154864483463050473557869065589649168, 412558417168152436059170177108518481504104909389966119467224740980715361039084900, 379013360598848524426838307544021120793535763669172279637583374247930017257612752, 79510803625960975136293110699095743477640774841480691165531320726532279504009152, 119246467719878286004186703543298639812649580965124121805161153548472942538790653, 44235048729597559877492812430806736314711896199059487848598597142896457753232432, 453319033816285234767354843915966019736243075972507643199351036007057824008570000, 300975897791737470999557383409844137620736489995632513055593286593028252152372832, 488688724028459389993054497130088474659149461722402520817247390457263798063265080, 98311703485802819685121101139900586756957739352203591545958914778011243453808576, 503894794312461918204750180188338003935699664049776370432270755067603639622480931]enc = 1954128229670403595826293823451515985816812578139791173172421160740653397416251058891670696398940725266238000104900728729829302299509397650740333416176077TMP = [ t//((i+1)**2) for i, t in enumerate(TMP[1:])]print(TMP)for T in TMP: predictor.setrandbits(T, 256) KEY = sum([predictor.predict_getrandbits(256 &gt;&gt; _)** 2 for _ in range(8)]) def encrypt(msg, KEY):\tm = msg\tc = KEY ^ m\treturn cprint(long_to_bytes(encrypt(enc,KEY)))b'MAPNA{4Re_y0U_MT19937_PRNG_pr3d!cT0r_R3ven9E_4057950503c1e3992}'" }, { "title": "UofTCTF 2024", "url": "/posts/UofTCTF/", "categories": "writeup", "tags": "writeup", "date": "2024-01-14 00:00:00 +0900", "snippet": "UofTCTF 2024Export Grade Cipher [crypto 10 solve]challimport astimport threadingfrom exportcipher import *try: from flag import FLAGexcept: FLAG = \"test{FLAG}\"MAX_COUNT = 100TIMEOUT = 120 # secondsdef input_bytes(display_msg): m = input(display_msg) try: m = ast.literal_eval(m) except: # might not be valid str or bytes literal but could still be valid input, so just encode it pass if isinstance(m, str): m = m.encode() assert isinstance(m, bytes) return mdef timeout_handler(): print(\"Time is up, you can throw out your work as the key changed.\") exit()if __name__ == \"__main__\": print(\"Initializing Export Grade Cipher...\") key = int.from_bytes(os.urandom(5),\"little\") cipher = ExportGradeCipher(key) print(\"You may choose up to {} plaintext messages to encrypt.\".format(MAX_COUNT)) print(\"Recover the 40-bit key to get the flag.\") print(\"You have {} seconds.\".format(TIMEOUT)) # enough time to crack a 40 bit key with the compute resources of a government threading.Timer(TIMEOUT, timeout_handler).start() i = 0 while i &lt; MAX_COUNT: pt = input_bytes(\"[MSG {}] plaintext: \".format(i)) if not pt: break if len(pt) &gt; 512: # don't allow excessively long messages print(\"Message Too Long!\") continue nonce = os.urandom(256) cipher.init_with_nonce(nonce) ct = cipher.encrypt(pt) print(\"[MSG {}] nonce: {}\".format(i, nonce)) print(\"[MSG {}] ciphertext: {}\".format(i, ct)) # sanity check decryption cipher.init_with_nonce(nonce) assert pt == cipher.decrypt(ct) i += 1 recovered_key = ast.literal_eval(input(\"Recovered Key: \")) assert isinstance(recovered_key, int) if recovered_key == key: print(\"That is the key! Here is the flag: {}\".format(FLAG)) else: print(\"Wrong!\")import osclass LFSR: def __init__(self, seed, taps, size): assert seed != 0 assert (seed &gt;&gt; size) == 0 assert len(taps) &gt; 0 and (size - 1) in taps self.state = seed self.taps = taps self.mask = (1 &lt;&lt; size) - 1 def _shift(self): feedback = 0 for tap in self.taps: feedback ^= (self.state &gt;&gt; tap) &amp; 1 self.state = ((self.state &lt;&lt; 1) | feedback) &amp; self.mask def next_byte(self): val = self.state &amp; 0xFF for _ in range(8): self._shift() return valclass ExportGradeCipher: def __init__(self, key): # 40 bit key assert (key &gt;&gt; 40) == 0 self.key = key self.initialized = False def init_with_nonce(self, nonce): # 256 byte nonce, nonce size isnt export controlled so hopefully this will compensate for the short key size assert len(nonce) == 256 self.lfsr17 = LFSR((self.key &amp; 0xFFFF) | (1 &lt;&lt; 16), [2, 9, 10, 11, 14, 16], 17) self.lfsr32 = LFSR(((self.key &gt;&gt; 16) | 0xAB &lt;&lt; 24) &amp; 0xFFFFFFFF, [1, 6, 16, 21, 23, 24, 25, 26, 30, 31], 32) self.S = [i for i in range(256)] # Fisher-Yates shuffle S-table for i in range(255, 0, -1): # generate j s.t. 0 &lt;= j &lt;= i, has modulo bias but good luck exploiting that j = (self.lfsr17.next_byte() ^ self.lfsr32.next_byte()) % (i + 1) self.S[i], self.S[j] = self.S[j], self.S[i] j = 0 # use nonce to scramble S-table some more for i in range(256): j = (j + self.lfsr17.next_byte() ^ self.lfsr32.next_byte() + self.S[i] + nonce[i]) % 256 self.S[i], self.S[j] = self.S[j], self.S[i] self.S_inv = [0 for _ in range(256)] for i in range(256): self.S_inv[self.S[i]] = i self.initialized = True def _update(self, v): i = self.lfsr17.next_byte() ^ self.lfsr32.next_byte() self.S[v], self.S[i] = self.S[i], self.S[v] self.S_inv[self.S[v]] = v self.S_inv[self.S[i]] = i def encrypt(self, msg): assert self.initialized ct = bytes() for v in msg: ct += self.S[v].to_bytes() self._update(v) return ct def decrypt(self, ct): assert self.initialized msg = bytes() for v in ct: vo = self.S_inv[v] msg += vo.to_bytes() self._update(vo) return msgif __name__ == \"__main__\": cipher = ExportGradeCipher(int.from_bytes(os.urandom(5))) nonce = os.urandom(256) print(\"=\"*50) print(\"Cipher Key: {}\".format(cipher.key)) print(\"Nonce: {}\".format(nonce)) msg = \"ChatGPT: The Kerckhoffs' Principle, formulated by Auguste Kerckhoffs in the 19th century, is a fundamental concept in cryptography that states that the security of a cryptographic system should not rely on the secrecy of the algorithm, but rather on the secrecy of the key. In other words, a cryptosystem should remain secure even if all the details of the encryption algorithm, except for the key, are publicly known. This principle emphasizes the importance of key management in ensuring the confidentiality and integrity of encrypted data and promotes the development of encryption algorithms that can be openly analyzed and tested by the cryptographic community, making them more robust and trustworthy.\" print(\"=\"*50) print(\"Plaintext: {}\".format(msg)) cipher.init_with_nonce(nonce) ct = cipher.encrypt(msg.encode()) print(\"=\"*50) print(\"Ciphertext: {}\".format(ct)) cipher.init_with_nonce(nonce) dec = cipher.decrypt(ct) print(\"=\"*50) try: print(\"Decrypted: {}\".format(dec)) assert msg.encode() == dec except: print(\"Decryption failed\")solvesumaaryThe class ExportGradeCipher is implemented in ExportGradeCipher.py. In this class, the state is initialized by the function init_with_nonce using key and nonce. After that, the function _update constructs a nfsr(non linear shift register) of lfsr17 and lfsr32, and appears to perform encryption using them. In encrypt, after outputting the location of one character of msg in the S array as ct, the output of 256 bytes of nfsr and the location of one character of msg are swapped. def _update(self, v): i = self.lfsr17.next_byte() ^ self.lfsr32.next_byte() self.S[v], self.S[i] = self.S[i], self.S[v] def encrypt(self, msg): assert self.initialized ct = bytes() for v in msg: ct += self.S[v].to_bytes(1,\"little\") self._update(v) return ct cryptanisisSuppose we have an S array of length 4 and msg is bâ€\\x00\\x01\\x02\\x03â€ i 0 1 2 3 S[i] 2 4 6 8 If you follow the processing of the encrypt function in order, the first character is when v=0 and the ct at that time is ct[0]=2. The self._update(v) causes a swap self.S[v], self.S[i] = self.S[i], self.S[v]. We know that v=0 here, so letâ€™s assume i=1. Then the table transitions as follows. i 0 1 2 3 S[i] 4 2 6 8 We see that v in the second week is v=1 and that ct at that time is ct[1]=2. I want you to wait a moment. This time, the array S is all set to different values, so the same value ct[0]=ct[1]=2 could be used for something. S[v], self.S[i] = self.S[i], self.S[v] means that v can set itself and swap its value with the i-th value, and if the same value appears here, we know that it was swapped with the i-th value in the process at this time. So, at this point, we know the output i of the nfsr when the same value appears for the first time. The rest is a repeat of this.By the time you reach the end, you have obtained a certain amount of S array and nfsr output i. And considering that the nonce changes only S array in this setup, repeating the above process up to the upper limit will give us almost perfect nfsr output.solverTherefore, now that we have obtained the output of nfsr, we can also reverse the initial state of lfsr32 by considering that lfsr17 is within the brute force range. At this point, checking whether the upper 2bytes are such that they are 0xAB will reduce the number of candidate solutions.self.lfsr32 = LFSR(((self.key &gt;&gt; 16) | 0xAB &lt;&lt; 24) &amp; 0xFFFFFFFF, [1, 6, 16, 21, 23, 24, 25, 26, 30, 31], 32)Nevertheless, since about 30 candidates for the key remain, and considering that this cipher can only affect nonce and key, the key can be checked if the cipher is the same for that plaintext by performing the cipher again.Thus, the following is my implementation. Note that I have used a matrix to speed up the lfsr.from pwn import *import astimport randomfrom tqdm import tqdmfrom exportcipher import *class LFSR: def __init__(self, seed, taps, size): assert seed != 0 assert (seed &gt;&gt; size) == 0 assert len(taps) &gt; 0 and (size - 1) in taps self.state = seed self.size = size self.taps = taps self.mask = (1 &lt;&lt; size) - 1 self.mat = matrix(GF(2),size,size) for i in range(size-1): self.mat[i,i+1] = 1 for t in self.taps: self.mat[-1,-t-1] = 1 self.state_vec = vector(GF(2),[int(i) for i in bin(seed)[2:].zfill(size)]) def _shift(self): feedback = 0 for tap in self.taps: feedback ^^= (self.state &gt;&gt; tap) &amp; 1 self.state = ((self.state &lt;&lt; 1) | feedback) &amp; self.mask def next_byte(self): val = self.state &amp; 0xFF for _ in range(8): self._shift() return val def _shift_mat(self, k): state_vec = self.mat^(8*k)*self.state_vec return int(\"\".join([str(i) for i in list(state_vec)[-8:]]),2) def after_255_256_next_byte(self): val1 = self._shift_mat(255+256) val2 = self._shift_mat(256+256) val3 = self._shift_mat(257+256) val4 = self._shift_mat(258+256) return bytes([val1,val2,val3,val4]) def check(self, vec): vec = vector(GF(2),[int(i) for i in bin(vec[0])[2:].zfill(8)+bin(vec[1])[2:].zfill(8)+bin(vec[2])[2:].zfill(8)+bin(vec[3])[2:].zfill(8)]) self.inv_mat = self.mat^(-1) if list(self.inv_mat^(8*514)*vec)[:8] == [int(i)for i in bin(0xab)[2:].zfill(8)]: return int(\"\".join([str(i) for i in list(self.inv_mat^(8*514)*vec)[8:]]),2) return Falsedef bxor(a,b): return bytes([_a^^_b for _a,_b in zip(a,b)])lfsr17s = []lfsr32s = []for key in tqdm(range(256**2)): lfsr17 = LFSR((key &amp; 0xFFFF) | (1 &lt;&lt; 16), [2, 9, 10, 11, 14, 16], 17) lfsr17s.append(lfsr17.after_255_256_next_byte())io = remote(\"0.cloud.chals.io\",\"23753\")# io = process([\"python3\",\"chal.py\"])CNT = 256lfsr = [-1 for i in range(CNT)]pt = [(i)%256 for i in range(CNT)]for __ in tqdm(range(100)): random.shuffle(pt) io.sendlineafter(b\": \",str(bytes(pt)).encode()) nonce = ast.literal_eval(io.recvline().decode().split(\"nonce: \")[1]) ct = ast.literal_eval(io.recvline().decode().split(\"ciphertext: \")[1]) S = [-1 for i in range(256)] print(lfsr.count(-1)) for i in range(CNT): if not ct[i] in S: S[pt[i]] = ct[i] else: if lfsr[ct[:i].index(ct[i])] != -1: continue lfsr[ct[:i].index(ct[i])] = pt[i] S[pt[i]] = ct[i] S[S.index(ct[i])] = -1lfsr32 = LFSR(((0x123456 &gt;&gt; 16) | 0xAB &lt;&lt; 24) &amp; 0xFFFFFFFF, [1, 6, 16, 21, 23, 24, 25, 26, 30, 31], 32)for i in tqdm(range(256**2)): a = lfsr32.check(bxor(bytes(lfsr[:4]),lfsr17s[i])) if a != False: key1 = i key2 = a key = key1 + (key2 &lt;&lt; 16) cipher = ExportGradeCipher(key) cipher.init_with_nonce(nonce) if ct == cipher.encrypt(pt): io.sendlineafter(b\": \", str(key)) io.interactive() exit()# uoftctf{wH0_w0u1D_h4ve_7houGHt_l0ng_nONceS_CAnt_S4ve_w3ak_KeYS}" }, { "title": "cakectf 2023", "url": "/posts/cakecft/", "categories": "writeup", "tags": "writeup", "date": "2023-09-30 00:00:00 +0900", "snippet": "cakectf 2023 BunkyoWesternsã«å…¥ã‚Œã¦ã‚‚ã‚‰ã£ãŸã®ã§ãƒãƒ¼ãƒ ã§ã‚„ã£ã¦ã¾ã—ãŸã€‚è‰²ã€…åè¨€ãŒç”Ÿã¾ã‚ŒãŸã®ã§æ¥½ã—ã‹ã£ãŸã§ã™ã€‚å¾Œè²·ã£ã¦ããŸã‚±ãƒ¼ã‚­ã‚’ã¿ã‚“ãªã§é£Ÿã¹ã¾ã—ãŸã¾ã‚‹ã€‚kanon on X: â€œcakectfçµ‚ã‚ã£ãŸã®ã§ã‚±ãƒ¼ã‚­é£Ÿã¹ã¾ã™ https://t.co/Kj9xOJZACyâ€ / X (twitter.com)simple signature 88 solvechallimport osimport sysfrom hashlib import sha512from Crypto.Util.number import getRandomRange, getStrongPrime, inverse, GCDimport signalflag = os.environ.get(\"FLAG\", \"neko{cat_does_not_eat_cake}\")p = getStrongPrime(512)g = 2p = 11551622313922707550008678743003601832188036792175262302397935776595208393670456612224185992217183071863853189220628487330346803009314560368938395241129573def keygen(): while True: x = getRandomRange(2, p-1) y = getRandomRange(2, p-1) w = getRandomRange(2, p-1) v = w * y % (p-1) if GCD(v, p-1) != 1: continue u = (w * x - 1) * inverse(v, p-1) % (p-1) return (x, y, u), (w, v)def sign(m, key): x, y, u = key r = getRandomRange(2, p-1) return pow(g, x*m + r*y, p), pow(g, u*m + r, p)def verify(m, sig, key): w, v = key s, t = sig return pow(g, m, p) == pow(s, w, p) * pow(t, -v, p) % pdef h(m): return int(sha512(m.encode()).hexdigest(), 16)if __name__ == '__main__': magic_word = \"cake_does_not_eat_cat\" skey, vkey = keygen() print(f\"p = {p}\") print(f\"g = {g}\") print(f\"vkey = {vkey}\") signal.alarm(1000) while True: choice = input(\"[S]ign, [V]erify: \").strip() if choice == \"S\": message = input(\"message: \").strip() assert message != magic_word sig = sign(h(message), skey) print(f\"(s, t) = {sig}\") elif choice == \"V\": message = input(\"message: \").strip() s = int(input(\"s: \").strip()) t = int(input(\"t: \").strip()) assert 2 &lt;= s &lt; p assert 2 &lt;= t &lt; p if not verify(h(message), (s, t), vkey): print(\"invalid signature\") continue print(\"verified\") if message == magic_word: print(f\"flag = {flag}\") sys.exit(0) else: breaksolveåŸºæœ¬çš„ã«ã€å…¬é–‹éµã¨ç§˜å¯†éµã¯ä½•ã‹æ•°å­¦çš„ãªé–¢é€£æ€§ãŒå¿…è¦ã§ã‚ã‚‹ã‹ã‚‰è§£ã‘ãªã„ã‚ã‘ã§ã€ä»Šå›ã¯$x,u$ãŒå…¬é–‹éµã«ã—ã‹ä½¿ã‚ã‚Œã¦ã„ãªã„ãŸã‚ã€ãªã‚“ã§ã‚‚ãŠï½‹ã¨ãªã‚‹from pwn import *from Crypto.Util.number import getRandomRange, getStrongPrime, inverse, GCDfrom hashlib import sha512io = remote(\"crypto.2023.cakectf.com\" ,10444)# io = process([\"python3\",\"server.py\"])p = int(io.recvline().decode().split(\"= \")[1])g = int(io.recvline().decode().split(\"= \")[1])w,v = eval(io.recvline().decode().split(\"= \")[1])y = (v * pow(w,-1,p-1))%(p-1)x = getRandomRange(2, p-1)magic_word = \"cake_does_not_eat_cat\"u = ((w * x - 1) * inverse(v, p-1)) % (p-1)def h(m): return int(sha512(m.encode()).hexdigest(), 16)def sign(m, key): x, y, u = key r = getRandomRange(2, p-1) return pow(g, x*m + r*y, p), pow(g, u*m + r, p)def verify(m, sig, key): w, v = key s, t = sig print(pow(g, m, p) , pow(s, w, p) * pow(t, -v, p) % p) return pow(g, m, p) == pow(s, w, p) * pow(t, -v, p) % p# sig = sign(h(\"message\"), (x, y, u), )# print( verify(h(\"message\"), sig, (w, v)))# exit()s,t = sign(h(magic_word), (x, y, u))io.sendlineafter(b\": \",b\"V\")io.sendlineafter(b\": \",b\"cake_does_not_eat_cat\")io.sendlineafter(b\": \",str(s).encode())io.sendlineafter(b\": \",str(t).encode())io.interactive()# io.sendlineafter(b\": \",str(t).encode())# CakeCTF{does_yoshiking_eat_cake_or_cat?}janken vs yoshiking 2 43 solvechallimport randomimport signalimport osHANDNAMES = { 1: \"Rock\", 2: \"Scissors\", 3: \"Paper\"}def commit(M, m): while True: r = random.randint(2, 2**256) if r % 3 + 1 == m: break return M**r, rsignal.alarm(1000)flag = os.environ.get(\"FLAG\", \"neko{old_yoshiking_never_die,simply_fade_away}\")p = 1719620105458406433483340568317543019584575635895742560438771105058321655238562613083979651479555788009994557822024565226932906295208262756822275663694111M = random_matrix(GF(p), 5)print(\"[yoshiking]: Hello! Let's play Janken(RPS)\")print(\"[yoshiking]: Here is p: {}, and M: {}\".format(p, M.list()))round = 0wins = 0while True: round += 1 print(\"[system]: ROUND {}\".format(round)) yoshiking_hand = random.randint(1, 3) C, r = commit(M, yoshiking_hand) print(\"[yoshiking]: my commitment is={}\".format(C.list())) hand = input(\"[system]: your hand(1-3): \") print(\"\") try: hand = int(hand) if not (1 &lt;= hand &lt;= 3): raise ValueError() except ValueError: print(\"[yoshiking]: Ohhhhhhhhhhhhhhhh no! :(\") exit() print(\"[yoshiking]: My hand is ... {}\".format(HANDNAMES[yoshiking_hand])) print(\"[yoshiking]: Your hand is ... {}\".format(HANDNAMES[hand])) result = (yoshiking_hand - hand + 3) % 3 if result == 0: print(\"[yoshiking]: Draw, draw, draw!!!\") print(\"[yoshiking]: I'm only respect to win!\") print(\"[system]: you can check that yoshiking doesn't cheat\") print(\"[system]: here's the secret value: {}\".format(r)) exit() elif result == 1: print(\"[yoshiking]: Yo! You win!!! Ho!\") wins += 1 print(\"[system]: wins: {}\".format(wins)) if wins &gt;= 100: break elif result == 2: print(\"[yoshiking]: Ahahahaha! I'm the winnnnnnner!!!!\") print(\"[yoshiking]: You, good loser!\") print(\"[system]: you can check that yoshiking doesn't cheat\") print(\"[system]: here's the secret value: {}\".format(r)) exit()print(\"[yoshiking]: Wow! You are the king of roshambo!\")print(\"[yoshiking]: suge- flag ageru\")print(flag)solvematrixã§ã®DDHä»®å®šã¿ãŸã„ãªã‚‚ã®ã‚’åˆ¤å®šã—ã‚ã£ã¦ã“ã¨ã¿ãŸã„ã§ã™ã€‚ãŸã ä»Šå›ã¯å¼±ã‚ã§$M^t = Y$ã§ã®$t$ãŒ3ã§å‰²ã£ãŸã‚ã¾ã‚ŠãŒã„ãã¤ã«ãªã‚‹ã‹ã§ã™ã­ã€‚pãŒb-smoothãªã®ã§å›ºæœ‰å€¤è¨ˆç®—ã—ã¦dlpã«æŒã¡è¾¼ã‚‚ã†ã¨ã—ãŸã‘ã©ã€å›ºæœ‰å€¤ãŒãªãã©ã†ã—ãŸã‚‚ã®ã‹ã¨æ€ã£ã¦ã„ãŸã‚‰ã€å‰ã«è‡ªä½œã—ãŸã‚‚ã®ã§çµ¶å¯¾å€¤ã«è½ã¨ã—ã¦dlpãŒã§ãã‚‹ã“ã¨ã‚’æ€ã„å‡ºã—(ä¸€éƒ¨å¤±æ•—ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒ)ã‚„ã£ã¦ã¿ãŸã‚‰è§£ã‘ãŸã€‚solvefrom pwn import *from tqdm import tqdmp = 1719620105458406433483340568317543019584575635895742560438771105058321655238562613083979651479555788009994557822024565226932906295208262756822275663694111# io = process([\"sage\",\"server.sage\"])io = remote(\"crypto.2023.cakectf.com\" ,\"10555\")io.recvline()M = eval(io.recvline().decode().split(\": \")[-1])M = matrix(GF(p),[[M[i+k*5] for i in range(5)] for k in range(5)])Mdet = GF(p)(M.det())for i in tqdm(range(100)): io.recvuntil(b\"[system]: R\") io.recvline() yoshi = eval(io.recvline().decode().split(\"=\")[1]) yoshi = matrix(GF(p),[[yoshi[i+k*5] for i in range(5)] for k in range(5)]) yoshi_det = yoshi.det() nad = discrete_log(GF(p)(yoshi_det), Mdet) if int((nad)%3)+1==1: io.sendlineafter(b\": \",str(int(3)).encode()) if int((nad)%3)+1==2: io.sendlineafter(b\": \",str(int(1)).encode()) if int((nad)%3)+1==3: io.sendlineafter(b\": \",str(int(2)).encode()) io.interactive() # CakeCTF{though_yoshiking_may_die_janken_will_never_perish}ding-dong-ting-ping 17 solvechallimport osfrom base64 import b64decode, b64encodefrom hashlib import md5from datetime import datetimefrom Crypto.Cipher import AESFLAG = os.environ.get(\"FLAG\", \"neko{cat_does_not_eat_cake}\")PREFIX = os.environ.get(\"PREFIX\", \"cakecakecakecake1\").encode()KEY = os.urandom(16)IV = os.urandom(16)aes = AES.new(KEY, AES.MODE_ECB)xor = lambda a, b: bytes([x^y for x, y in zip(a, b)])def pad(data: bytes): l = 16 - len(data) % 16 return data + bytes([l]*l)def unpad(data: bytes): return data[:-data[-1]]def encrypt(plain: bytes): plain = pad(plain) blocks = [plain[i:i+16] for i in range(0, len(plain), 16)] ciphers = [IV] for block in blocks: block = xor(block, md5(ciphers[-1]).digest()) ciphers.append(aes.encrypt(block)) return b\"\".join(ciphers)def decrypt(cipher: bytes): blocks = [cipher[i:i+16] for i in range(0, len(cipher), 16)] h = md5(blocks[0]).digest() # IV plains = [] for block in blocks[1:]: plains.append(xor(aes.decrypt(block), h)) h = md5(block).digest() return unpad(b\"\".join(plains)) def register(): username = b64decode(input(\"username(base64): \").strip()) if b\"root\" in username: print(\"Cannot register as root user!\") else: cookie = b\"|\".join([PREFIX, b\"user=\"+username, str(datetime.now()).encode()]) cookie = encrypt(cookie) cookie = b64encode(cookie) print(\"your cookie =&gt;\", cookie.decode()) returndef login(): cookie = input(\"cookie: \").strip() cookie = decrypt(b64decode(cookie)) data = cookie.split(b\"|\") if (data[0] == PREFIX) and data[1].startswith(b\"user=\"): username = data[1].split(b\"=\")[1] time = data[2] else: print(\"Authentication unsuccessful...\") return print(f\"Hi, {username.decode()}! [registered at {time.decode()}]\") if username != b\"root\": print(\"You're not the root user...\") else: print(\"Ding-Dong, Ding-Dong, Welcome, root. The ultimate authority has logged in.\") print(\"This is for you =&gt; \", FLAG) returnwhile True: print(\"===== MENU =====\") choice = int(input(\"[1]register [2]login: \").strip()) if choice == 1: register() elif choice == 2: login() else: print(\"Invalid choice\") print()solveAES-CBCã®xoræ¼”ç®—ã«md5ã‚’ç”¨ã„ã¦ã‚‹ã‚‚ã®ã§ã€ã‚¨ãƒ©ãƒ¼ã‚’åã‹ãªã„é™ã‚Šã„ãã‚‰ã§ã‚‚oracleã¯ä½¿ãˆã‚‹ã€‚ã•ã‚‰ã«ã€timeã®éƒ¨åˆ†ã¯checkã•ã‚Œã¦ãªã„ã“ã¨ã‹ã‚‰ã†ã¾ãå¾©å…ƒã•ã‚Œã‚Œã°ãªã‚“ã§ã‚‚è¡¨ç¤ºã—ã¦ãã‚Œã‚‹ã€‚ã‘ã©ã€ä½¿ã‚ãªã‹ã£ãŸâ€¦orzæ–¹é‡ã¨ã—ã¦ä»»æ„ã®æš—å·æ–‡ã‚’æš—å·åŒ–ã—ã¦ãã‚Œã‚‹oracleã‚’æ§‹æˆã—ã€ãã“ã‹ã‚‰æš—å·æ–‡ã‚’çµ„ã¿ãŸã¦ã‚‹ã¨ã„ã†ä½œæ¥­ã‚’ãŠã“ãªãˆã°ãŠï½‹å•é¡Œã¨ã—ã¦ã¯ã€prefixã®é•·ã•ã«ã‚ˆã£ã¦ãƒ¡ãƒ³ãƒ‰ã‚µãŒå¤‰ã‚ã‚‹ãŒä»Šå›ã¯é‹ã‚ˆãã€17æ–‡å­—ï¼Ÿã ã£ãŸã®ã§1æ–‡å­—ã‚’ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹ã—ã¦æ±‚ã‚ã‚Œã°ã„ã„ã“ã¨ã«ãªã‚‹ã€‚import osfrom base64 import b64decode, b64encodefrom hashlib import md5from datetime import datetimefrom Crypto.Cipher import AESfrom tqdm import tqdmfrom pwn import *from itertools import productPrint = strcontext.log_level = \"debug\"def encrypt(io,m): io.sendlineafter(b\": \",b\"1\" ) io.sendlineafter(b\": \",b64encode(m)) return b64decode(io.recvline(None).split(b\"=&gt; \")[1])def decrypt(io,m): io.sendlineafter(b\": \",b\"2\" ) io.sendlineafter(b\": \",b64encode(m)) return io.recvline(None).decode()def ecb_oracle(io,m): user = b\"A\"*9 + b\"A\"*16 ret = encrypt(io,user) b = md5(ret[3*16:4*16]).digest() ret = encrypt(io,user + xor(b,m)) return ret[4*16:5*16] io = remote(\"crypto.2023.cakectf.com\" ,\"11111\")# io = process([\"python3\",\"server.py\"])enc_PREFIX = encrypt(io,b\"1\")[:2*16]ret = encrypt(io,b\"AAAAAAAAA\")[2*16:3*16]for i in range(256): if ret == ecb_oracle(io,xor(bytes([i]) + b\"|user=AAAAAAAAA\", md5(enc_PREFIX[-16:]).digest())): print(i) breakelse: print(\"NOT found\") exit()pad = b\"\\x01\"*16body1 = bytes([i])+b\"|user=root|1234\"body1 = ecb_oracle(io,xor(body1, md5(enc_PREFIX[-16:]).digest()))body2 = ecb_oracle(io,xor(pad, md5(body1).digest()))aim = enc_PREFIX + body1+ body2print(decrypt(io,aim))io.interactive()# CakeCTF{dongdingdongding-dingdong-dongdingdong-ding}" }, { "title": "åæœˆåˆé€±ã®upsolve", "url": "/posts/", "categories": "writeup", "tags": "writeup", "date": "2023-09-30 00:00:00 +0900", "snippet": "åæœˆåˆé€±ã®upsolveæ™‚é–“çš„ã«å‡ºã‚Œãªã‹ã£ãŸã‚„ã¤+è§£ã‘ãªã‹ã£ãŸã‚„ã¤ã®upsolveæ™‚é–“ãŒè¨±ã™é™ã‚Šæ›¸ã„ã¦ã¿ãŸã€‚ä»–ã«ã‚‚ã‚„ã£ãŸã‘ã©å¿˜ã‚ŒãŸâ€¦ASISCTF refactorchall#!/usr/bin/env python3from Crypto.Util.number import *from flag import flagdef pgen(nbit):\tx, y = 0, 1\twhile True:\t\tu, v = getRandomRange(1, 110), getRandomRange(1, 313)\t\tprint(u, v )\t\tx, y = u * x + 31337 * v * y, v * x - u * y\t\tif x.bit_length() &lt;= nbit // 2 and x.bit_length() &lt;= nbit // 2:\t\t\tp = x**2 + 31337 * y**2 | 1\t\t\tif isPrime(p) and p.bit_length() &gt;= nbit:\t\t\t\treturn p,x**2 + 31337 * y**2 \t\telse:\t\t\tprint()\t\t\tx, y = 0, 1def encrypt(msg, pkey):\te, n = pkey\tm = bytes_to_long(msg)\tc = pow(m, e, n)\treturn cp, q = [pgen(1024) for _ in '__']pkey = (31337, p * q)c = encrypt(flag, pkey)print(f'n = {p * q}')print(f'c = {c}')solveã¯ã˜ã‚ã¯ä¸€æ¬¡å¤‰æ›ã§ä½•ã¨ã‹ã§ãã‚“ã®ã‹ã­ã¨æ€ã£ã¦ã¾ã—ãŸãŒã€‚ã€‚ã€‚ç‰¹ã«è¡Œåˆ—ã®ç·šå½¢ã§ä½•ã¨ã‹ã§ãã‚‹ã‚ã‘ã§ã‚‚ãªãé©å½“ã«ç”Ÿæˆã—ãŸ$p = 383335841611474253288258749967087188658203719865678826202588775827454938897094153644206800790962935429622538072389187334174056071856288025761508719826829572233136259075355366784281390335902964426872367689398610556483495586882838606704940310135146159104045784806491756138016281172853224810405203956107889868800$ãŒä»¥ä¸‹ã«ç´ å› æ•°åˆ†è§£ã§ãã‚‹ã®ã§ã€$2^32 * 3^41 * 5^2 * 7^13 * 23^3 * 43^2 * 47^3 * 59^2 * 83^2 * 139 * 149 * 229 * 239 * 257 * 271 * 307 * 673 * 677 * 683 * 691 * 769 * 919 * 1163 * 1289 * 4691 * 4969 * 6229 * 9157 * 10799 * 16883 * 16979 * 29837 * 31337 * 34807 * 44953 * 65633 * 77999 * 235099 * 267781 * 271027 * 378283 * 545023 * 594469 * 644647 * 1498009 * 1535837 * 6577127 * 11794219 * 12075199 * 14300119 * 17062301 * 22574411 * 41120153 * 50521253 * 91379653 * 111311803 * 524726357 * 581782787 * 1026631601$ã•ã™ãŒã«ã€ãªã‚“ã‹ã‚ã‚‹ãªãã¨æ€ã£ã¦ã€$x_{i+1}, y_{i+1} = u_{i} * x_{i} + 31337 * v_{i} * y_{i}, v_{i} * x_{i} - u_{i} * y_{i}$ã¨æ¼¸åŒ–å¼ã‚’ç½®ã„ã¦ã€$p=x_1^2 + 31337 * y_1^2+1$ã‚’æ±‚ã‚ã‚‹ã¨ã€ãˆãˆæ„Ÿã˜ã«å› æ•°åˆ†è§£$p=(x_0^2 + 31337*y_0^2) * (u_0^2 + 31337*v_0^2)+1$ã«ãªã£ãŸã“ã¨ã‚ˆã‚Š$(u_0^2 + 31337*v_0^2)$ã®å…¨ã¦ã‚’æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã€pollardã®p-1ã§æ±‚ã¾ã‚Šãã†ãªäºˆæ„Ÿn = 15354257069173285781905276045639014609593379926482050489113547339117588412057832262093892509606681500550900795674355198875730897090963848584014735402479257641196755288572505568604616504895577156519599359709585689487167929035277328860394887100644352498762646576634768748203691626550604902474991908656069443025123380468043304218262437495617397923826383876725820263637369772201236276175774820781740263113457945850397866995318921153304724846886489062447149970082086628646772837892015556355384776002878980523779509899708723447721484662031731419684247739500573264103203416815345858413217500504527510275599764791910780108801c = 11319719392368830772976523857976369154729855326260479489071566552409492905894844561614086707874832191432242950123964961582894044688274348653418226595519872495639236324552876924940961325755770656445013054487327399663358245181836741250528901918846037855858412978924591011941242779828600098063462814300900861180897010043498668688944295535981632815932395145673684660722012731208682402231321184600968865557231738026003707732466182970622224802483189066444000715061144732475930157185474148162121034705457395021374353689284243509307079898846581316271587575615363632603786729853488699442091342820074301120194843407072588515822from Crypto.Util.number import *cand = [u**2 + 31337 * v**2 for u in range(110) for v in range(313)]tmp = Zmod(n)(c)for k in cand[1:]: tmp ^= k if GCD(tmp-1,n)!=1: p = GCD(tmp-1,n) breakelse: print(\"NOT FOUND\")q = n//pe = 31337for i in GF(p)(c).nth_root(e,all=True): if b\"ASIS\" in long_to_bytes(int(i)): print(long_to_bytes(int(i)))# ASIS{P0lL4rd5_p-1_Al9oR!7Hm_gg!!}ã‚‚ã¨ã¾ã£ãŸã€‚æ¥½maplectf RNGchallfrom Crypto.Util.number import getPrimefrom secret import flagimport randomclass RNG: def __init__(self, s, a): self.s = s self.a = a def next(self): self.s = (self.s * self.a) % (2 ** 128) return self.s &gt;&gt; 96if __name__ == \"__main__\": rng1 = RNG(getPrime(128), getPrime(64)) rng2 = RNG(getPrime(128), getPrime(64)) assert flag.startswith(\"maple{\") and flag.endswith(\"}\") flag = flag[len(\"maple{\"):-1] enc_flag = [] for i in range(0, len(flag), 4): enc_flag.append(int.from_bytes(flag[i:i+4].encode(), 'big') ^ rng1.next() ^ rng2.next()) outputs = [] for _ in range(42): if random.choice([True, False]): rng1.next() if random.choice([True, False]): rng2.next() if random.choice([True, False]): outputs.append(rng1.next()) else: outputs.append(rng2.next()) print(\"RNG 1:\", rng1.a) print(\"RNG 2:\", rng2.a) print(\"Encrypted flag:\", enc_flag) print(\"Outputs:\", outputs)solveã“ã®å•é¡ŒCTFä¸­ã¯ã‚ã‚“ã©ã™ãã¦è§£ã„ã¦ã¾ã›ã‚“ã§ã—ãŸ(ã‚ã‹ã£ãŸãªã‚‰ã‚„ã‚‹ã¹ãã ã‚ˆãªãã€åçœã—ã¦ã¾ã™)ã¾ãšã¯kurenaifã•ã‚“ã®turncated LCGã‚’è©³ã—ãè¦‹ã¦ãã ã•ã„ã€‚ã•ã¦ã€ä»Šå›ã®è¨­å®šã¨ã—ã¦ã¯2ã¤ã®LCGã®å‡ºåŠ›ãŒãƒ©ãƒ³ãƒ€ãƒ ã«ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚ãã‚‚ãã‚‚ã¨ã—ã¦turncated LCGã¯LLLã®éƒ¨åˆ†ã§é©å½“ã«å·¥å¤«ã™ã‚Œã°éé€£ç¶šã§ã‚‚è§£ã‘ã‚‹æ™‚ãŒã‚ã‚‹ã®ã§ã€ã“ã‚Œã‚’ã†ã¾ãä½¿ã£ã¦ã„ãã¾ã™ã€‚from sage.all import QQfrom sage.all import ZZfrom sage.all import matrixfrom sage.all import vector# modified for https://github.com/jvdsn/crypto-attacks/blob/master/attacks/lcg/truncated_state_recovery.pydef tlcg(y, k, s, m, a, c): diff_bit_length = k - s # Preparing for the lattice reduction. delta = c % m yi = [_[1] for _ in y] y = vector(ZZ, [_[0] for _ in y]) for i in range(len(y)): # Shift output value to the MSBs and remove the increment. y[i] = (y[i] &lt;&lt; diff_bit_length) - delta delta = (a * delta + c) % m # This lattice only works for increment = 0. B = matrix(ZZ, len(y), len(y)) B[0, 0] = m for i in range(1, len(y)): B[i, 0] = a ** yi[i] B[i, i] = -1 B = B.LLL() # Finding the target value to solve the equation for the states. b = B * y for i in range(len(b)): b[i] = round(QQ(b[i]) / m) * m - b[i] # Recovering the states delta = c % m x = list(B.solve_right(b)) for i, state in enumerate(x): # Adding the MSBs and the increment back again. x[i] = int(y[i] + state + delta) delta = (a * delta + c) % m return xfrom Crypto.Util.number import *from itertools import combinationsfrom tqdm import tqdmfrom lll import tlcga1 = 17858755236422136913a2 = 10444850750214055793ct = [3999539808, 1592738381, 1057217965, 215730455, 2499659667]Outputs = [3110779950, 3143489116, 2523808356, 59145943, 424415688, 1607693531, 2579126212, 1755297842, 3906113295, 1470215707, 3409703846, 3241626049, 3619900521, 3320623221, 2749059114, 775644902, 2452534658, 1107040405, 1783853908, 280554339, 3216758786, 2250874382, 2218107153, 4254508193, 2241158217, 2648593639, 2984582005, 3238054409, 3573713662, 2295623647, 1012063687, 1503914767, 2705122053, 2969541370, 2233703326, 1334624347, 1016155206, 2288145534, 2614694809, 1778390279, 999900406, 2501497460]Outputs2 = [3110779950, 3143489116, 2523808356, 59145943, 424415688, 1607693531, 2579126212, 1755297842, 3906113295, 1470215707, 3409703846, 3241626049, 3619900521, 3320623221, 2749059114, 775644902, 2452534658, 1107040405, 1783853908, 280554339, 3216758786, 2250874382, 2218107153, 4254508193, 2241158217, 2648593639, 2984582005, 3238054409, 3573713662, 2295623647, 1012063687, 1503914767, 2705122053, 2969541370, 2233703326, 1334624347, 1016155206, 2288145534, 2614694809, 1778390279, 999900406, 2501497460]class RNG: def __init__(self, s, a): self.s = s self.a = a self.a_inv = pow(a,-1,2 ** 128) def back(self): self.s = (self.s * self.a_inv) % (2 ** 128) return self.s &gt;&gt; 96 def next(self): self.s = (self.s * self.a) % (2 ** 128) return self.s &gt;&gt; 96def oracle(i0,i1,i2,i3,i4): for k0,k1,k2,k3,k4 in combinations(range(15), 5): y = [(Outputs[i0],k0-k0),(Outputs[i1],k1-k0),(Outputs[i2],k2-k0),(Outputs[i3],k3-k0),(Outputs[i4],k4-k0)] state1 = attack(y, 128, 128-96, 2**128, a1, 0) state2 = attack(y, 128, 128-96, 2**128, a2, 0) # print(state1) rng1 = RNG(state1[-1],a1) rng2 = RNG(state2[-1],a2) for i in range(10): if rng1.next() in Outputs: print(\"FOUND STATE1\",state1[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4)) return state1[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4) if rng2.next() in Outputs: print(\"FOUND STATE2\",state2[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4)) return state2[0],[i0,i1,i2,i3,i4],[k0,k1,k2,k3,k4] return False for i0,i1,i2,i3,i4 in tqdm(combinations(range(8), 5)): i0,i1,i2,i3,i4 = (1, 3, 4, 6, 7) tmp = oracle(i0,i1,i2,i3,i4) if tmp!=False: state1, iis, _ = tmp breakrng1 = RNG(state1,a1)rng1.back()for i in range(1000): tmp = rng1.next() if tmp in Outputs2: Outputs2[Outputs2.index(tmp)] = 0state2 = []for i in range(15): if Outputs2[i] !=0: state2.append(i)state2 = oracle(*state2[:5])[0]print(state1)print(state2)for i in range(4): for k in range(4): rng1 = RNG(state1,a1) rng2 = RNG(state2,a2) for _ in range(i): rng1.back() for _ in range(k): rng2.back() m = [] for l in range(5): m.append(long_to_bytes(ct[4-l]^rng2.back()^rng1.back())) print(m[::-1]) print()b\"maple{lcgs_and_lattices}\"" }, { "title": "åæœˆåˆé€±ã®upsolve", "url": "/posts/(copy)/", "categories": "writeup", "tags": "writeup", "date": "2023-09-30 00:00:00 +0900", "snippet": "åæœˆåˆé€±ã®upsolveæ™‚é–“çš„ã«å‡ºã‚Œãªã‹ã£ãŸã‚„ã¤+è§£ã‘ãªã‹ã£ãŸã‚„ã¤ã®upsolveæ™‚é–“ãŒè¨±ã™é™ã‚Šæ›¸ã„ã¦ã¿ãŸã€‚ä»–ã«ã‚‚ã‚„ã£ãŸã‘ã©å¿˜ã‚ŒãŸâ€¦ASISCTF refactorchall#!/usr/bin/env python3from Crypto.Util.number import *from flag import flagdef pgen(nbit):\tx, y = 0, 1\twhile True:\t\tu, v = getRandomRange(1, 110), getRandomRange(1, 313)\t\tprint(u, v )\t\tx, y = u * x + 31337 * v * y, v * x - u * y\t\tif x.bit_length() &lt;= nbit // 2 and x.bit_length() &lt;= nbit // 2:\t\t\tp = x**2 + 31337 * y**2 | 1\t\t\tif isPrime(p) and p.bit_length() &gt;= nbit:\t\t\t\treturn p,x**2 + 31337 * y**2 \t\telse:\t\t\tprint()\t\t\tx, y = 0, 1def encrypt(msg, pkey):\te, n = pkey\tm = bytes_to_long(msg)\tc = pow(m, e, n)\treturn cp, q = [pgen(1024) for _ in '__']pkey = (31337, p * q)c = encrypt(flag, pkey)print(f'n = {p * q}')print(f'c = {c}')solveã¯ã˜ã‚ã¯ä¸€æ¬¡å¤‰æ›ã§ä½•ã¨ã‹ã§ãã‚“ã®ã‹ã­ã¨æ€ã£ã¦ã¾ã—ãŸãŒã€‚ã€‚ã€‚ç‰¹ã«è¡Œåˆ—ã®ç·šå½¢ã§ä½•ã¨ã‹ã§ãã‚‹ã‚ã‘ã§ã‚‚ãªãé©å½“ã«ç”Ÿæˆã—ãŸ$p = 383335841611474253288258749967087188658203719865678826202588775827454938897094153644206800790962935429622538072389187334174056071856288025761508719826829572233136259075355366784281390335902964426872367689398610556483495586882838606704940310135146159104045784806491756138016281172853224810405203956107889868800$ãŒä»¥ä¸‹ã«ç´ å› æ•°åˆ†è§£ã§ãã‚‹ã®ã§ã€$2^32 * 3^41 * 5^2 * 7^13 * 23^3 * 43^2 * 47^3 * 59^2 * 83^2 * 139 * 149 * 229 * 239 * 257 * 271 * 307 * 673 * 677 * 683 * 691 * 769 * 919 * 1163 * 1289 * 4691 * 4969 * 6229 * 9157 * 10799 * 16883 * 16979 * 29837 * 31337 * 34807 * 44953 * 65633 * 77999 * 235099 * 267781 * 271027 * 378283 * 545023 * 594469 * 644647 * 1498009 * 1535837 * 6577127 * 11794219 * 12075199 * 14300119 * 17062301 * 22574411 * 41120153 * 50521253 * 91379653 * 111311803 * 524726357 * 581782787 * 1026631601$ã•ã™ãŒã«ã€ãªã‚“ã‹ã‚ã‚‹ãªãã¨æ€ã£ã¦ã€$x_{i+1}, y_{i+1} = u_{i} * x_{i} + 31337 * v_{i} * y_{i}, v_{i} * x_{i} - u_{i} * y_{i}$ã¨æ¼¸åŒ–å¼ã‚’ç½®ã„ã¦ã€$p=x_1^2 + 31337 * y_1^2+1$ã‚’æ±‚ã‚ã‚‹ã¨ã€ãˆãˆæ„Ÿã˜ã«å› æ•°åˆ†è§£$p=(x_0^2 + 31337*y_0^2) * (u_0^2 + 31337*v_0^2)+1$ã«ãªã£ãŸã“ã¨ã‚ˆã‚Š$(u_0^2 + 31337*v_0^2)$ã®å…¨ã¦ã‚’æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã€pollardã®p-1ã§æ±‚ã¾ã‚Šãã†ãªäºˆæ„Ÿn = 15354257069173285781905276045639014609593379926482050489113547339117588412057832262093892509606681500550900795674355198875730897090963848584014735402479257641196755288572505568604616504895577156519599359709585689487167929035277328860394887100644352498762646576634768748203691626550604902474991908656069443025123380468043304218262437495617397923826383876725820263637369772201236276175774820781740263113457945850397866995318921153304724846886489062447149970082086628646772837892015556355384776002878980523779509899708723447721484662031731419684247739500573264103203416815345858413217500504527510275599764791910780108801c = 11319719392368830772976523857976369154729855326260479489071566552409492905894844561614086707874832191432242950123964961582894044688274348653418226595519872495639236324552876924940961325755770656445013054487327399663358245181836741250528901918846037855858412978924591011941242779828600098063462814300900861180897010043498668688944295535981632815932395145673684660722012731208682402231321184600968865557231738026003707732466182970622224802483189066444000715061144732475930157185474148162121034705457395021374353689284243509307079898846581316271587575615363632603786729853488699442091342820074301120194843407072588515822from Crypto.Util.number import *cand = [u**2 + 31337 * v**2 for u in range(110) for v in range(313)]tmp = Zmod(n)(c)for k in cand[1:]: tmp ^= k if GCD(tmp-1,n)!=1: p = GCD(tmp-1,n) breakelse: print(\"NOT FOUND\")q = n//pe = 31337for i in GF(p)(c).nth_root(e,all=True): if b\"ASIS\" in long_to_bytes(int(i)): print(long_to_bytes(int(i)))# ASIS{P0lL4rd5_p-1_Al9oR!7Hm_gg!!}ã‚‚ã¨ã¾ã£ãŸã€‚æ¥½maplectf RNGchallfrom Crypto.Util.number import getPrimefrom secret import flagimport randomclass RNG: def __init__(self, s, a): self.s = s self.a = a def next(self): self.s = (self.s * self.a) % (2 ** 128) return self.s &gt;&gt; 96if __name__ == \"__main__\": rng1 = RNG(getPrime(128), getPrime(64)) rng2 = RNG(getPrime(128), getPrime(64)) assert flag.startswith(\"maple{\") and flag.endswith(\"}\") flag = flag[len(\"maple{\"):-1] enc_flag = [] for i in range(0, len(flag), 4): enc_flag.append(int.from_bytes(flag[i:i+4].encode(), 'big') ^ rng1.next() ^ rng2.next()) outputs = [] for _ in range(42): if random.choice([True, False]): rng1.next() if random.choice([True, False]): rng2.next() if random.choice([True, False]): outputs.append(rng1.next()) else: outputs.append(rng2.next()) print(\"RNG 1:\", rng1.a) print(\"RNG 2:\", rng2.a) print(\"Encrypted flag:\", enc_flag) print(\"Outputs:\", outputs)solveã“ã®å•é¡ŒCTFä¸­ã¯ã‚ã‚“ã©ã™ãã¦è§£ã„ã¦ã¾ã›ã‚“ã§ã—ãŸ(ã‚ã‹ã£ãŸãªã‚‰ã‚„ã‚‹ã¹ãã ã‚ˆãªãã€åçœã—ã¦ã¾ã™)ã¾ãšã¯kurenaifã•ã‚“ã®turncated LCGã‚’è©³ã—ãè¦‹ã¦ãã ã•ã„ã€‚ã•ã¦ã€ä»Šå›ã®è¨­å®šã¨ã—ã¦ã¯2ã¤ã®LCGã®å‡ºåŠ›ãŒãƒ©ãƒ³ãƒ€ãƒ ã«ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚ãã‚‚ãã‚‚ã¨ã—ã¦turncated LCGã¯LLLã®éƒ¨åˆ†ã§é©å½“ã«å·¥å¤«ã™ã‚Œã°éé€£ç¶šã§ã‚‚è§£ã‘ã‚‹æ™‚ãŒã‚ã‚‹ã®ã§ã€ã“ã‚Œã‚’ã†ã¾ãä½¿ã£ã¦ã„ãã¾ã™ã€‚from sage.all import QQfrom sage.all import ZZfrom sage.all import matrixfrom sage.all import vector# modified for https://github.com/jvdsn/crypto-attacks/blob/master/attacks/lcg/truncated_state_recovery.pydef tlcg(y, k, s, m, a, c): diff_bit_length = k - s # Preparing for the lattice reduction. delta = c % m yi = [_[1] for _ in y] y = vector(ZZ, [_[0] for _ in y]) for i in range(len(y)): # Shift output value to the MSBs and remove the increment. y[i] = (y[i] &lt;&lt; diff_bit_length) - delta delta = (a * delta + c) % m # This lattice only works for increment = 0. B = matrix(ZZ, len(y), len(y)) B[0, 0] = m for i in range(1, len(y)): B[i, 0] = a ** yi[i] B[i, i] = -1 B = B.LLL() # Finding the target value to solve the equation for the states. b = B * y for i in range(len(b)): b[i] = round(QQ(b[i]) / m) * m - b[i] # Recovering the states delta = c % m x = list(B.solve_right(b)) for i, state in enumerate(x): # Adding the MSBs and the increment back again. x[i] = int(y[i] + state + delta) delta = (a * delta + c) % m return xfrom Crypto.Util.number import *from itertools import combinationsfrom tqdm import tqdmfrom lll import tlcga1 = 17858755236422136913a2 = 10444850750214055793ct = [3999539808, 1592738381, 1057217965, 215730455, 2499659667]Outputs = [3110779950, 3143489116, 2523808356, 59145943, 424415688, 1607693531, 2579126212, 1755297842, 3906113295, 1470215707, 3409703846, 3241626049, 3619900521, 3320623221, 2749059114, 775644902, 2452534658, 1107040405, 1783853908, 280554339, 3216758786, 2250874382, 2218107153, 4254508193, 2241158217, 2648593639, 2984582005, 3238054409, 3573713662, 2295623647, 1012063687, 1503914767, 2705122053, 2969541370, 2233703326, 1334624347, 1016155206, 2288145534, 2614694809, 1778390279, 999900406, 2501497460]Outputs2 = [3110779950, 3143489116, 2523808356, 59145943, 424415688, 1607693531, 2579126212, 1755297842, 3906113295, 1470215707, 3409703846, 3241626049, 3619900521, 3320623221, 2749059114, 775644902, 2452534658, 1107040405, 1783853908, 280554339, 3216758786, 2250874382, 2218107153, 4254508193, 2241158217, 2648593639, 2984582005, 3238054409, 3573713662, 2295623647, 1012063687, 1503914767, 2705122053, 2969541370, 2233703326, 1334624347, 1016155206, 2288145534, 2614694809, 1778390279, 999900406, 2501497460]class RNG: def __init__(self, s, a): self.s = s self.a = a self.a_inv = pow(a,-1,2 ** 128) def back(self): self.s = (self.s * self.a_inv) % (2 ** 128) return self.s &gt;&gt; 96 def next(self): self.s = (self.s * self.a) % (2 ** 128) return self.s &gt;&gt; 96def oracle(i0,i1,i2,i3,i4): for k0,k1,k2,k3,k4 in combinations(range(15), 5): y = [(Outputs[i0],k0-k0),(Outputs[i1],k1-k0),(Outputs[i2],k2-k0),(Outputs[i3],k3-k0),(Outputs[i4],k4-k0)] state1 = attack(y, 128, 128-96, 2**128, a1, 0) state2 = attack(y, 128, 128-96, 2**128, a2, 0) # print(state1) rng1 = RNG(state1[-1],a1) rng2 = RNG(state2[-1],a2) for i in range(10): if rng1.next() in Outputs: print(\"FOUND STATE1\",state1[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4)) return state1[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4) if rng2.next() in Outputs: print(\"FOUND STATE2\",state2[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4)) return state2[0],[i0,i1,i2,i3,i4],[k0,k1,k2,k3,k4] return False for i0,i1,i2,i3,i4 in tqdm(combinations(range(8), 5)): i0,i1,i2,i3,i4 = (1, 3, 4, 6, 7) tmp = oracle(i0,i1,i2,i3,i4) if tmp!=False: state1, iis, _ = tmp breakrng1 = RNG(state1,a1)rng1.back()for i in range(1000): tmp = rng1.next() if tmp in Outputs2: Outputs2[Outputs2.index(tmp)] = 0state2 = []for i in range(15): if Outputs2[i] !=0: state2.append(i)state2 = oracle(*state2[:5])[0]print(state1)print(state2)for i in range(4): for k in range(4): rng1 = RNG(state1,a1) rng2 = RNG(state2,a2) for _ in range(i): rng1.back() for _ in range(k): rng2.back() m = [] for l in range(5): m.append(long_to_bytes(ct[4-l]^rng2.back()^rng1.back())) print(m[::-1]) print()b\"maple{lcgs_and_lattices}\"" }, { "title": "DEF CON31å‚åŠ è¨˜", "url": "/posts/DEFCON/", "categories": "DEF CON31", "tags": "DEF CON31", "date": "2023-08-26 00:00:00 +0900", "snippet": "DEF CON31å‚åŠ è¨˜ã€€DEF CONã¨ã¯â€¦? ã‚¢ãƒ¡ãƒªã‚«ã®ãƒ©ã‚¹ãƒ™ã‚¬ã‚¹ã§æ¯å¹´é–‹å‚¬ã•ã‚Œã‚‹ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚„æƒ…å ±ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¼ã«é–¢ä¿‚ã—ãŸä¸–ç•Œæœ€å¤§è¦æ¨¡ã®ã‚¤ãƒ™ãƒ³ãƒˆã¾ã‚“ã¾ã“ã®é€šã‚Šã§ã™ã­ã€‚ã‚¤ãƒ™ãƒ³ãƒˆã«ã¯villageã‚„contestsãªã©ãŒã‚ã‚Šã¾ã—ã¦ã€ãã‚Œãã‚Œã«æ²¿ã£ãŸãƒ†ãƒ¼ãƒã«é–¢ã™ã‚‹ä½“é¨“ã‚„CTFã€è¬›æ¼”ã‚’èãã“ã¨ãŒã§ãã¾ã™ã€‚DEF CON CTF 2023 QualifiersDEF CON finalã¸ã®å‡ºå ´ã‚’å¾—ã‚‹ãŸã‚ã®äºˆé¸ãŒ5/27 0:00~5/29 0:00(UTC)ã«è¡Œã‚ã‚Œã¦ã„ã¾ã—ãŸã€‚å®Ÿã¯ç§ã‚‚åˆ¥ãƒãƒ¼ãƒ (if this doesnâ€™t work weâ€™ll get more for next year)ã§å‚åŠ ã—ã¦ã„ã¾ã—ãŸãŒã€15ä½ã§è² ã‘ã¦ã—ã¾ã—ã¾ã—ãŸã€‚ã•ã‚‰ã«ã€å•é¡Œè‡ªä½“ãŒrevãƒ»pwnãŒ8å‰²ã‚’å ã‚ã¦ã„ã‚‹ãŸã‚å¾—æ„åˆ†é‡ãŒcryptoãªç§ã¯ã€æ¤…å­ã‚’æ¸©ã‚ã¦ã„ã‚‹ã ã‘ã§ã—ãŸã€‚(ï¼‘ã¤cryptoã£ã½ã„ã‚‚ã®ãŒã‚ã‚Šã¾ã—ãŸãŒã€å”¯ã®æš—å·ã‚½ãƒ ãƒªã‚¨ã¿ãŸã„ã«æš—å·ã‚’ç‰¹å®šã™ã‚‹ã ã‘ã®å•é¡Œã§ã—ãŸ)ãªã®ã§ã€å®Ÿã¯DEFCONã«è¡Œãäºˆå®šã¯ã•ã‚‰ã•ã‚‰ãªã‹ã£ãŸã‚“ã§ã™ã‚ˆã­â€¦CTFtime.org / DEF CON CTF Qualifier 2023DEFCON è¡ŒãçµŒç·¯ãƒªãƒ¼ãƒ€ãƒ¼ã®sahuangã•ã‚“ãŒè¡Œãäººã„ã‚‹ã‹ã¨èã„ã¦ã„ãŸã®ã§ã€ãã“ã§ã€Œå¤šåˆ†?ã€ã£ã¦ç­”ãˆãŸã®ãŒå§‹ã¾ã‚Šã§ã™ã€‚ï¼ˆç­”ãˆã¦ã„ãªã‹ã£ãŸã‚‰æ—¥æœ¬ã‹ã‚‰twitterã‚’çœºã‚ã¦ã„ãŸæ°—ãŒã™ã‚‹ï¼‰ã¾ã˜ã§ã€æ„Ÿè¬ã—ã¦ã¾ã™ã€‚æº–å‚™ã‚„ã£ãŸã“ã¨ã¯å°‘ãªãã¦ã€è·é€ ã‚Šã€ESTAã®ç”³è«‹ã€èˆªç©ºæ©Ÿã®ãƒã‚±ãƒƒãƒˆç¢ºä¿ã€ãƒ­ãƒ¼ãƒŸãƒ³ã‚°ã®ç”³è«‹ã ã‘ã§ã™ã­ã€‚è·é€ ã‚Šãƒ•ãƒ©ã‚¤ãƒˆã®åŠæœˆå‰ã«satokiå›ã‹ã‚‰ã€Œä¼šå ´ã¯ããå¯’ã„ã‹ã‚‰ãƒ‘ãƒ¼ã‚«ãƒ¼æŒã£ã¦ã„ãã¨ã„ã„ã€ã¨äº‹å‰ã«èã„ã¦ã„ãŸã®ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€è·é€ ã‚Šã®æ™‚ç‚¹ã§ã™ã£ã‹ã‚Šå¿˜ã‚Œã¦å…¥ã‚Œã¦ã„ãªã‹ã£ãŸã®ã§ã™ãŒã€DEFCONãƒ•ãƒ©ã‚¤ãƒˆå‰æ—¥ã®ã‚¹ãƒšãƒ¼ã‚¹ã§è¨€ã‚ã‚Œã¦æ€¥ã„ã§é­”å¥³ãƒ‘ãƒ¼ã‚«ãƒ¼ã¨ã‚«ãƒ¼ãƒ‡ã‚£ã‚¬ãƒ³ã‚’è©°ã‚è¾¼ã¿ã¾ã—ãŸã€‚ã‚ã¨ã¯ã€æ©Ÿå†…goodsã¨ã—ã¦ãŠã—ã‚Šã«æ•·ãç”¨ã®è†¨ã‚‰ã¾ã›ã‚‹åº§å¸ƒå›£ã‚’è²·ã„ã¾ã—ãŸã€‚ESTAã®ç”³è«‹ESTAã¯ç”³è«‹ã—ã¦ã‹ã‚‰2æ™‚é–“ã§æ‰¿èªãŒé€šã£ãŸã®ã§ç‰¹ã«æ°—ã«ã™ã‚‹å¿…è¦ã¯ãªã‹ã£ãŸã§ã™ã­ã€‚èˆªç©ºæ©Ÿã®ãƒã‚±ãƒƒãƒˆã®ç¢ºä¿èˆªç©ºæ©Ÿã®ãƒã‚±ãƒƒãƒˆã¯ç·é¡32ä¸‡ãã‚‰ã„ã—ãŸæ°—ãŒã—ã¾ã™ã€‚å€¤æ®µã‚’æŠ‘ãˆãŸã„ã®ãªã‚‰æ—©ã‚ã«ã¨ã‚‹ã“ã¨ã‚’å¼·ããŠå‹§ã‚ã—ã¾ã™ã€‚ãƒ­ãƒ¼ãƒŸãƒ³ã‚°ã®ç”³è«‹æµ·å¤–ã§è‡ªåˆ†ã®æºå¸¯ã‚’ä½¿ãŠã†ã¨ã™ã‚‹ã¨ã€ãƒ¢ãƒã‚¤ãƒ«ãƒ«ãƒ¼ã‚¿ãƒ¼ã‹ãƒ­ãƒ¼ãƒŸãƒ³ã‚°ã®ç”³è«‹ãŒå¿…è¦ã§ã™ã€‚ãƒ¢ãƒã‚¤ãƒ«ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚’æŒã¡æ­©ãã®ã¯é¢å€’ãªã®ã§æºå¸¯ä¼šç¤¾ã«ãƒ­ãƒ¼ãƒŸãƒ³ã‚°ã®ç”³è«‹ã‚’ã—ã¦ãã®ã¾ã¾æ¥ç¶šã™ã‚Œã°ã€ä½¿ãˆã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚ãƒ•ãƒ©ã‚¤ãƒˆå½“æ—¥ãƒ•ãƒ©ã‚¤ãƒˆãƒ«ãƒ¼ãƒˆã¯æˆç”°â†’ã‚·ã‚¢ãƒˆãƒ«â†’ãƒ©ã‚¹ãƒ™ã‚¬ã‚¹ã‚’2ã¤ã®èˆªç©ºä¼šç¤¾ã‚’ä½¿ã†ãƒ«ãƒ¼ãƒˆã§å–ã‚Šã¾ã—ãŸã€‚ æˆç”°â†’ã‚·ã‚¢ãƒˆãƒ«ã¯JAL ã‚·ã‚¢ãƒˆãƒ«â†’ãƒ©ã‚¹ãƒ™ã‚¬ã‚¹ã¯ã‚¢ãƒ©ã‚¹ã‚«èˆªç©ºæˆç”°â†’ã‚·ã‚¢ãƒˆãƒ«ãƒ•ãƒ©ã‚¤ãƒˆæ™‚é–“ã¯8æ™‚é–“ç¨‹åº¦ã ã£ãŸã‹ãªâ€¦?(å±¥æ­´ãŒãªãã¦é¡ã‚Œãªã„) ãªã®ã§ã€åº§å¸ƒå›£ã§ä½“å‹¢ã‚’å¤‰ãˆã‚‹ï¼‹ã¡ã‚‡ã£ã¨ã—ãŸé‹å‹•ã§ä½“ã‚’ã»ãã—ã¦ã¾ã—ãŸã€‚ãŸã ã€ãã‚Œã§ã‚‚è¶³ãŒç—›ã‹ã£ãŸã®ã§è€ƒãˆç‰©ã§ã™ã­â€¦æ©Ÿå†…ã§ã¯ã€å¯ã‚‹ã‹æ˜ ç”»è¦‹ã¦ã¾ã—ãŸã€‚ã‚·ã‚¢ãƒˆãƒ«â†’ãƒ©ã‚¹ãƒ™ã‚¬ã‚¹ã“ã“ã§ã€ã¾ã•ã‹ã®ã‚·ã‚¢ãƒˆãƒ«è¡Œãã®é£›è¡Œæ©Ÿã§ãŸã¾ãŸã¾åŒã˜é£›è¡Œæ©Ÿã«ä¹—ã£ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šæ€¥é½åˆæµã—ã¦ã€å…¥å›½å¯©æŸ»ã‚’æ¸ˆã¾ã›ã¦ã‚·ã‚¢ãƒˆãƒ«ãƒ©ã‚¹ãƒ™ã‚¬ã‚¹è¡Œãã®é£›è¡Œæ©Ÿã«ä¹—ã‚Šã¾ã—ãŸã€‚è‡ªå¸­ã«åº§ã‚‹ã¨éš£ã«æ—¥æœ¬äººã®æ–¹ãŒãŠã‚‰ã‚Œã¾ã—ãŸã€‚æ›´ã«åå¯¾å´ã®å¸­ã«ã¯å¤–å›½ã®æ–¹åº§ã‚‰ã‚Œã¦ã€ãŠäºŒæ–¹ã¨ã‚‚DEFCONè¡Œãã¨ã®ã“ã¨ã ã£ãŸã®ã§æƒ…å ±äº¤æ›å…¼ã­ã¤ã¤è«‡ç¬‘ã—ã¦ã¾ã—ãŸã€‚é£›è¡Œæ©Ÿã‹ã‚‰è¦‹ã‚‹æ™¯è‰²ã¯ãšã£ã¨å²©ã ã‚‰ã‘ã§ç”ºãŒã‚ã‚‹ã®ã‹æ­£ç›´ç–‘ã„ã¾ã—ãŸã€‚DECFON DAY 0é£›è¡Œæ©Ÿã‹ã‚‰é™ã‚Šã‚‹ã¨å…ˆã«ã¤ã„ã¦ã„ã‚‹sahuangã•ã‚“ã¨åˆæµã—ã€enscribeã•ã‚“ã¨ã¯å¾Œã‹ã‚‰åˆæµæµã‚Œã¨ãªã‚Šã¾ã—ãŸãŒã€enscribeã•ã‚“ã®é£›è¡Œæ©ŸãŒä¸é‹ãªã“ã¨ã«2æ™‚é–“åŠç¨‹åº¦é…ã‚Œã‚‹ã“ã¨ã«â€¦ã“ã“ã§ã€kurenaifã•ã‚“ã¨ã¯ãŠåˆ¥ã‚Œã—ã€sahuangã•ã‚“ã¨enscribeã•ã‚“ã‚’ç©ºæ¸¯ã®å¤–ã®ã‚¹ã‚¿ãƒã§å¾…ã¤ã“ã¨ã«ãªã‚Šã€ä»Šåº¦è¡Œã†SekaiCTFã®å•é¡Œã‚„éŸ³ã‚²ãƒ¼ã«ã¤ã„ã¦è©±ã—ã¦ã¾ã—ãŸã€‚(ãŸã éŸ³ã‚²ãƒ¼ã‚„ã‚‹ã®ãŒä¹…ã—ã¶ã‚Šã™ãã¦ã€ããé›‘é­šã‹ã¾ã—ã¦ã„ãŸã®ã¯å†…ç·’)ã¨ã„ã†ã‚ã‘ã§ã€enscribeã¨åˆæµã—ã¦ã‹ã‚‰ãƒ›ãƒ†ãƒ«ã¾ã§uberã§å‘ã„ã€ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ã‚’æ¸ˆã¾ã›ã€legoclonesã•ã‚“ã€zafirrã•ã‚“ã€ã‚„CSN3RDã•ã‚“ã¨æ›´ã«åˆæµã—æ™©é£¯ã‚’é£Ÿã¹ã¦ã¾ã—ãŸã€‚ã›ã£ã‹ããªã®ã§ã‚«ã‚¸ãƒã‚„ã‚‹ã‹ã¨ã„ã†è©±ã«ãªã‚Šã€CSN3RDã•ã‚“ãŒATMã‹ã‚‰å¼•ãå‡ºãã†ã¨ã™ã‚‹ã¨å¼•ãå‡ºã›ãªã„ã¨ã„ã†è¬ãªçŠ¶æ³ã‚‚ã‚ã‚Šã¾ã—ãŸãŒã€ã¨ã‚Šã‚ãˆãšç§ã¯é©å½“ã«åº§ã£ã¦20$å…¥ã‚Œã¦éŠã‚“ã§ãŸã‚‰è¬ã«110$å½“ãŸã£ã¦çµæœçš„ã«+110å„²ã‘ã¾ã—ãŸã€‚(æ®‹ã‚Šã®ãƒ©ã‚¹ãƒ™ã‚¬ã‚¹ã§ã®ç”Ÿæ´»ã¯ã»ã¨ã‚“ã©ã“ã®ãŠé‡‘ã§éã”ã—ã¦ã„ãŸè¨˜æ†¶ã§ã™ã­â€¦)DEF CON DAY 1(8/10)DEFCONã«å…¥å ´ã™ã‚‹ãŸã‚ã«ã¯badgeãŒå¿…è¦ã§ã€äº‹å‰ã«ç”³ã—è¾¼ã‚“ã§ã„ãŸåˆ†ã®å—ã‘å–ã‚Šã‚’ã—ãªã„ã¨ã„ã‘ãªã„ã®ã§çš†ã§å—ã‘å–ã£ã¦ã„ã¾ã—ãŸã€‚ãã®å¾Œã¯HTBã®ãƒ–ãƒ¼ã‚¹ã«ãªã ã‚Œè¾¼ã‚“ã§Sekai + æ•°åã§HTB CTFã‚’ã‚„ã‚‹ã“ã¨ã«ã€ãŸã å•é¡Œã¨ã—ã¦ç§ã®è‹±èªãŒã‚«ã‚¹ãªã®ã¨PCã‚’ãƒ›ãƒ†ãƒ«ã«ç½®ã„ãŸã¾ã‚“ã¾ã ã£ãŸã®ã§ã€è‡ªåˆ†ã§å‹æ‰‹ã«ã§ãã‚‹ã“ã¨ã‚‚ãªãæ„æ€ç–é€šã«ã¨ã‚“ã§ã‚‚ãªãè‹¦åŠ´ã—ã¾ã—ãŸãŒã€çµæœçš„ã«sahuangã•ã‚“ã‚„quaserã•ã‚“ãŒã„ãŸã®ã§cryotoã¯é€Ÿæ”»çµ‚ã‚ã‚Šã€ä»–ã®ã‚¸ãƒ£ãƒ³ãƒ«ã¯ã‚ã‹ã‚‰ã‚“ã®ã§ã¶ã£ã¡ã‚ƒã‘æš‡ãªæ™‚é–“ã¨ãªã£ã¦ã¾ã—ãŸã€‚ãã†ã“ã†ã—ã¦ã„ã‚‹ã¨é‹å–¶ã®æ–¹ãŒæ¥ã‚‰ã‚Œã¦ä¸€ç·’ã«å†™çœŸæ’®ã£ãŸã‚Šã€ã‚°ãƒƒã‚ºã‚’ã‚‚ã‚‰ã£ãŸã‚Šã—ã¦ã‚ã‚ŠãŒãŸã‹ã£ãŸã§ã™ã€‚ãã®å¾Œã€kurenaifã•ã‚“ãŒã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã—ã¦ã„ã‚‹tweetã‚’è¦‹ã‹ã‘ãŸã®ã§ã€HTBã‚’æŠœã‘ã¦kurenaifã•ã‚“ã¨åˆæµã—ã¦ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³ãƒ»ã‚·ãƒ§ãƒ¼ãƒ»ãƒ©ã‚¹ãƒ»ãƒ™ã‚¬ã‚¹ã«è¡Œãã€ãããƒ‡ã‚«ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ«ã®ä¸­ã‚’æ•£ç­–ã—ã¦ã¾ã—ãŸã€‚ãã®å¾Œã€satoooonã•ã‚“ã¨ã‚Œã£ãã™ã•ã‚“ãŒsekaiã¨åˆæµã—ã¦ã„ã‚‹ã¨ã„ã†ã®ã‚’kurenaifã•ã‚“ã‹ã‚‰ãŠèãã—ã¦ç§ãŸã¡ã‚‚åˆæµã™ã‚‹ã“ã¨ã«ã—ãŸã®ã¯ã„ã„ã‚‚ã®ã®â€¦é€”ä¸­è¿·å­ã«ãªã£ã¦ã‚ãƒ¼ã ãƒ¼ã“ã†ã ã„ã„ã¤ã¤ä½•ã¨ã‹ï¼Ÿåˆæµå ´æ‰€ã«ãŸã©ã‚Šç€ãã“ã¨ãŒã§ãã¾ã—ãŸã€‚ãã®å¾Œã€æ—¥æœ¬ãƒãƒƒã‚¯ãªã‚²ãƒ¼ã‚»ãƒ³ã«è¡Œãã¨ã„ã†ã“ã¨ã ã£ãŸã®ã§èˆˆå‘³ãŒããã‚‰ã‚Œã¦ã¤ã„ã¦ã„ãã¨ã€ãªã‚“ã‹ã€Œå¹³æˆã§è¦‹ãŸã“ã¨ã‚ã‚‹ã‚ˆã†ãªã‚²ãƒ¼ã‚»ãƒ³ã€ã§ã—ãŸã€‚DiceGangã®äººã¨åˆæµã—ã¦éŠã‚“ã§ã¾ã—ãŸã€‚ãã®å¾Œãƒ©ãƒ¼ãƒ¡ãƒ³ã§æ­»ã¬ã»ã©ã‚«ãƒ«ãƒãƒ£ãƒ¼ã‚·ãƒ§ãƒƒã‚¯å—ã‘ãŸã®ã¯åˆ¥ã®ãŠè©±â€¦DEF CON DAY 2(8/11)ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã€‚ã‹ã‚‰ã®IoT villageã¸ãã“ã§IoTã‚’è»½ãã‚„ã£ã¦ã‹ã‚‰DEFCONã®æ—¥æœ¬çµ„ã«ä¼šã„ã«è¡Œã“ã†ã‹ãªã¨æ€ã£ã¦ã„ãŸã‚‰ã€1æ™‚é–“ãŸã£ã¦ã‚‚IoT CTFãŒå§‹ã¾ã‚‰ãªã„ã®ã§ã€å…ˆã«cloiud villageã«ç§»å‹•ã—ã¦azaraã•ã‚“ã¨åˆã‚ã¦ä¼šã†ã“ã¨ã«â€¦cloud villageã«è¡Œã£ãŸã¯ã„ã„ã‚‚ã®ã®å¤§ç››æ³ã§éƒ¨å±‹ã«å…¥ã‚ã†ã¨ã™ã‚‹ã‚‚ã™ãã«å…¥ã‚Œãš30åˆ†ã»ã©å¾…ã¡ã¾ã—ãŸã€‚ãã®å¾Œéƒ¨å±‹ã®ä¸­ã§azaraã•ã‚“ã¨åˆæµã—ã¦cloud ctfã‚’ãŠæ‰‹ä¼ã„ã—ã‚ˆã†ã¨ã—ãŸã¯ã„ã„ã‚‚ã®ã®ã€ãã‚‚ãã‚‚cloudè‡ªä½“ã‚ˆãã‚ã‹ã‚‰ãšæ•—åŒ—â€¦æ˜¼é£¯æ™‚ãªã®ã§ã€DEFCON finalã®ä¼šå ´ã«ç§»å‹•ã—ã¦é ‘å¼µã£ã¦ã„ã‚‹äººãŸã¡ã«æŒ¨æ‹¶ã—ã¦ã‹ã‚‰ã€ã‚¢ãƒ¡ãƒªã‚«ç‰ˆãƒã‚¯ãƒ‰ã‚’é£Ÿã¹ã«è¡Œãã“ã¨ã«ã—ãŸã‘ã©ã€ãƒ“ãƒƒã‚¯ãƒãƒƒã‚¯ã¯ç›¸å¤‰ã‚ã‚‰ãšæ—¨ã‹ã£ãŸã€‚ãã®å¾Œã€ä¼šå ´ã‚’ãµã‚‰ã¤ããªãŒã‚‰cloud ctfã®ç¶šãã‚‚ã‚„ã£ãŸã‚Šã™ã‚‹æ„Ÿã˜ã§ã ã‚‰ã ã‚‰ã—ã¦ã‹ã‚‰azaraã•ã‚“ã¨ãŠåˆ¥ã‚Œã—ãŸå¾Œã«ã€sekaiã®äººã¨åˆæµã—ã¦flamingoè¿‘ãã§è¡Œã‚ã‚Œã¦ã„ã‚‹ã‚¿ã‚³ã‚¹ãƒ‘ãƒ¼ãƒ†ã‚£ã¸ã€‚ã“ã®ã‚¿ã‚³ã‚¹ãŒæ—¨ã‹ã£ãŸâ€¦ã‚¹ãƒ†ãƒ¼ã‚¸ã§ã¯rickrollã§ãƒ©ãƒƒãƒ—ã™ã‚‹ã‚ã§ãƒãƒãƒ£ãƒ¡ãƒãƒ£ã ã£ãŸã€‚ãã®å¾Œã«ä¼šå ´ã‹ã‚‰ãƒšãƒ—ã‚·æŒã£ã¦å¸°ã£ã¦ã€ãƒ›ãƒ†ãƒ«ã§enscribeã•ã‚“ã¨æ—¥æœ¬æ—…è¡Œã«ã¤ã„ã¦è©±ã—ã¦ãŸã‚‰åˆå‰1:30ã§ã€è…¹æ¸›ã£ãŸã—ãƒšãƒ—ã‚·é£²ã‚€ã‹ã£ã¦é£²ã‚“ã ã‚‰ã€ŒBROâ€¦!??ã€ãŠå‰å¯ã‚Œã‚‹ã®ã‹..?ã€ã£ã¦èã‹ã‚Œã¦ã€Œå¤§ä¸ˆå¤«ã€å¤§ä¸ˆå¤«ã€ã£ã¦è¨€ã£ãŸå¾Œã«ã€Œkanon just drank pepsi. idk if he will sleepğŸ’€ã€ã£ã¦discrodã§æ›¸ã‹ã‚Œã¦ç¬‘ã£ã¦ã¾ã—ãŸwwã¡ãªã¿ã«ã€å¸ƒå›£ã«å…¥ã‚‹ã¨10åˆ†ã»ã©ã§å¯ã‚Œã¾ã—ãŸã€‚æ™®é€šã«ç–²ã‚Œã™ããŸã€‚DEF CON DAY 3(8/12)èµ·ãã¦ã€red alert ctfã‚„ã£ã¦ã¾ã—ãŸã€‚ãªã‚“ã‹ã‚¸ãƒ£ãƒ³ãƒ«ã®è¤‡åˆï¼Ÿã¿ãŸã„ãªå•é¡Œã‚‚ã‚ã£ã¦é›£ã—ã„ã‚ˆã‚Šã‚‚é¢å€’ã ãªã£ã¦æ„Ÿã˜ã§ã—ãŸã€‚åˆå¾Œã‹ã‚‰ã¯ã€æ˜¨æ—¥ã«big Dere6ã•ã‚“ã¨azaraã•ã‚“ã¨é£¯ã‚’é£Ÿã¹ã«è¡Œãç´„æŸã‚’ã—ã¦ã„ãŸã®ã§ã€ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ã‚’é£Ÿã¹ã¦ãƒ–ãƒ¼ã‚¹ã‚’å›ã‚ŠãªãŒã‚‰cloudctfã®ç¶šãã‚’ãšã£ã¨ã—ã¦ã¾ã—ãŸã€‚å¤œã«Zonectfã‚„ã‚‹ãã¨ã„ã†è©±ãŒãƒãƒ¼ãƒ ã«ä¸ŠãŒã£ã¦ã„ãŸã®ã§ã€‚DEF CON DAY 4(8/13)æœèµ·ãã¦ã€DEFCONã«ã¯è¡Œã‹ãšã€Zonectfã‚’è§£ã„ã¦ã„ã¾ã—ãŸãŒè§£ã‘ãšã«å°‘ã—æ‚”ã—ã‹ã£ãŸã§ã™â€¦ãã®å¾Œã€ãŠæ˜¼ã‚’é£Ÿã¹ã¦ã€ãã®å¾Œã«ã€sahuangã•ã‚“ãŒä½™ã£ãŸãŠé‡‘ã§ã‚«ã‚¸ãƒå›ã—ãŸã‚‰ã¾ãŸå¤§å½“ãŸã‚Šã€‚æ˜¼é£Ÿä»£ã‚’ã‚«ã‚¸ãƒã§å›åã§ããŸã‚‰ã—ã„â€¦å¾Œã¯ç©ºæ¸¯ã¾ã§è¡Œã£ã¦ã‹ã‚‰ãŠåˆ¥ã‚Œã—ã¦ã€ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ã—ãŸã‚Šã€ã‚¹ã‚¿ãƒè²·ã£ãŸã‚Šã€ã‚¹ã‚¿ãƒè²·ã£ãŸã‚Š(æ™‚é–“ãŒä½™ã‚Šã™ããŸã®ã§â€¦)ã—ã¦æ™‚é–“ã¤ã¶ã—ã¦ã¾ã—ãŸã€‚å¸°ã‚Šé£›è¡Œæ©Ÿå¸°ã‚Šã®ãƒ•ãƒ©ã‚¤ãƒˆãƒ«ãƒ¼ãƒˆã¯ãƒ©ã‚¹ãƒ™ã‚¬ã‚¹â†’ãƒ­ã‚µãƒ³ã‚¼ãƒ«ã‚¹â†’ç¾½ç”°ã‚’ã‚¢ãƒ¡ãƒªã‚«ãƒ³èˆªç©ºä¼šç¤¾ã‚’ä½¿ã†ãƒ«ãƒ¼ãƒˆã§å–ã‚Šã¾ã—ãŸã€‚ãƒ©ã‚¹ãƒ™ã‚¬ã‚¹â†’ãƒ­ã‚µãƒ³ã‚¼ãƒ«ã‚¹åˆå¾Œ7:30ç™ºã®é£›è¡Œæ©Ÿã§å¯ã‚‹ã«ã‚‚å¯ã‚Œãªã„æ„Ÿã˜ã§ã—ãŸã€‚ãŸã ã€éš£ã®æ–¹ãŒã‚¢ãƒ¡ãƒªã‚«ã®è»äººã®æ–¹ã§ã¡ã‚‡ã£ã¨ãƒ†ãƒ³ã‚·ãƒ§ãƒ³ä¸ŠãŒã£ã¦ã¾ã—ãŸã€‚ã»ã‹ã«ã‚‚ã€é£›ã³ç«‹ã¤ã¨ãã‚„ç€é™¸ã®å¤œæ™¯ã¯ç¶ºéº—ã§ãŠãŠã£ã¦ãªã£ã¦ã¾ã—ãŸã€‚ãƒ­ã‚µãƒ³ã‚¼ãƒ«ã‚¹â†’ãƒ©ã‚¹ãƒ™ã‚¬ã‚¹ãƒ­ã‚µãƒ³ã‚¼ãƒ«ã‚¹ã«ã¯åˆå¾Œ10æ™‚ãã‚‰ã„ã«ç€ã„ã¦ã€çˆ¶è¦ªã‹ã‚‰é‡çƒã®ã‚¨ãƒ³ã‚¼ãƒ«ã‚¹ã®ã‚°ãƒƒã‚ºã‚’è²·ã£ã¦ãã‚Œã¨è¨€ã‚ã‚Œã¦ã„ãŸã®ã§ã€è²·ã£ã¦ãã¾ã—ãŸã€‚ã‚ã¨ã¯é©å½“ã«ã‚±ãƒ³ã‚¿ãƒƒã‚­ãƒ¼é£Ÿã¹ã¦ã“ã®ãƒ–ãƒ­ã‚°ã®ãƒ—ãƒ­ãƒƒãƒˆã‚’æ›¸ã„ã¦ã„ãŸã‚‰é£›è¡Œæ©Ÿã®å ´æ‰€ãŒå¤‰æ›´ã«ãªã£ãŸã‚‰ã—ãã€ã—ã‹ã‚‚ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚‚ç•°ãªã‚‹ãƒ¬ãƒ™ãƒ«ã§ã®ç§»å‹•ã§å°‘ã—ç–²ã‚Œã¾ã—ãŸã€‚ãã®å¾Œã€é£›è¡Œæ©Ÿã«ä¹—ã£ãŸã¯ã„ã„ã‚‚ã®ã®ãƒ•ãƒ©ã‚¤ãƒˆæ™‚é–“ã¯12æ™‚é–“ç¨‹åº¦ã‹ã¤å‡ºç™ºæ™‚é–“ãŒåˆå‰1:30ãã‚‰ã„ã ã£ãŸã®ã§ã€é£›è¡Œæ©Ÿã®10æ™‚é–“ã¯å¯ã¦ã¾ã—ãŸã€‚ã™ã”ã„ç–²ã‚Œã¦ãŸã‚“ã ã¨æ€ã„ã¾ã™ã€‚æ—¥æœ¬ã«ç€ãã¨é€Ÿæ”»ã§ãƒ©ãƒ¼ãƒ¡ãƒ³é£Ÿã¹ã¾ã—ãŸã€‚ããæ—¨ã‹ã£ãŸæœ€å¾Œã«åˆã‚ã¦ã®ã“ã†ã„ã†ã‚¤ãƒ™ãƒ³ãƒˆã«å‚åŠ ã—ãŸã‚Šã€å¤šãã®ãƒãƒ¼ãƒ ã®ãƒ¡ãƒ³ãƒãƒ¼ã«ä¼šãˆãŸã‚Šã—ãŸã®ã§ã„ã„åˆºæ¿€ã«ãªã‚Šã¾ã—ãŸã€‚ãŸã ã€è‹±èªã®èƒ½åŠ›ãŒä½ã™ãã‚‹ã®ã‚‚ã‚ã£ã¦ãƒãƒ¼ãƒ ã®ãƒ¡ãƒ³ãƒãƒ¼ã«ã¯ç”³ã—è¨³ãªã‹ã£ãŸã®ã‹ãªã¨æ€ã„ã¾ã™ã€‚" }, { "title": "zer0pts 2023 writeup", "url": "/posts/zer0ptsCTF-writeup/", "categories": "writeup", "tags": "writeup", "date": "2023-07-16 00:00:00 +0900", "snippet": "zer0ptsCTFä¹…ã—ã¶ã‚Šã«é•·æ™‚é–“å‚åŠ ã—ãŸæ°—ãŒã™ã‚‹â€¦å‰ç½®ãã€€Project Sekaiã§å‚åŠ ã—ã¦ã¾ã—ãŸã€‚çµæœã¯18ä½ãªã®ã§omgã£ã¦æ„Ÿã˜ã§ã™ã­ã€‚ã€‚ã€‚å®Ÿéš›å‚åŠ ã—ã¦ã‚‹äººãŒå°‘ãªã‹ã£ãŸï¼‹ãƒ¡ã‚¤ãƒ³ã®äººãŒã»ã¼ã„ãªã‹ã£ãŸã®ã‚‚å¤§ãã„ã‚“ã§ã™ã‹ã­â€¦ä»£ã‚ã‚Šã«Mr godãŒã„ã¾ã—ã¦revã‚’çˆ†é€Ÿã§å…¨éƒ¨çµ‚ã‚ã‚‰ã—ã¦ã¾ã—ãŸ(å¼·ã™ãã‚‹)æ®‹ã‚Šã¯ã€upsolveã—ãŸã‚‰è¿½åŠ ã—ã¾ã™ã€‚ã€‚ã€‚SquareRNG [crypto 54 solve ] (30 minuts)chall#!/usr/bin/env python3import osfrom Crypto.Util.number import getPrime, getRandomRangedef isSquare(a, p): return pow(a, (p-1)//2, p) != p-1class SquareRNG(object): def __init__(self, p, sa, sb): assert sa != 0 and sb != 0 (self.p, self.sa, self.sb) = (p, sa, sb) self.x = 0 def int(self, nbits): v, s = 0, 1 for _ in range(nbits): self.x = (self.x + 1) % p s += pow(self.sa, self.x, self.p) * pow(self.sb, self.x, self.p) s %= self.p v = (v &lt;&lt; 1) | int(isSquare(s, self.p)) return v def bool(self): self.x = (self.x + 1) % self.p t = (pow(self.sa, self.x, self.p) + pow(self.sb, self.x, self.p)) t %= self.p return isSquare(t, self.p)p = getPrime(256)sb1 = int(input(\"Bob's seed 1: \")) % psb2 = int(input(\"Bob's seed 2: \")) % pfor _ in range(77): sa = getRandomRange(1, p) r1 = SquareRNG(p, sa, sb1) print(\"Random 1:\", hex(r1.int(32))) r2 = SquareRNG(p, sa, sb2) print(\"Random 2:\", hex(r2.int(32))) guess = int(input(\"Guess next bool [0 or 1]: \")) if guess == int(r1.bool()): print(\"OK!\") else: print(\"NG...\") breakelse: print(\"Congratz!\") print(os.getenv(\"FLAG\", \"nek0pts{*** REDACTED ***}\"))solveLCG$s_x \\equiv \\sum_{i=1}^{x}(sa^x*sb^x) + 1\\mod p$ã®å‡ºåŠ›ã«é–¢ã—ã¦$(s_x/p)$ã®ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·ã®å€¤ãŒ$sb$ãŒ2å›å…¥åŠ›ã§ãã‚‹ã“ã¨ã‹ã‚‰2ã¤å¾—ã‚‰ã‚Œã‚‹ã®ã§ã€ãã“ã‹ã‚‰$(sa^{33}+sb^{33} /p)$ã®ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·ã®å‡ºåŠ›ã‚’å½“ã¦ã‚ã£ã¦ã„ã†æ„Ÿã˜ã¿ãŸã„ã§ã™ã€‚ãã‚‚ãã‚‚ã€ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·ã¯ãã®æ•°$a$ãŒã‚ã‚‹ç´ æ•°$p$ã«ãŠã„ã¦$a \\equiv x^2 \\mod p$ã¨ãªã‚‹ã‚ˆã†ãª$x$ã®å­˜åœ¨ã®åˆ¤å®šã™ã‚‹ã‚‚ã®ã§ã™ã€‚ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·ã«ã¯å¹³æ–¹å‰°ä½™ã®ç›¸äº’æ³•å‰‡ã¨ã„ã†$(a/p)*(b/p) = (ab/p)$ãŒã‚ã‚‹ã®ã§ã“ã‚Œã‚’ä½¿ãˆãŸã‚‰ãªãƒ¼ã¨ã„ã†æ°—æŒã¡ã§ç”·ã¯é»™ã£ã¦å› æ•°åˆ†è§£ã—ã¾ã™ã€‚ã“ã“ã§ã€$sa^{33}+sb^{33}$ã‚’å› æ•°åˆ†è§£ã—ã¡ã‚ƒã£ã¦ã€$sa^{33}+sb^{33} = (sa + sb) * (sa^2 - sa*sb + sb^2) * (sa^{10} - sa^9*sb + sa^8*sb^2 - sa^7*sb^3 + sa^6*sb^4 - sa^5*sb^5 + sa^4*sb^6 - sa^3*sb^7 + sa^2*sb^8 - sa*sb^9 + sb^10) * (sa^{20} + sa^{19}*sb - sa^{17}*sb^3 - sa^{16}*sb^4 + sa^{14}*sb^6 + sa^{13}*sb^7 - sa^{11}*sb^9 - sa^{10}*sb^10 - sa^9*sb^{11} + sa^7*sb^{13} + sa^6*sb^{14} - sa^4*sb^{16} - sa^3*sb^{17} + sa*sb^{19} + sb^{20})$ã£ã¦ãªã‚Šã¾ã™ã€‚ã‚ã§ãŸãå› æ•°åˆ†è§£ã§ããŸ(ã¦ã‹å¯¾ç§°å¼ãªã®ã§å½“ãŸã‚Šå‰)ã®ã§ã€ã•ã£ãè²°ã£ãŸå‡ºåŠ›ã«ç½®ãæ›ãˆã¦ã„ãã¾ã™ã€‚ã“ã“ã§ã€æœ€åˆã®é …ä»¥å¤–ã‚’ã‹ã‘ã‚ã›ã¦ã—ã¾ãˆã°ã€$sa^{32} - sa^{31}*sb + sa^{30}*sb^2 - sa^{29}*sb^3 + sa^{28}*sb^4 - sa^{27}*sb^5 + sa^{26}*sb^6 - sa^{25}*sb^7 + sa^{24}*sb^8 - sa^{23}*sb^9 + sa^{22}*sb^{10} - sa^{21}*sb^{11} + sa^{20}*sb^{12} - sa^{19}*sb^{13} + sa^{18}*sb^{14} - sa^{17}*sb^{15} + sa^{16}*sb^{16} - sa^{15}*sb^{17} + sa^{14}*sb^{18} - sa^{13}*sb^{19} + sa^{12}*sb^{20} - sa^{11}*sb^{21} + sa^{10}*sb^{22} - sa^9*sb^{23} + sa^8*sb^{24} - sa^7*sb^{25} + sa^6*sb^{26} - sa^5*sb^{27} + sa^4*sb^{28} - sa^3*sb^{29} + sa^2*sb^{30} - sa*sb^{31} + sb^{32} = \\sum_{i=1}^{x}(sa^x + (-sb)^x) + 1$$sb$ã«$-sb$ã‚’ä»£å…¥ã—ãŸã¨ãã«å¾—ã‚‰ã‚ŒãŸé …ã®æœ€çµ‚é …ã¨ä¸€è‡´ã—ã¾ã™ã€‚ã•ã‚‰ã«æ®‹ã‚Šã®$sa+sb$ã¯ä»®ã«$sb=1$ã¨ã™ã‚‹ã¨ï¼Ÿ$sa+1$ã¨ãªã‚Šã“ã‚Œã¯ã€$s_1 \\equiv sa + 1\\mod p$ã¨åŒå€¤ãªã®ã§ã€$sb1=1,sb2=-1$ã‚’ä»£å…¥ã—ã¾ã™ã€‚ãã“ã‹ã‚‰çµæœã®1bitã‚’æ›ã‘ç®—ã™ã‚‹ã¨ç­”ãˆãŒå‡ºã¾ã™ã€‚from Crypto.Util.number import getPrime, getRandomRangefrom pwn import *io = remote(\"crypto.2023.zer0pts.com\",\"10666\")io.sendlineafter(b\": \",b\"1\")io.sendlineafter(b\": \",b\"-1\")for i in range(77): ct1 = eval(io.recvline().decode().split(\" \")[-1]) ct2 = eval(io.recvline().decode().split(\" \")[-1]) ct1 = bin(ct1)[2:].zfill(32) ct2 = bin(ct2)[2:].zfill(32) ans = (1-(int(ct2[-1])^int(ct1[0])))%2 io.sendlineafter(b\": \",str(int(ans)).encode()) print(io.recvline())io.interactive()# zer0pts{L(a)L(b)=L(ab)}easy_factoring (coworker solved) [crypto 95 solve ] (?? minuts)challimport osimport signalfrom Crypto.Util.number import *flag = os.environb.get(b\"FLAG\", b\"dummmmy{test_test_test}\")def main(): p = getPrime(128) q = getPrime(128) n = p * q N = pow(p, 2) + pow(q, 2) print(\"Let's factoring !\") print(\"N:\", N) p = int(input(\"p: \")) q = int(input(\"q: \")) if isPrime(p) and isPrime(q) and n == p * q: print(\"yey!\") print(\"Here you are\") print(flag) else: print(\"omg\")def timeout(signum, frame): print(\"Timed out...\") signal.alarm(0) exit(0)if __name__ == \"__main__\": signal.signal(signal.SIGALRM, timeout) signal.alarm(30) main() signal.alarm(0)solve???ã•ã£ãã®LCGè§£ã„ã¦ä¼‘æ†©ã—ãŸã‚‰sahuangãƒ‘ã‚¤ã‚»ãƒ³ã¨quasarã•ã‚“ãŒçˆ†é€Ÿã§è§£ã„ã¦ã¾ã—ãŸ(å¤šåˆ†unintend)ã®ã§ã€ã¾ãŸä»Šåº¦ã®upsolveã£ã¦ã“ã¨ã§â€¦.$N = p^2+q^2$ã®$p,q$ã‚’æ±‚ã‚ã‚ˆã¨ã„ã†ã“ã¨ã§ã™ãŒã€ãªã‚“ã¨ã„ã†ã“ã¨ã§ã—ã‚‡ã†ãƒ‡ã‚£ã‚ªãƒ•ã‚¡ãƒ³ãƒˆã‚¹å•é¡Œ(ã ã‚ˆã­??)ã¾ãOTOKO HA DAMATTE INSUUBUNKAI $N=(p+qi)*(p-qi)$ã£ã¦æ„Ÿã˜ã§ã™ã­ã€‚ã‚“ã§ã€è¤‡ç´ æ•°ä½“è‡ªä½“ã¯UFDã ã‘ã©ãã®$(p+qi)$è‡ªä½“ãŒã•ã‚‰ã«å› æ•°ã‚’æŒã¤å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§å› æ•°ã®ç©ã§å‡ºã‚‹ã®ã‹ãªãï¼Ÿ(çŸ¥ã‚‰ãªã„)elliptic_ring_rsa [crypto 27 solve ] (2 hour)challimport stringimport randomimport osflag = os.environb.get(b\"FLAG\", b\"dummmmy{test_test_test}\")class EllipticRingElement:\tpoint = None\tdef __init__(self, point):\t\tself.point = point\t\tdef __add__(self, other):\t\tif self.point == dict():\t\t\treturn other\t\tif other.point == dict():\t\t\treturn self\t\tres = self.point.copy()\t\tfor k in other.point.keys():\t\t\tif k in res:\t\t\t\tres[k] += other.point[k]\t\t\t\tif res[k] == 0:\t\t\t\t\tres.pop(k)\t\t\telse:\t\t\t\tres[k] = other.point[k]\t\t\t\tif res[k] == 0:\t\t\t\t\tres.pop(k)\t\treturn EllipticRingElement(res)\t\tdef __mul__(self, other):\t\tif self.point == dict() or other.point == dict():\t\t\treturn self.point()\t\tres = dict()\t\tfor k1 in other.point.keys():\t\t\tfor k2 in self.point.keys():\t\t\t\tE = k1 + k2\t\t\t\tk = other.point[k1] * self.point[k2]\t\t\t\tif E in res:\t\t\t\t\tres[E] += k\t\t\t\t\tif res[E] == 0:\t\t\t\t\t\tres.pop(E)\t\t\t\telse:\t\t\t\t\tres[E] = k\t\t\t\t\tif res[E] == 0:\t\t\t\t\t\tres.pop(E)\t\treturn EllipticRingElement(res)\t\tdef __repr__(self):\t\tst = \"\"\t\tfor k in self.point.keys():\t\t\tst += f\"{self.point[k]}*({k[0]}, {k[1]}) + \"\t\treturn st[:-3]\tclass EllipticRing:\tE = None\tBase = None\tdef __init__(self, E):\t\tself.E = E\t\tself.Base = E.base()\tdef __call__(self, pt):\t\tfor P in pt:\t\t\tpt[P] = self.Base(pt[P])\t\treturn EllipticRingElement(pt)\t\tdef zero(self):\t\treturn EllipticRingElement(dict())\t\tdef one(self):\t\treturn EllipticRingElement({E(0): self.Base(1)})\t\tdef pow(self, x, n):\t\tres = self.one()\t\twhile n:\t\t\tif (n &amp; 1):\t\t\t\tres = res * x\t\t\tx = x * x\t\t\tn &gt;&gt;= 1\t\treturn res\t\tdef encode(self, m, length):\t\tleft = random.randint(0, length - len(m))\t\tpad1 = \"\".join(random.choices(string.ascii_letters, k=left)).encode(\"utf-8\")\t\tpad2 = \"\".join(random.choices(string.ascii_letters, k=length-len(m)-left)).encode(\"utf-8\")\t\tm = pad1 + m + pad2\t\tPs = []\t\twhile len(Ps) &lt; length:\t\t\tPP = self.E.random_element()\t\t\tif PP not in Ps:\t\t\t\tPs.append(PP)\t\tPs = sorted(Ps)\t\tM = dict()\t\tfor coef, pt in zip(m, Ps):\t\t\tM[pt] = self.Base(coef)\t\treturn EllipticRingElement(M)\tdef random_prime_bits(nbits):\treturn random_prime(2^nbits-1, false, 2^(nbits-1))nbits = 8p = random_prime_bits(nbits)Fp = GF(p)a = Fp.random_element()b = Fp.random_element()E = EllipticCurve(Fp, [a, b])ER = EllipticRing(E)P = ER.encode(flag, 30)e = 13C = ER.pow(P, e)print(f\"p: {p}\")print(f\"C: {C}\")print(f\"a: {a}\")print(f\"b: {b}\")print(f\"e: {e}\")solveã¨ã‚Šã‚ãˆãšæ¥•å††ã¯æ¥•å††ã ã‘ã©æ¼”ç®—ãŒ..?ã¦æ„Ÿã˜ãªã®ã§è¦‹ã¦ã„ãã¾ã™ã€‚ãªã‚“ã‹$Aâ€™ =a_0*P_0 + a_2*P_2 + â€¦+a_{r-1}*P_{r-1}$ã£ã¦æ„Ÿã˜ã®å…ƒã«è¦‹ãˆã¾ã™ã­ã“ã‚Œã€‚æ›ã‘ç®—ã¯ã€å¤šé …å¼ã®æ›ã‘ç®—ã¨åŒã˜ã§$Aâ€™*Bâ€™ = \\sum_{i=0}^{r-1}\\sum_{j=0}^{r-1}((a_i+b_j)*P_{i+j})$ã£ã¦æ„Ÿã˜ã§ã™ã­ã€‚è¶³ã—ç®—ã‚‚ã€å¤šé …å¼ã®æ›ã‘ç®—ã¨åŒã˜ã§$Aâ€™+Bâ€™ = \\sum_{i=0}^{r-1}(a_i+b_j)*P_{i})$ã£ã¦æ„Ÿã˜ã€‚ä¹—ç®—ã«ãŠã‘ã‚‹é€†å…ƒã¯â€¦.$A = (1+P_1)$ç­‰ãŒå­˜åœ¨ã—ãªã„ã¯ãšï¼(ç†ç”±ã¯å¾Œç¨‹)ã¦ãªæ„Ÿã˜ã§å¤šé …å¼ç’°ã«æº–åŒå‹å†™åƒå‡ºæ¥ãã†ã§ã™ã­ã“ã‚Œï¼ï¼ãªã‚‰ã“ã®å…ƒå…¨ä½“ã®é›†åˆã‚’$G$ã€å†™åƒå…ˆã®é›†åˆã‚’$H$ã¨ã™ã‚‹ã¨ã€$\\phi : G\\to H: P_i \\mapsto x^i$ã£ã¦ã„ã†å¤šé …å¼ã¸ã®å†™åƒã‚’æ§‹æˆã™ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚ã“ã“ã§ã€$A$ã®ä¸–ç•Œã§è¡Œã‚ã‚Œã¦ã„ãŸã“ã¨ã‚’è€ƒãˆã¦ã¿ã‚‹ã¨ã€$P$ã¨ã„ã†å…ƒã‚’æ§‹ç¯‰ã—ã€$P^e$ã—ã¦ã„ã‚‹ã ã‘ã§ã™ã€‚ã£ã¦ã“ã¨ã§$\\phi$â†’rsaã®ã‚ˆã†ãªé€†æ¼”ç®—â†’$\\hat \\phi$ ã§å…ƒã«æˆ»ã‚Šã¾ã™ã€‚STEP1 å†™åƒã®ä½œæˆã¨ã‚Šã‚ãˆãšåŸºæº–ã¨ãªã‚‹$g \\in A$ã‚’æ¢ã—ã¾ã™(ä½æ•°ã¯æœ€å¤§ã®ã‚‚ã®)ã€ãã‚Œã‚’ä½¿ã£ã¦å†™åƒã—ã¾ã™ã€‚def plus2dict(_C): cc = dict() _C = _C.split(\" + \") for c in _C: if c.split(\"*\")[1] == \"(0, 1)\": cc[E(0)] = c.split(\"*\")[0] else: cc[E(eval(c.split(\"*\")[1]))] = c.split(\"*\")[0] _C = cc return _CPR.&lt;x&gt; = PolynomialRing(GF(p))gen = x^192-1QR.&lt;x&gt; = QuotientRing(PR, gen)while True: g = E.random_element() if g.order() == r: break def ec2vec(g,_C): vec = 0 for i in range(0,r): try: vec += (int(_C[g*i])*x^i) except KeyError as e: continue return vecC = plus2dict(C)C = ec2vec(g,C)ã“ã‚Œã§ãŠã—ã¾ã„ã€‚PART2 rsa likeãªå¾©å·$Aâ€™ \\in G$ã‹ã‚‰$Aâ€™'\\in H$ã«å†™åƒã§ããŸã®ã§ã€$H$ã«ã¤ã„ã¦è€ƒãˆã¾ã™ã€‚$Z_p[x]/(X^{192}-1)$ã¨ã„ã†ç¾¤æ§‹é€ ã‚’æŒã¡ã¾ã™ã€‚ã“ã“ã§ã€$x^{192}-1$ã¯å› æ•°åˆ†è§£ã§ãã¦ã—ã¾ã„ã€è¦ç´„å¤šé …å¼ã«ã¯ãªã‚Šã¾ã›ã‚“ã®ã§æ‹¡å¤§ä½“ã«ã¯ãªã‚‰ãªã„ã®ã§ã™ã¹ã¦ã®å…ƒãŒä¹—æ³•ã§ã®é€†å…ƒã‚’æŒã¡ã¾ã›ã‚“ã€‚($(X+1)| X^{192}-1$ã‚ˆã‚Šé€†å…ƒã‚’æŒãŸãªã„ã€ã‹ã¤ã•ã£ãã®å†™åƒã‚’è€ƒãˆã‚‹ã¨â€¦)ã‚ˆã£ã¦ã€$H$ã¯å¤šé …å¼ç’°ã«ãªã‚‹ã®ã§å¤šé …å¼ç’°ã®rsaã®å¾©å·ã‚’è€ƒãˆã¾ã™ã€‚ç•¥ã—ã¾ã™ãŒã€ä½æ•°ã¯$p^k-1$ã®ç´„æ•°ãªã“ã¨ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã¦ã„ã¾ã™ã€‚ã“ã“ã§ã€Men must keep their mouths shut and factorizeã™ã‚‹ã¨$e | p^k-1$ã¨ã„ã†ã„ã‚„ãƒ¼ãªæ„Ÿã˜ã§ã™ãŒã€ä½æ•°çš„ã«ã¯$Aâ€™'^{p^k-1//e} \\equiv 1 \\mod p$ã§å•é¡Œãªã‹ã£ãŸã®ã§ã‚ˆã—ã¨ã—ã¾ã™ã€‚ã‚ˆã£ã¦ã€é€šå¸¸ã®RSAã£ã½ã$d = e^{-1} \\mod (p^k-1)//e$ã¨ã—ã¦ã€$Bâ€™'\\equiv Aâ€™'^d \\mod p $ã§æœ€çµ‚çš„ã«å¾©å·ã§ãã¾ã™ã€‚d = int(pow(13,-1,(p^192-1)//13))print((C^d))m = str(C^d)PART3 é€†å†™åƒæœ€å¾Œã«é€†å†™åƒã—ã¦çµ‚ã‚ã‚Šã§ã™ã€‚æœ€åˆã«æ±‚ã‚ãŸ$g$ã‚’åŸºæº–ã«ã—ã¦é€†å†™åƒã—ã¦ã„ãã¾ã™ã€‚ms = []ps = []for i in m.split(\" + \")[:-1]: g_tmp = g*int(i.split(\"^\")[1]) ms.append([g_tmp,chr(int(i.split(\"*\")[0]))]) ps.append(g_tmp)ã“ã‚Œã§ã€æœ€å¾Œã«ã‚½ãƒ¼ãƒˆã—ã¦é †ã«ä¿‚æ•°ã‚’æ–‡å­—ã«èµ·ã“ã—ã¦ã‚„ã‚‹ã¨flagãŒæ±‚ã¾ã‚Šã¾ã™ã€‚å†™åƒè€ƒãˆã‚‹ã®ã¾ã˜ã§æ¥½ã—ã‹ã£ãŸã§ã™ã€‚ã‚ã¨ã€ã“ã‚Œã¯ãã‚Œãªã‚Šã«å®Ÿè¡Œé€Ÿåº¦æ—©ã„ã¯ãš..??(çŸ¥ã‚‰ã‚“ã‘ã©)ã£ã¦ã“ã¨ã§ã€ã“ã‚Œã®æƒ³å®šè§£ãŒæ°—ã«ãªã‚‹ã¨ã“ã‚â€¦??ps_ori = str([i.xy() for i in ps])ps_sort = sorted(ps)print(ps_ori)ps_ori = [E(i) for i in eval(ps_ori)]for i in range(len(ps_sort)): num = ps_ori.index(ps_sort[i]) print(ms[num][1],end=\"\")# zer0pts{Gr0up_r1ng_meow!!}C = \"182*(91, 45) + 147*(3, 164) + 85*(62, 60) + 53*(77, 59) + 99*(77, 152) + 18*(137, 59) + 106*(169, 101) + 147*(127, 127) + 154*(152, 163) + 121*(43, 73) + 155*(110, 160) + 202*(116, 45) + 195*(1, 84) + 106*(71, 162) + 33*(209, 122) + 112*(134, 164) + 186*(1, 127) + 72*(183, 116) + 141*(141, 39) + 72*(83, 127) + 157*(197, 175) + 6*(178, 24) + 106*(71, 49) + 114*(57, 201) + 95*(181, 58) + 1*(174, 44) + 193*(202, 27) + 182*(121, 95) + 52*(167, 179) + 109*(184, 177) + 110*(21, 162) + 101*(126, 170) + 208*(47, 102) + 168*(129, 105) + 209*(179, 123) + 210*(160, 70) + 10*(13, 103) + 159*(76, 55) + 165*(31, 26) + 31*(44, 119) + 47*(6, 70) + 150*(74, 47) + 117*(30, 65) + 3*(108, 69) + 61*(43, 138) + 151*(72, 209) + 122*(110, 51) + 127*(44, 92) + 64*(191, 113) + 61*(45, 70) + 155*(91, 166) + 175*(95, 194) + 97*(21, 49) + 210*(66, 191) + 129*(129, 106) + 210*(80, 7) + 157*(174, 167) + 45*(141, 172) + 189*(155, 78) + 160*(194, 1) + 209*(82, 28) + 142*(164, 136) + 135*(199, 155) + 166*(118, 95) + 100*(123, 14) + 203*(121, 116) + 22*(36, 20) + 33*(65, 58) + 196*(189, 60) + 75*(137, 152) + 22*(125, 4) + 45*(119, 162) + 59*(47, 109) + 102*(177, 157) + 196*(109, 20) + 112*(192, 94) + 97*(209, 89) + 67*(95, 17) + 129*(75, 55) + 34*(134, 47) + 156*(60, 156) + 135*(127, 84) + 11*(148, 147) + 194*(202, 184) + 27*(45, 141) + 131*(4, 166) + 166*(148, 64) + 183*(164, 75) + 177*(130, 145) + 128*(107, 8) + 204*(156, 40) + 131*(17, 25) + 99*(177, 54) + 122*(82, 183) + 52*(178, 187) + 130*(168, 19) + 14*(150, 150) + 173*(167, 32) + 82*(184, 34) + 172*(72, 2) + 144*(169, 110) + 7*(118, 116) + 96*(181, 153) + 34*(133, 5) + 97*(207, 17) + 24*(78, 161) + 54*(57, 10) + 90*(143, 188) + 172*(130, 66) + 179*(146, 65) + 38*(55, 202) + 170*(63, 31) + 99*(35, 65) + 162*(150, 61) + 56*(74, 164) + 146*(144, 85) + 196*(133, 206) + 164*(152, 48) + 139*(176, 153) + 92*(125, 207) + 124*(31, 185) + 136*(0, 1) + 118*(107, 203) + 28*(24, 56) + 66*(171, 151) + 127*(76, 156) + 63*(208, 59) + 187*(146, 146) + 138*(85, 0) + 195*(19, 190) + 115*(60, 55) + 87*(171, 60) + 194*(17, 186) + 79*(75, 156) + 181*(27, 37) + 38*(192, 117) + 168*(13, 108) + 41*(143, 23) + 167*(199, 56) + 177*(86, 71) + 160*(35, 146) + 165*(189, 151) + 130*(32, 30) + 39*(108, 142) + 197*(36, 191) + 176*(120, 17) + 180*(194, 210) + 204*(19, 21) + 160*(6, 141) + 195*(109, 191) + 194*(155, 133) + 62*(65, 153) + 6*(138, 107) + 12*(201, 62) + 43*(180, 43) + 178*(208, 152) + 86*(180, 168) + 135*(55, 9) + 5*(138, 104) + 118*(207, 194) + 58*(160, 141) + 173*(66, 20) + 16*(179, 88) + 181*(61, 131) + 3*(80, 204) + 137*(119, 49) + 106*(126, 41) + 127*(176, 58) + 64*(144, 126) + 96*(30, 146) + 165*(168, 192) + 104*(27, 174) + 64*(63, 180) + 35*(123, 197) + 111*(86, 140) + 141*(197, 36) + 83*(116, 166) + 159*(4, 45) + 165*(62, 151) + 94*(183, 95) + 133*(3, 47) + 58*(83, 84) + 149*(201, 149) + 96*(20, 112) + 141*(191, 98) + 113*(24, 155) + 139*(61, 80) + 73*(120, 194) + 116*(78, 50) + 68*(156, 171) + 31*(32, 181)\"p = 211a = 201b = 102e = 13r = 192 # E.order()E = EllipticCurve(GF(p),[a,b])def plus2dict(_C): cc = dict() _C = _C.split(\" + \") for c in _C: if c.split(\"*\")[1] == \"(0, 1)\": cc[E(0)] = c.split(\"*\")[0] else: cc[E(eval(c.split(\"*\")[1]))] = c.split(\"*\")[0] _C = cc return _CPR.&lt;x&gt; = PolynomialRing(GF(p))gen = x^192-1QR.&lt;x&gt; = QuotientRing(PR, gen)while True: g = E.random_element() if g.order() == r: breakprint(\"[+] REFERNCE POINT\",g) def ec2vec(g,_C): vec = 0 for i in range(0,r): try: vec += (int(_C[g*i])*x^i) except KeyError as e: continue return vecC = plus2dict(C)C = ec2vec(g,C)d = int(pow(13,-1,(p^192-1)//13))print(\"[+] AFTER DECRYPT\",C^d)m = str(C^d)ms = []ps = []for i in m.split(\" + \")[:-1]: g_tmp = g*int(i.split(\"^\")[1]) ms.append([g_tmp,chr(int(i.split(\"*\")[0]))]) ps.append(g_tmp) print(\"[+] AFTER INVERSE MAPPING\",ps)ps_ori = str([i.xy() for i in ps])ps_sort = sorted(ps)ps_ori = [E(i) for i in eval(ps_ori)]print(\"[+] FLAG : \",end=\"\")for i in range(len(ps_sort)): num = ps_ori.index(ps_sort[i]) print(ms[num][1],end=\"\")# zer0pts{Gr0up_r1ng_meow!!}" }, { "title": "CPCTF 2023 writeup", "url": "/posts/CPCTF-writeup/", "categories": "writeup", "tags": "writeup", "date": "2023-02-19 00:00:00 +0900", "snippet": "CPCTFãªã‚“ã‹ç©ºãæ™‚é–“è¦‹ã¤ã‘ã¦å‚åŠ ã—ã¦ã¾ã—ãŸã€‚é¢ç™½ã‹ã£ãŸã§ã™simplechallfrom Crypto.Util.number import inverse, bytes_to_long, getPrimefrom flag import flagclass complex_over_p: \"\"\" a + bi \"\"\" def __init__(self, a, b, p): self.a = a self.b = b self.p = p def __mul__(self, other): return complex_over_p( (self.a * other.a - self.b * other.b) % self.p, (self.a * other.b + self.b * other.a) % self.p, self.p, ) def __pow__(self, n: int): ret = complex_over_p(1, 0, self.p) x = complex_over_p(self.a, self.b, self.p) while n &gt; 0: if n &amp; 1: ret = ret * x x = x * x n &gt;&gt;= 1 return ret def __str__(self): return str(self.a) + \" + \" + str(self.b) + \"i\"p = getPrime(512)q = getPrime(512)n = p * qphi = (p - 1) * (q - 1)e = 65537m = bytes_to_long((flag).encode(\"utf-8\"))c_1 = complex_over_p(p, m, n) ** ec_2 = complex_over_p(q, m, n) ** ewith open(\"cipher.txt\", \"w\") as f: f.write(f\"c_1 = {str(c_1)}\\n\") f.write(f\"c_2 = {str(c_2)}\\n\") f.write(f\"n = {n}\\n\") f.write(f\"e = {e}\\n\")solveé¢ç™½ã„ã§ã™ã­ã€‚è¤‡ç´ æ•°ä½“ä¸Šã§ã®é›¢æ•£å¯¾æ•°å•é¡Œçš„ãªï¼Ÿï¼Ÿã¨ã‚Šã‚ãˆãšã€ã“ã†ã„ã†ã®ã¯$p,q$ã‚’æ±‚ã‚ãªã„ã¨å§‹ã¾ã‚‰ãªã„ã®ãŒé‰„å‰‡ãªã®ã§æ±‚ã‚ã¦ã„ãã¾ã™ã€‚$c_1 = (p+mi)^e=\\sum_{i=0}^e {}_eC_i p^i(mi)^{e-i}$ã‚ˆã‚Šå®Ÿæ•°éƒ¨ã¯$p$ã§ããã‚Œã‚‹æ°—ãŒã—ã¾ã™ã€‚ã‚ˆã£ã¦ã€$p=GCD(Re(c_1),n)$ã§æ±‚ã¾ã‚Šãã†ãªæ°—ãŒã—ã¾ã™ã€‚ã•ã¦ã€ã“ã“ã‹ã‚‰å•é¡Œã§$m$ã‚’æ±‚ã‚ãªã‘ã‚Œã°ã„ã‘ãªã„ã§ã™ãŒã€ã©ã†ã—ãŸã‚‚ã®ã‹ã¨ã€‚ã€‚ã€‚$c_1 \\equiv (p+mi)^e \\mod n$ã‚ˆã‚Š$c_1 \\equiv (mi)^e \\mod p$ã¨ãªã‚‹ã®ã§ã“ã‚Œã®è™šæ•°éƒ¨ã‚’è€ƒãˆã‚‹ã¨ãŸã ã®ãƒ•ã‚§ãƒ«ãƒãƒ¼ã®å°å®šç†ã§ã™ã‚ˆã­ï¼ãªã‚‰ã€$d \\equiv e^{-1} \\mod p-1$ã¨ã™ã‚Œã°è§£æ±ºã—ã¾ã™ã­ï¼ï¼ã“ã“ã§ä¸€ã¤ã€$phi$ã«ã¤ã„ã¦ãƒŸã‚¹ãƒªãƒ¼ãƒ‰ã§ã¯ãªã„ã‹ã¨ã„ã†è©±ã‚’è¦‹ã‹ã‘ãŸæ°—ãŒã™ã‚‹ã®ã§ã€‚ã€‚ã€‚å®Ÿéš›ãã“ã ã‘è¦‹ã‚‹ã¨ãƒŸã‚¹ãƒªãƒ¼ãƒ‰ãªæ°—ã‚‚ã—ã¾ã™ãŒã€ãã‚‚ãã‚‚ã¨ã—ã¦$p$ã®å€¤ã‚’å‡ºã›ãŸæ™‚ç‚¹ã§ãã®è¾ºã®çŸ¥è­˜ã‚’ç†è§£ã—ã¦ã„ã‚‹ã‚‚ã®ã¨è€ƒãˆã¦ã„ã„ã‚ˆã†ãªæ°—ãŒã—ã¾ã™ã§ã€ãƒŸã‚¹ãƒªãƒ¼ãƒ‰ã«ãªã‚‰ãªã„ã¨ç§ã¯è€ƒãˆã¾ã™ã—ã€ã“ã‚Œã¯è§£ã„ãŸã†ãˆã§ã®ç§ã®æ„è¦‹ã§ã™ã€‚c_1 = [88947353384906315386142174915579230007708484691905461586249734733895208303904624706955572569717469153074453837889147058757297004159523404800499566731846573280606881057150101844929178328363240743156762837486978571114151912836342740869293096891054377782752248810122413624567401981982628574682163267589540717955 , 105796218607197626508309219898970081654433389611035862776816738031930217893350585142033078143656160997324512315260317101196998029046142078518167267210684968483205795618377068578645969888568133775820377659323101885187136507439656053103103802476138541844262969937543381511564444761769799873705129093296227488320]c_2 = [6246646181898635030418930144979030696163268885489193597189892517442414814959679853409630585655482080447639092928109757977342458025765218315720433756032748568912426451942636486110411038484872363928990656032625950245328223463301109739166158341796991125915052131277132622262221136515681121985807852466393611412 , 53817519046828021036896927561082153848829725683909509411136093993919199941896521025977358288420902565544951255959786518459773639829589216874164688208953119794504853435052217109342811249935881805211646847973929482665869312260539685753735469177452027367949870932823024534083790996822338074496201028292592498398]n = 115660927134746496667389439939121894365639159618801107805144217447831876345527158612296725729945512010246362315164908359385194177739042272399000609673334050698528059482827768728850630523188582862374516240503442919767592843273925939238586765096529791229982128395675821790738782110235716669724330392693672332699e = 65537from Crypto.Util.number import *p = GCD(n,88947353384906315386142174915579230007708484691905461586249734733895208303904624706955572569717469153074453837889147058757297004159523404800499566731846573280606881057150101844929178328363240743156762837486978571114151912836342740869293096891054377782752248810122413624567401981982628574682163267589540717955)q = GCD(6246646181898635030418930144979030696163268885489193597189892517442414814959679853409630585655482080447639092928109757977342458025765218315720433756032748568912426451942636486110411038484872363928990656032625950245328223463301109739166158341796991125915052131277132622262221136515681121985807852466393611412,n)assert p*q == nclass complex_over_p: \"\"\" a + bi \"\"\" def __init__(self, a, b, p): self.a = a self.b = b self.p = p def __mul__(self, other): return complex_over_p( (self.a * other.a - self.b * other.b) % self.p, (self.a * other.b + self.b * other.a) % self.p, self.p, ) def __pow__(self, n: int): ret = complex_over_p(1, 0, self.p) x = complex_over_p(self.a, self.b, self.p) while n &gt; 0: if n &amp; 1: ret = ret * x x = x * x n &gt;&gt;= 1 return ret def __str__(self): return str(self.a) + \" + \" + str(self.b) + \"i\" dp = pow(e,-1,p-1)mp = pow(c_1[1],int(dp),p)print(long_to_bytes(mp))misusechall\"\"\"This code is designed to be run with SageMath.See https://www.sagemath.org/If you don't have SageMath installed, you can use the online version at https://cocalc.com/ or https://sagecell.sagemath.org/But you may not use pyton lib online...ref: https://doc.sagemath.org/html/en/index.html\"\"\"from Crypto.Util.number import bytes_to_long, long_to_bytes, isPrimefrom flag import flagfrom Crypto.Cipher import AESfrom base64 import b64encodefrom secret import keyfrom Crypto.Util.Padding import padp = 1457379754778834114393428514496372769300186542434939310975944765431765709327445548009771988242361974038539406450275157591a = 1236064211753439722521344199773932075287648377233139862790772102290062141518569630890922001641345393262197009050412379555b = 1128111897991419355721141214155995058314857116431662004640521251265155838304469066234949556324122951758680646976644303642def lift_x(x, p): assert p % 4 == 3 z = (x**3 + a * x + b) % p res = pow(z, (p + 1) // 4, p) return res % p, -res % pif __name__ == \"__main__\": assert isPrime(p) F = GF(p) m = flag.encode(\"utf-8\") cipher = AES.new(long_to_bytes(key), AES.MODE_CBC) iv = cipher.iv c = cipher.encrypt(pad(m, AES.block_size)) x = bytes_to_long(long_to_bytes(key) + c) assert x &lt; p d = 65537 ecc = EllipticCurve(F, [a, b]) y = lift_x(x, p)[0] P = ecc(x, y) Q = d * P with open(\"public.txt\", \"w\") as f: f.write(f\"iv={bytes_to_long(b64encode(iv))}\\n\") f.write(f\"Q_x={Q[0]}\\n\") f.write(f\"Q_y={Q[1]}\\n\")solveæ¥•å††æ›²ç·šå•é¡Œã§ã™ã­ã€‚ã€‚ã€‚$Q=[65537]P$ã¨ãªã‚‹$P$ã‚’è¦‹ã¤ã‘ã¦ã»ã—ã„ã¨ã€‚ã€‚ã€‚ä½æ•°ã‚’$r$ã¨ã™ã‚‹æ™‚ã«ãŠã„ã¦$P=[e]Q$ã¨ãªã‚‹ã‚ˆã†ãª$e$ãŒå­˜åœ¨ã™ã‚‹æ™‚ã€$P=[e]([65537]P)=[65537e]P)$ã¨ãªã‚‹ã‚ã‘ã§ã™ã­ï¼ï¼ã‚ˆã£ã¦$65537e \\mod r \\equiv1$ãŒæˆã‚Šç«‹ã¡$e$ã‚’æ±‚ã‚ã¦GGã§ã™ã­!!from Crypto.Util.number import bytes_to_long, long_to_bytes, isPrimefrom Crypto.Cipher import AESfrom base64 import b64encode,b64decodefrom Crypto.Util.Padding import padfrom attacks.ecc.mov_attack import attackiv=1605329254557036569964018111218106639001485748371419774269Q_x=1392303607889887553584136595208390161792050603172364540235291678701315789244344186052295822556700256817290239704363991998Q_y=1217907436356492041789129865417129927287034438783900990437895711720259012753482269603468893642710812002767867785347902249p = 1457379754778834114393428514496372769300186542434939310975944765431765709327445548009771988242361974038539406450275157591a = 1236064211753439722521344199773932075287648377233139862790772102290062141518569630890922001641345393262197009050412379555b = 1128111897991419355721141214155995058314857116431662004640521251265155838304469066234949556324122951758680646976644303642ecc = EllipticCurve(GF(p), [a, b])d = 65537# r = ecc.order()r = 1457379754778834114393428514496372769300186542434939310975942617452418525644269374582205991018703761232026759172619867624Q = ecc(Q_x, Q_y)Px = int(pow(d,-1,r))*Qassert Px*d == QPx = Px.xy()[0]Px = long_to_bytes(int(Px))key = Px[:AES.block_size]ct = Px[AES.block_size:]cipher = AES.new(key, AES.MODE_CBC,iv=b64decode(long_to_bytes(int(iv))))c = cipher.decrypt(ct)print(c)# 'CPCTF{Manual_is_imp0rtant}" }, { "title": "å¤§å­¦é™¢ãŒçµ‚ã‚ã£ã¦ã—ã¾ã£ãŸ", "url": "/posts/Reflections_on_Graduate_School/", "categories": "university", "tags": "university", "date": "2023-02-19 00:00:00 +0900", "snippet": "åˆã‚ã«3æœˆ24æ—¥ã‚’æŒã¡ã¾ã—ã¦ã¨ã‚ã‚‹å¤§å­¦ã®åšå£«å‰æœŸèª²ç¨‹ã‚’ä¿®äº†ã—ã€ç„¡äº‹ä¿®å£«(å·¥å­¦)ã®å­¦ä½ã‚’é ‚ãã“ã¨ãŒã§ãã¾ã—ãŸã€‚ã‚ã¾ã‚Šã€å¤§å­¦é™¢ã®ã“ã¨ã‚’æ›¸ãã“ã¨ã‚‚ãªã‹ã£ãŸã®ã§æŒ¯ã‚Šè¿”ã‚Šã®æ„å‘³ã‚‚è¾¼ã‚ã¦ç ”ç©¶å®¤é…å±ã‹ã‚‰ä¿®äº†ã¾ã§æ›¸ã„ã¦ã¿ã‚ˆã†ã‹ã¨æ€ã„ã¾ã™ã€‚ãŸã ã€1å¹´ä»¥ä¸Šå‰ã®ã“ã¨ã‚‚ã‚ã‚‹ã®ã§è¨˜æ†¶ãŒã‚ã‚„ãµã‚„ãªã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ç ”ç©¶ç”Ÿæ´»B4ãã‚‚ãã‚‚ã€åƒ•ã®å¤§å­¦ã§ã¯å­¦éƒ¨4å¹´ç”Ÿã‹ã‚‰ç ”ç©¶å®¤ã«é…å±ã•ã‚Œå’æ¥­è«–æ–‡ã¨ä¿®å£«è«–æ–‡ã«å‘ã‘ã¦ç ”ç©¶ã‚’å§‹ã‚ã¾ã™ã€‚ã“ã®æ™‚ç‚¹ã§ã¯ã€ä»Šã®å¤§å­¦ã«æ®‹ã‚‹æ°—ã¯æ¯›é ­ãªãã€åˆ¥ã®å¤§å­¦ã«å¤§å­¦é™¢ã‹ã‚‰ç§»ã‚‹äºˆå®šã§ã„ã¾ã—ãŸã€‚(B3ã®3æœˆã«ã¯ç ”ç©¶å®¤è¦‹å­¦ã«è¡Œã£ãŸã‚Šã€é™¢è©¦å¯¾ç­–å§‹ã‚ãŸã‚Š)ã€€ãªã®ã§ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ã¯ã©ã‚“ãªã‚‚ã®ã‹ã‚„æ•°å­¦ã‚’å­¦ã¶ã¤ã‚‚ã‚Šã§å­¦éƒ¨4å¹´ã‚’éã”ãã†ã‹ãªã¨è€ƒãˆã¦ã„ãŸã‚‰4æœˆå‰ãã‚‰ã„ã‹ã‚‰æ—¥æœ¬ã§ã‚‚ã‚³ãƒ­ãƒŠãŒæµè¡Œã—ã€ç ”ç©¶å®¤ã§ã‚‚æ„ŸæŸ“ç—‡å¯¾ç­–ãŒè¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã‚¼ãƒŸã¯ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§è¡Œã„ã€ç ”ç©¶å®¤ã®åŒæœŸã‚„å…ˆè¼©ãŒã©ã‚“ãªäººã‹ã‚‚ã‚ã‹ã‚‰ãšã€ã‚ã‚Œã“ã‚Œè©°ã‚“ã§ã­????ã£ã¦ãªã£ã¦ã‚²ãƒ¼ãƒ ã«é€ƒã’ã¾ã—ãŸã€‚8æœˆé ƒ?(æ›–æ˜§ã§ã™â€¦)ã«ã¯å°‘ã—ã¯ç·©å’Œã•ã‚ŒãŸã®ã§å°‘ã—ã¯ç ”ç©¶å®¤ã§ç ”ç©¶ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã“ã®ã“ã‚ã«ã¯ç ”ç©¶å®¤ã®æœ€ä½é™ã®çŸ¥è­˜ã‚„ãƒ†ãƒ¼ãƒã‚’æŠŠæ¡ã§ãã¦ããŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€ã‚ã¾ã‚Šè©³ã—ãã¯è¿°ã¹ã‚‰ã‚Œã¾ã›ã‚“ãŒç ”ç©¶å®¤ã®æ•°å­¦ã‚’æ‰±ã£ãŸãƒ†ãƒ¼ãƒãŒå®Ÿè£…å¯„ã‚Šãªéƒ¨åˆ†ãªã“ã¨ãŒå¤§åŠãªã“ã¨ã‚‚ã‚ã£ã¦ãƒ¢ãƒãƒ™ã¯æ­£ç›´å…¨ããªã‹ã£ãŸã§ã™ã€‚ï¼ˆã”ã‚ã‚“ãªã•ã„ï¼‰ã•ã‚‰ã«ã€ã“ã®æ™‚æœŸã«é™¢è©¦ãŒã‚ã‚Šã¾ã™ãŒã€äºˆå®šã—ã¦ã„ãŸå¤§å­¦é™¢ã®é™¢è©¦æ—¥ç¨‹ãŒä»Šã„ã‚‹å¤§å­¦ã®é™¢è©¦æ—¥ç¨‹ã¨è¢«ã£ã¦ã—ã¾ã†ã®ã§ã€ã©ã†ã™ã‚‹ã®ã‹ã‚ã¡ã‚ƒãã¡ã‚ƒæ‚©ã¿ã¾ã—ãŸãŒã€ãƒã‚­ã£ã¦ä»Šã„ã‚‹å¤§å­¦ã®é™¢è©¦ã‚’å—ã‘ã¾ã—ãŸã€‚å—é¨“çµ‚ã‚ã‚Šã«æœ¬å½“ã«ã“ã®é¸æŠã§è‰¯ã‹ã£ãŸã®ã‹ä»Šã§ã‚‚æ‚©ã‚“ã§ã„ã¾ã™ã€‚ãã‚ãã‚ãƒ†ãƒ¼ãƒã®ç ”ç©¶ã‚’æ±ºã‚ã¦ã‚¹ã‚¿ãƒ¼ãƒˆã•ã›ãªã„ã¨å’æ¥­è«–æ–‡ãŒå¾Œã€…ãã¤ããªã‚‹ã¨æ€ã„ã¾ã™ãŒã€ç ”ç©¶ãƒ†ãƒ¼ãƒã¯å…ˆç”ŸãŒé©å½“ã«èˆˆå‘³ã‚‚ã£ãŸã‚‚ã®ã‚’é©å½“ã«ç†è«–æ§‹ç¯‰ã—ã¦ã‚„ã£ã¦ã¾ã—ãŸã€‚ã“ã“ã§ã‚‚ã€èˆˆå‘³ã¯ã‚ã‚Šã¾ã—ãŸãŒãƒ¢ãƒãƒ™ã¯æ­£ç›´ãªã‹ã£ãŸçŠ¶æ…‹ã‹ã‚‰å¤‰ã‚ã‚‰ãªã‹ã£ãŸã®ã§ã©ã†ã—ã‚ˆã†ã‚‚ãªã„ã§ã™ã€‚ãŸã ã€ã“ã“ã‹ã‚‰è»¢æ©ŸãŒã‚ã‚Šã€ã‚ã‚‹å…ˆè¼©ã‹ã‚‰10æœˆã”ã‚ã«ã€Œæ•°å­¦å¥½ããªã‚“ã ã‚ˆã­?ã€ãªã‚‰ã“ã®ç ”ç©¶ã‚„ã£ã¦ã¿ãªã„ï¼Ÿã€ã£ã¦è¨€ã‚ã‚ŒãªãŒã‚‰ä¸¡è‚©ã‚’ãƒãƒ³ã£ã¨å©ã‹ã‚Œã¾ã—ãŸã€‚åŸºæœ¬çš„ãªå†…å®¹ã¯çŸ¥ã£ã¦ã„ãŸã®ã¨æ¥½ã—ãã†ã ã£ãŸã®ã§äºŒã¤è¿”äº‹ã§ã€Œã‚„ã‚Šã¾ã™!!ã€ã£ã¦ç­”ãˆã¦ç ”ç©¶ãŒã‚¹ã‚¿ãƒ¼ãƒˆã—ã¾ã™ã€‚ã¨ã¯ã„ã£ã¦ã‚‚ã€å’æ¥­è«–æ–‡ã¯ã“ã®ãƒ†ãƒ¼ãƒã§ãªã„ã®ã§ã€ã¡ã‚ƒã‚“ã¨ç ”ç©¶ã™ã‚‹ã®ã¯ã¾ãŸä»Šåº¦ã¨ã„ã†çŠ¶æ…‹ã§ã—ãŸãŒã€‚ã€‚ã€‚ã“ã‚“ãªåŠåˆ†é©å½“ãªæ„Ÿã˜ã§éã”ã—ã¦å­¦éƒ¨4å¹´ç”Ÿã¯çµ‚ã‚ã‚Šã¾ã—ãŸã€‚ã“ã®æ™‚ç‚¹ã§apex legendã®ãƒ—ãƒ¬ã‚¤æ™‚é–“ãŒ3000æ™‚é–“çªç ´ã—ã¦ãŸæ°—ãŒã™ã‚‹â€¦M1ä¿®å£«1å¹´ã¯ã€å‰ã«æ¯”ã¹ã¦ã‚³ãƒ­ãƒŠã®å¯¾å¿œã‚‚æ¯”è¼ƒçš„ç·©ããªã£ãŸã®ã§ã€é€±2-3ãã‚‰ã„ã§ç ”ç©¶å®¤ã«è¡Œã£ã¦ä½œæ¥­ãƒ»ç ”ç©¶ã—ã¦ã¾ã—ãŸã€‚åŒæœŸã‚„å…ˆè¼©ã®ã“ã¨ã‚‚ã ã‚“ã ã‚“ã¨åˆ†ã‹ã£ã¦ããŸã®ã§ã€å‰åŠã«NISTã®PQCã®é¸å®šãŒä½³å¢ƒã«å…¥ã£ãŸã¨ã„ã†ã®ã‚’èã„ã¦ã€ç ”ç©¶å®¤ã®åŒç´šç”ŸPQCã®è«–æ–‡ã‚’èª­ã‚“ã§ã¿ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚åˆã‚ã¦è‹±èªè«–æ–‡ã‹ã¤ã€åˆã‚ã¦ã®è¦‹ã‚‹ç†è«–ãªã®ã§èª­ã‚€ã®ã«ã¯ç›¸å½“ã®æ™‚é–“(2-3ãƒµæœˆ)ã‚’ä½¿ã„ã¾ã—ãŸãŒã€ã‚„ã‚ŠãŸã„ã“ã¨ã‚„æ•°å­¦çš„ãªæ§‹é€ ã¯æœ€ä½é™ã‚ã‹ã‚‹ã‚ˆã†ã«ãªã‚Šå°‘ã—ãšã¤ãƒ¢ãƒãƒ™ãŒå‡ºã¦ãã¦æ¥ã¾ã—ãŸã€‚ãã‚“ãªã“ã‚“ã‚„ã§ã€PQCã¨æ ¼é—˜ã—ã¦ãŸã‚‰ã€ä½•ã‹ã®ã¯ãšã¿(ç ”ç©¶å®¤ã®ãƒ‰ã‚¯ã‚¿ãƒ¼ã®äººã‹ã‚‰ã ã£ãŸã‹ã‚‚?)ã§cryptoctfãªã‚‹ã‚‚ã®ã‚’èã„ãŸã®ã§ã€ç ”ç©¶å®¤ã®å…ˆè¼©ã‚„åŒç´šç”Ÿã¨ã‚„ã£ã¦ã¾ã—ãŸã€‚é¢ç™½ã„ã‘ã©å®Ÿè£…åŠ›ãŒçš†ç„¡ãªã®ã§ã€æ€ã„ã¤ã„ãŸè§£æ³•ã‚’åŒç´šç”Ÿã«å®Ÿè£…ã—ã¦ã‚‚ã‚‰ã£ã¦è§£ã„ã¦ã¾ã—ãŸã€‚ã“ã®å¾Œãã‚‰ã„ã«2é€±é–“ã®ä¼šç¤¾ã¸ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ³ã¸è¡Œãã“ã¨ã«ãªã‚Šã€è©³ã—ãã¯è©±ã›ã¾ã›ã‚“ãŒã„ã„ä½“é¨“ã‚’ã•ã›ã¦ã„ãŸã ãã¾ã—ãŸã€‚ç ”ç©¶ã¨å–¶åˆ©ä¼æ¥­ã¨ã®å·®ã‚’æ„Ÿã˜ã‚ŒãŸã®ã¯å¤§ãã„ã¨æ„Ÿã˜ã¦ã¾ã™ã€‚å°‘ã—ã—ã¦ã€ç§ã®å¤§å­¦ã®å¤§å­¦ç”Ÿãƒ»å¤§å­¦é™¢ç”Ÿã‚’å¯¾è±¡ã¨ã—ãŸCTFã‚’12æœˆã«è¡Œã†ã¨ã„ã†è©±ãŒã‚ã‚Šã¾ã—ãŸã€‚ã¸ãƒ¼ç ”ç©¶å®¤ã§ã‚„ã‚‹ã‚“ã ã¨æ€ã£ã¦ã„ã‚‹ã¨ã€ã‚µãƒ¼ãƒãƒ¼å‘¨ã‚Šã¯å…ˆè¼©ãŒã€ç§ã¯cryptoã®å•é¡Œä½œæˆã™ã‚‹æµã‚Œã«ãªã£ãŸã®ã§4å•ã»ã©ç°¡å˜ãªå¥´ã‚’ã‚ã‚Œã‚„ã“ã‚Œã‚„è¨€ã„ãªãŒã‚‰ä½œã£ã¦ã¾ã—ãŸã€‚æ›´ã«discord serverã‚’èª¿æ•´ã—ãŸã‚Šã—ã¦ã¡ã‚‡ã£ã¨ã—ãŸè£æ–¹ã‚‚ã‚„ã£ã¦ã‚‹ã¨ã€æœ¬ç•ªãŒæ¥ãŸã®ã§ä½œå•ãƒŸã‚¹ãŒãªã„ã‚ˆã†ã«ãŠç¥ˆã‚Šã—ãªãŒã‚‰discord serverã¨solveæ•°ã‚’è¦‹ã¦ã¾ã—ãŸã€‚çµæœã¨ã—ã¦ãƒŸã‚¹ã¯ãªã‹ã£ãŸã‚ˆã†ã§ã„ã„çµŒé¨“ãŒã§ãã¾ã—ãŸã€‚æ›´ã«ã“ã®é ƒã‹ã‚‰kanonã‚’åä¹—ã£ã¦æœ¬æ ¼çš„ã«CTFã‚’ã‚„ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ãã¾ã—ãŸã€‚æ›´ã«ã€å­¦éƒ¨4å¹´ç”Ÿã®æ™‚ã«å¼•ãç¶™ã„ã ç ”ç©¶ã«é€²å±•ãŒã‚ã‚Šã€æº–æ•™æˆã®å…ˆç”Ÿã«è©±ã—è¦‹ã‚‹ã¨ã„ã„ã¨ã“ã‚ã¾ã§ç‹™ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã¨ãªã£ãŸã®ã§ã€ä¿®å£«è«–æ–‡ã‚‚ã‚ã‚‹ç¨‹åº¦ç›®é€”ãŒã¤ã„ãŸã“ã¨ã‚‚ã‚ã‚Šä¸€æ°—ã«è‚©ã®è·ãŒä¸‹ã‚Šã¾ã—ãŸã€‚ã•ã‚‰ã«ã“ã®æ™‚ç‚¹ã§å°±æ´»ã‚‚ã‚ã‚‹ç¨‹åº¦ç›®é€”ãŒã¤ãã€å°±è·ã«æ‚©ã‚€å¿…è¦ã‚‚ãªããªã‚Šã¾ã—ãŸã€‚ãã‚“ãªã“ã‚“ãªã§ã€ä¿®å£«1å¹´ç”Ÿã¯CTFã‚’å§‹ã‚ã¦ã€ç ”ç©¶ã«é€²å±•ãŒã‚ã£ãŸã®ã§ä¸€å®‰å¿ƒã§ãã‚‹ä¸€å¹´ã§ã—ãŸã€‚M2ã‚³ãƒ­ãƒŠã®åˆ¶é™ã‚‚æ˜”ã»ã©ãã¤ãã¯ãªã„ã®ã§ã»ã¼ã»ã¼ç ”ç©¶å®¤ã«ãã¦ä½œæ¥­ã—ã¦ã¾ã—ãŸã€‚ã•ã‚‰ã«ã€M2ã«ãªã‚‹ã¨ç ”ç©¶ã‚ˆã‚Šç™ºè¡¨ã®æ–¹ãŒãƒ¡ã‚¤ãƒ³ã«ãªã‚‹ã®ã§æ¯”è¼ƒçš„æ™‚é–“ã¯ä½œã‚Šã‚„ã™ã‹ã£ãŸã§ã™ã€‚ãã®ãŸã‚ã€å‰åŠã¯ç ”ç©¶ã®æˆæœã¨ã—ã¦å›½éš›ä¼šè­°ã§ã®ç™ºè¡¨ã‚„CTFã‚„CTFã‚’ã—ã¦ã¾ã—ãŸã€‚6æœˆã«å¾Œè¼©ã®ä¸€éƒ¨ã‚‚CTFã‚’ã‚„ã‚Šå§‹ã‚ã¦ã„ãŸã“ã¨ã‚‚ã‚ã‚Šã€10å•ã»ã©ä½œå•ã—ã¦å…ˆç”Ÿã‹ã‚‰ãŠé‡‘ã‚’å‡ºã—ã¦ã‚‚ã‚‰ã„å°‘ã—ã®è³é‡‘ä»˜ãã®ç ”ç©¶å®¤å†…CTFã‚’1äººã§é–‹å‚¬ã—ãŸã‚Šã‚‚ã—ã¦ã¾ã—ãŸã€‚7-8æœˆé ƒã«è»¢æ©ŸãŒã‚ã‚Šã€ä»Šã¾ã§1å¹´é–“èª°ã¨ã‚‚äº¤æµã›ãšä¸€äººã§ã‚„ã£ã¦ãã¾ã—ãŸãŒã€twitterã‚’ä½œæˆã—ã¦æƒ…å ±åé›†ã™ã‚‹ã‹ã¨æ€ã£ã¦ã„ã‚‹ã¨æœ­å¹Œã§ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã£ãŸã®ã§ç”³ã—è¾¼ã‚€ã¨ã€ã‚ã‚ŠãŒãŸã„ã“ã¨ã«SECCON Beginners 2022 æœ­å¹Œ ã«å‚åŠ ã•ã›ã¦ã„ãŸã ãã“ã¨ãŒã§ãã¾ã—ãŸã€‚revã¨webã§ã—ãŸãŒé‹ã‚ˆã3ä½ã«ãªã‚Œã¦ã‚ˆã‹ã£ãŸã§ã™ã€‚ã¦ã‹ã€æ„å¤–ã¨å­¦éƒ¨ç”Ÿã‚„é«˜å°‚ç”ŸãŒã„ã‚‹ã“ã¨ã«é©šããŒéš ã›ã¾ã›ã‚“ã§ã—ãŸã€‚ãã‚“ãªã“ã‚“ã‚„ã§ã€Satoooon (@Satoooon1024) / Twitterã•ã‚“ã¨ãƒãƒ¼ãƒ çµ„ã‚“ã§sekaictfã«å‡ºãŸã‚Š11æœˆã«ã¯SECCON CTFã®äºˆé¸ã‚’ã‚„ã£ãŸã‚Šã—ã¦ã¾ã—ãŸã€‚ç ”ç©¶ã®æ–¹ã‚‚æˆæœã¯ä¿®å£«1å¹´ã®æ™‚ã«ã‚ã‚‹ç¨‹åº¦å‡ºã¦ã„ãŸã®ã§ãã‚Œã‚’ã‚‚ã£ã¦6æœˆã¨10æœˆã«å›½éš›ä¼šè­°ã§ç™ºè¡¨ã—ã¦ã¾ã—ãŸã€‚ã“ã‚Œã§ã€å¾Œã¯SECCON æœ¬æˆ¦ã ã‘ã ã¨æ€ã£ã¦ãŸã‚‰ã€æº–æ•™æˆã®å…ˆç”Ÿã«è«–æ–‡èªŒã‚‚å‡ºã™ã‚ˆã£ã¦è¨€ã‚ã‚Œã¦ç· ã‚åˆ‡ã‚Šè¦‹ã‚‹ã¨2æœˆä¸­æ—¬ã§ã€ãã®æ™‚ã¯å¾Œã ã‹ã‚‰ã„ã„ã‚„ã¨æ€ã£ã¦ã¾ã—ãŸãŒã€å®Ÿã¯2æœˆãŒä¸€ç•ªå¿™ã—ã‹ã£ãŸã¨ã„ã†ã€‚ã€‚ã€‚2æœˆã«äºŒæ—¥ãŠãã«ç· ã‚åˆ‡ã‚ŠãŒæ¥ã¦é †ã«ã€ä¿®è«–ã®æå‡ºæœŸé™ã€SECCONæœ¬æˆ¦ã€è«–æ–‡èªŒã®æŠ•ç¨¿æœŸé™ã€ä¿®è«–ã®ç™ºè¡¨ã‚¹ãƒ©ã‚¤ãƒ‰ã€ä¿®è«–ç™ºè¡¨ä¼šã¨ã„ã†æ„å‘³ä¸æ˜ã§åœ°ç„ã®æ™‚é–“ã§ã—ãŸã€‚ã¾ã˜ã§ã€SECCONãƒ¡ãƒ³ãƒãƒ¼ã«ã¯è¿·æƒ‘ã‹ã‘ãŸã®ã§ç”³ã—è¨³ãªã„ã§ã™ã€‚ã€‚ãã‚“ãªã“ã‚“ãªã‚‚ã‚ã‚Šã¾ã—ãŸãŒã€ç„¡äº‹å’æ¥­ã§ããŸã®ã§ã‚ˆã‹ã£ãŸã§ã™ã€‚éŠã³å…ƒã€…æ—…è¡ŒãŒå¥½ãã§è‰²ã€…ãªå ´æ‰€ã«è¡Œã£ã¦ã¾ã—ãŸãŒã‚³ãƒ­ãƒŠã«ãªã£ã¦æ—…è¡ŒãŒã§ããªããªã‚Šæ¥½ã—ã¿ã‚‚æ¶ˆãˆã¾ã—ãŸã€‚ã§ã‚‚ã€ä¿®å£«ã«ãªã‚‹ã¨åˆ¶é™ã‚‚å¾ã€…ã«è§£é™¤ã•ã‚Œã¦ããŸã®ã§ã€ã ã‚“ã ã‚“ã¨é »åº¦ãŒå¢—ãˆã¦ã„ãã¾ã—ãŸã€‚é«˜æ ¡ã®åŒç´šç”Ÿã‚„å­¦éƒ¨ã®å‹é”ã€ç ”ç©¶å®¤ã®å‹é”ã¨ã‹è‰²ã€…èª˜ã£ã¦é«˜çŸ¥ã‚„æœ­å¹Œãªã©ãªã©æ—¥æœ¬å„åœ°ã«è¡Œãã¾ã—ãŸã€‚å¤šåˆ†ã€ã‚³ãƒ­ãƒŠãŒã¾ã æµè¡Œã£ã¦ã„ãŸã‚‰è¡Œã‘ã¦ãªã‹ã£ãŸã®ã§ãã“ã¯æ•‘ã„ã§ã—ãŸã€‚çµæ§‹ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã«ãªã‚‹ã®ã§ã€‚ã€‚ã“ã‚Œã‹ã‚‰å®Ÿã¯ã€æ–°ç¤¾ä¼šäººã¨ä¸¦è¡Œã—ã¦åšå£«å¾ŒæœŸèª²ç¨‹ã«ç¤¾ä¼šäººDã¨ã—ã¦é€²å­¦ã—ã¾ã™ã€‚ä»Šå‡ºã—ã¦ã„ã‚‹è«–æ–‡ã®æ¡éŒ²çµæœãŒ4æœˆåˆã‚ã«é€šçŸ¥ãŒæ¥ã‚‹ã¯ãšã§ã€ã‚‚ã—ã€é€šã‚Œã°ã“ã‚Œã®æ¡éŒ²ãŒ8æœˆã«ãªã‚‹ã®ã§è«–æ–‡èªŒã®æ¥­ç¸¾ãŒç¨¼ã’ã‚‹ã®ã§åšå£«èª²ç¨‹ã®ä¿®äº†è¦ä»¶ã®ä¸€ç•ªé‡ã„éƒ¨åˆ†ã‚’ã‚¯ãƒªã‚¢ã§ãã‚‹ã®ã§ã€‚ã§ã‚‚ã€é€šã‚‰ãªã‹ã£ãŸã‚‰å³ã‚„ã‚ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã‚‚ã—ã€é€šã‚‰ãšã«åšå£«èª²ç¨‹ã«è¡Œãã¨å¤šåˆ†å¤šå¿™ã§æ­»ã­ã‚‹ã®ã§ã€‚ã€‚ã€‚ãã‚Œã¯ã€å…ˆã«è©±ã‚’é€šã—ã¦æ•™æˆã‚„ä¼šç¤¾ã®æ–¹ã‚‚äº†æ‰¿æ¸ˆã¿ã§ã™ã€‚ã¾ã¨ã‚åˆã‚ã¯ã‚³ãƒ­ãƒŠã«ç¿»å¼„ã•ã‚ŒãŸç ”ç©¶ç”Ÿæ´»ã§ã—ãŸãŒã€å¾Œã€…ã«ãªã‚‹ã¨ã‚³ãƒ­ãƒŠã‚‚è½ã¡ç€ã„ã¦ãã¦æ¯”è¼ƒçš„è‡ªç”±ã«è‰²ã€…ç ”ç©¶ã‚„æ´»å‹•ã‚’ã•ã›ã¦ã„ãŸã ã„ãŸã®ã§å¤§å¤‰ã‚ã‚ŠãŒãŸã‹ã£ãŸã§ã™ã€‚ãã®ãŠã‹ã’ã§CTFã‹ã‚‰å¾—ãŸã‚‚ã®ã‚’ç ”ç©¶ã«é‚„å…ƒã§ããŸã‚Šã€è‰²ã€…ãªäººã¨äº¤æµã‚’æŒã¦ãŸã®ã¯ã„ã„ã“ã¨ã‹ãªã¨æ€ã„ã¾ã—ãŸã€‚ã“ã“ã¾ã§é§„æ–‡ã‚’èª­ã‚“ã§ãã ã•ã‚Šã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼ã€€ã¾ãŸã€ã©ã“ã‹ã§ãŠä¼šã„ã—ã¾ã—ã‚‡ã†ï¼ã§ã¯ã¾ãŸï¾‰ï½¼P.S. å°±è·å…ˆã¯æ±äº¬ãªã®ã§ã€é£¯è¡Œãã¾ã—ã‚‡ã†ï¼ï¼" }, { "title": "HackTM writeup", "url": "/posts/HackTM-writeup/", "categories": "ctf, writeup", "tags": "ctf, writeup", "date": "2023-02-19 00:00:00 +0900", "snippet": "åˆã‚ã«SECCONçµ‚ã‚ã‚Šã®åˆãƒ•ãƒ«å‚åŠ CTFã§ã—ãŸã€‚SECCONã§ã¼ã“ã•ã‚ŒãŸã®ã§ã€åˆå¿ƒå¿˜ã‚‹ã¹ã‹ã‚‰ãšã§ã„ãã¾ã—ãŸã€‚è‰²ã€…è¦‹ã¦ã‚‹æ„Ÿã˜ Double Lariat ã®ãƒ¡ãƒ³ãƒãƒ¼èª˜ãˆã°è‰¯ã‹ã£ãŸã¨å¾Œæ‚”â€¦orzå¤šåˆ†ã„ã„æ‰€ã¾ã§è¡Œã‘ãŸã‚“ã˜ã‚ƒãªã„ã‹ãªãâ€¦[crypto] d-phi-encchallfrom Crypto.Util.number import bytes_to_long, getStrongPrimefrom secret import flagassert len(flag) == 255e = 3p = getStrongPrime(1024, e=e)q = getStrongPrime(1024, e=e)n = p * qphi = (p - 1) * (q - 1)d = pow(e, -1, phi)enc_d = pow(d, e, n)enc_phi = pow(phi, e, n)enc_flag = pow(bytes_to_long(flag), e, n)print(f\"{n = }\")print(f\"{enc_d = }\")print(f\"{enc_phi = }\")print(f\"{enc_flag = }\")solve$enc_{phi} \\equiv phi^e \\mod n,enc_d \\equiv d^e \\mod n$ ã‹ã‚‰ $phi$ ã‚’å¾©å…ƒã™ã‚Œã°ãŠã£ã‘ãƒ¼ã§ã™ã€‚ãªã®ã§ $e^e*enc_d \\equiv (ed)^e \\mod n \\equiv (k*phi+1)^e \\mod n$ ã§$k$ã¯2ã§ã‚ã‚‹ã“ã¨ãŒæ‰‹å…ƒã§å®Ÿé¨“ã—ã¦ã‚ã‹ã£ã¦ã‚‹ã®ã§ã€ å¤šé …å¼gcdã§$phi$ã ã—ã¦å¾Œã¯è‰¯ã—ãªã«â€¦from Crypto.Util.number import *from sage.all import *n = 24476383567792760737445809443492789639532562013922247811020136923589010741644222420227206374197451638950771413340924096340837752043249937740661704552394497914758536695641625358888570907798672682231978378863166006326676708689766394246962358644899609302315269836924417613853084331305979037961661767481870702409724154783024602585993523452019004639755830872907936352210725695418551084182173371461071253191795891364697373409661909944972555863676405650352874457152520233049140800885827642997470620526948414532553390007363221770832301261733085022095468538192372251696747049088035108525038449982810535032819511871880097702167enc_d = 23851971033205169724442925873736356542293022048328010529601922038597156073052741135967263406916098353904000351147783737673489182435902916159670398843992581022424040234578709904403027939686144718982884200573860698818686908312301218022582288691503272265090891919878763225922888973146019154932207221041956907361037238034826284737842344007626825211682868274941550017877866773242511532247005459314727939294024278155232050689062951137001487973659259356715242237299506824804517181218221923331473121877871094364766799442907255801213557820110837044140390668415470724167526835848871056818034641517677763554906855446709546993374enc_phi = 3988439673093122433640268099760031932750589560901017694612294237734994528445711289776522094320029720250901589476622749396945875113134575148954745649956408698129211447217738399970996146231987508863215840103938468351716403487636203224224211948248426979344488189039912815110421219060901595845157989550626732212856972549465190609710288441075239289727079931558808667820980978069512061297536414547224423337930529183537834934423347408747058506318052591007082711258005394876388007279867425728777595263973387697391413008399180495885227570437439156801767814674612719688588210328293559385199717899996385433488332567823928840559enc_flag = 24033688910716813631334059349597835978066437874275978149197947048266360284414281504254842680128144566593025304122689062491362078754654845221441355173479792783568043865858117683452266200159044180325485093879621270026569149364489793568633147270150444227384468763682612472279672856584861388549164193349969030657929104643396225271183660397476206979899360949458826408961911095994102002214251057409490674577323972717947269749817048145947578717519514253771112820567828846282185208033831611286468127988373756949337813132960947907670681901742312384117809682232325292812758263309998505244566881893895088185810009313758025764867e = 3poly_gcd = lambda g1, g2: g1.monic() if not g2 else poly_gcd(g2, g1%g2)PR.&lt;phi&gt; = PolynomialRing(Zmod(n))poly = [(2*phi +1)^e - enc_d * e^3, phi^3 -enc_phi,]phi = poly_gcd(poly[0],poly[1]).small_roots()[0]PR.&lt;p,q&gt; = QQ[]polys = [ p*q -n, (p-1)*(q-1) - int(phi),]I = Ideal(polys)ans = I.variety(ring=ZZ)[0]p, q = ans[p], ans[q]d = pow(e,-1,int(phi))print(long_to_bytes(int(pow(enc_flag,d,n))))# HackTM{Have you warmed up? If not, I suggest you consider the case where e=65537, although I don't know if it's solvable. Why did I say that? Because I have to make this flag much longer to avoid solving it just by calculating the cubic root of enc_flag.}[crypto] kaitenzushichallfrom math import gcdfrom Crypto.Util.number import bytes_to_long, isPrimefrom secret import p, q, x1, y1, x2, y2, e, flag# properties of secret variablesassert isPrime(p) and p.bit_length() == 768assert isPrime(q) and q.bit_length() == 768assert isPrime(e) and e.bit_length() == 256assert gcd((p - 1) * (q - 1), e) == 1assert x1.bit_length() &lt;= 768 and x2.bit_length() &lt;= 768assert y1.bit_length() &lt;= 640 and y2.bit_length() &lt;= 640assert x1 ** 2 + e * y1 ** 2 == p * qassert x2 ** 2 + e * y2 ** 2 == p * q# encrypt flag by RSA, with xorn = p * qc = pow(bytes_to_long(flag) ^^ x1 ^^ y1 ^^ x2 ^^ y2, e, n)print(f\"{n = }\")print(f\"{c = }\") ,# hints ğŸ£F = RealField(1337)x = vector(F, [x1, x2])y = vector(F, [y1, y2])# rotatetheta = F.random_element(min=-pi, max=pi)R = matrix(F, [[cos(theta), -sin(theta)], [sin(theta), cos(theta)]])x = R * xy = R * yprint(f\"{x = }\")print(f\"{y = }\")solveè¦‹ãŸæ„Ÿã˜ $x1,y1,x2,y2$ ã®å¾©å…ƒã‚’ã‚„ã‚‰ãªã„ã¨å§‹ã¾ã‚“ãªã„ã¿ãŸã„ã§ã™ã­ã€‚ã¦ãªã‚ã‘ã§ã€æ–¹é‡ã¨ã—ã¦ä»¥ä¸‹ã®æ„Ÿã˜ã«ãªã‚Šã¾ã™ã€‚ $x1,y1,x2,y2$ ã®å¾©å…ƒ $p,q$ ã®ç´ å› æ•°åˆ†è§£part1å†™åƒå¾Œã®printã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã‚’ $X_i,Y_i$ ã«ã—ã¦å¼ã«æ›¸ãã¨ä¸‹ã®æ„Ÿã˜ã«ãªã‚‹ã€‚\\[\\begin{bmatrix} X_1 &amp; Y_1 \\\\ X_2 &amp; Y_2\\end{bmatrix} =\\begin{bmatrix} cos(\\theta) &amp; sin(\\theta) \\\\ sin(\\theta) &amp; cos(\\theta)\\end{bmatrix} \\begin{bmatrix} x_1 &amp; y_1 \\\\ x_2 &amp; y_2\\end{bmatrix}\\]ã•ã‚‰ã«ã€$x_1^2 + e* y_1^2 = p*q,x_2^2 + e* y_2^2 = p*q$ã§ã‚ã‚‹ã“ã¨ã‚‚è€ƒãˆã‚‹ã¨å…¨ã¦å¤‰æ•°åŒ–ã—ã¦ã€çµ‚çµå¼ã¸æŠ•ã’ã‚‹ã¨ã„ã„æ„Ÿã˜ã«å¸°ã£ã¦ãã‚‹def resultant(f1, f2, var): return Matrix(f1.sylvester_matrix(f2, var)).determinant()PR.&lt;c,s,e,x0,x1,y0,y1,n&gt; = QQ[]polys = [ c^2 + s^2 - 1, (x0*c + x1*s)^2 + e*(c* y0 + s*y1)^2 - n, (x1*c + x0*(-s))^2 + e*(c* y1 + (-s)*y0)^2 - n,]print(resultant(polys[1], polys[2], s))# s side# 4*s^4*x0^2*x1^2*y0^4 + 4*s^4*x1^4*y0^4 - 8*s^4*x0^3*x1*y0^3*y1 - 8*s^4*x0*x1^3*y0^3*y1 + 4*s^4*x0^4*y0^2*y1^2 + 8*s^4*x0^2*x1^2*y0^2*y1^2 + 4*s^4*x1^4*y0^2*y1^2 - 8*s^4*x0^3*x1*y0*y1^3 - 8*s^4*x0*x1^3*y0*y1^3 + 4*s^4*x0^4*y1^4 + 4*s^4*x0^2*x1^2*y1^4 - 8*s^4*x1^2*y0^4*n + 16*s^4*x0*x1*y0^3*y1*n - 8*s^4*x0^2*y0^2*y1^2*n - 8*s^4*x1^2*y0^2*y1^2*n + 16*s^4*x0*x1*y0*y1^3*n - 8*s^4*x0^2*y1^4*n - 4*s^2*x0^2*x1^2*y0^4 - 4*s^2*x1^4*y0^4 + 8*s^2*x0^3*x1*y0^3*y1 + 8*s^2*x0*x1^3*y0^3*y1 - 4*s^2*x0^4*y0^2*y1^2 - 8*s^2*x0^2*x1^2*y0^2*y1^2 - 4*s^2*x1^4*y0^2*y1^2 + 8*s^2*x0^3*x1*y0*y1^3 + 8*s^2*x0*x1^3*y0*y1^3 - 4*s^2*x0^4*y1^4 - 4*s^2*x0^2*x1^2*y1^4 + 4*s^4*y0^4*n^2 + 8*s^4*y0^2*y1^2*n^2 + 4*s^4*y1^4*n^2 + 8*s^2*x1^2*y0^4*n - 16*s^2*x0*x1*y0^3*y1*n + 8*s^2*x0^2*y0^2*y1^2*n + 8*s^2*x1^2*y0^2*y1^2*n - 16*s^2*x0*x1*y0*y1^3*n + 8*s^2*x0^2*y1^4*n + x1^4*y0^4 - 2*x0^2*x1^2*y0^2*y1^2 + x0^4*y1^4 - 4*s^2*y0^4*n^2 - 8*s^2*y0^2*y1^2*n^2 - 4*s^2*y1^4*n^2 - 2*x1^2*y0^4*n + 2*x0^2*y0^2*y1^2*n + 2*x1^2*y0^2*y1^2*n - 2*x0^2*y1^4*n + y0^4*n^2 - 2*y0^2*y1^2*n^2 + y1^4*n^2å¾Œã¯ä»£å…¥ã™ã‚‹ã¨ã€n = ----[snipped]----ct = ----[snipped]----x = ----[snipped]----y = ----[snipped]----F = RealField(1337)PR.&lt;s&gt; = PolynomialRing(F)x0,x1 = xy0,y1 = ypoly_s = 4*s^4*x0^2*x1^2*y0^4 + 4*s^4*x1^4*y0^4 - 8*s^4*x0^3*x1*y0^3*y1 - 8*s^4*x0*x1^3*y0^3*y1 + 4*s^4*x0^4*y0^2*y1^2 + 8*s^4*x0^2*x1^2*y0^2*y1^2 + 4*s^4*x1^4*y0^2*y1^2 - 8*s^4*x0^3*x1*y0*y1^3 - 8*s^4*x0*x1^3*y0*y1^3 + 4*s^4*x0^4*y1^4 + 4*s^4*x0^2*x1^2*y1^4 - 8*s^4*x1^2*y0^4*n + 16*s^4*x0*x1*y0^3*y1*n - 8*s^4*x0^2*y0^2*y1^2*n - 8*s^4*x1^2*y0^2*y1^2*n + 16*s^4*x0*x1*y0*y1^3*n - 8*s^4*x0^2*y1^4*n - 4*s^2*x0^2*x1^2*y0^4 - 4*s^2*x1^4*y0^4 + 8*s^2*x0^3*x1*y0^3*y1 + 8*s^2*x0*x1^3*y0^3*y1 - 4*s^2*x0^4*y0^2*y1^2 - 8*s^2*x0^2*x1^2*y0^2*y1^2 - 4*s^2*x1^4*y0^2*y1^2 + 8*s^2*x0^3*x1*y0*y1^3 + 8*s^2*x0*x1^3*y0*y1^3 - 4*s^2*x0^4*y1^4 - 4*s^2*x0^2*x1^2*y1^4 + 4*s^4*y0^4*n^2 + 8*s^4*y0^2*y1^2*n^2 + 4*s^4*y1^4*n^2 + 8*s^2*x1^2*y0^4*n - 16*s^2*x0*x1*y0^3*y1*n + 8*s^2*x0^2*y0^2*y1^2*n + 8*s^2*x1^2*y0^2*y1^2*n - 16*s^2*x0*x1*y0*y1^3*n + 8*s^2*x0^2*y1^4*n + x1^4*y0^4 - 2*x0^2*x1^2*y0^2*y1^2 + x0^4*y1^4 - 4*s^2*y0^4*n^2 - 8*s^2*y0^2*y1^2*n^2 - 4*s^2*y1^4*n^2 - 2*x1^2*y0^4*n + 2*x0^2*y0^2*y1^2*n + 2*x1^2*y0^2*y1^2*n - 2*x0^2*y1^4*n + y0^4*n^2 - 2*y0^2*y1^2*n^2 + y1^4*n^2# print(poly_s.roots())_, _, c, s = [_[0] for _ in poly_s.roots()]ã“ã‚Œã§ $sin(\\theta),cos(\\theta)$ã®å€¤ãŒã‚ã‹ã£ãŸã€‚ãŸã ã€å€™è£œãŒ2ã¤ã‚ã‚‹(æ­£å›è»¢oré€†å›è»¢)ã®ã§ä»£å…¥ã—ã¦ã€å€¤ãŒæ•´æ•°ã¨ã„ã†ã“ã¨ã‚’è€ƒãˆã¦ã‚„ã‚Œã°ä¸€æ„ã«æ±ºã¾ã‚‹ã€‚def solve_xs_ys(s,c): x = ----[snipped]---- y = ----[snipped]---- F = RealField(1337) x = vector(F, [_ for _ in x]) y = vector(F, [_ for _ in y]) # rotate R = matrix(F, [[c, -s], [s, c]]) x = R^(-1) * x y = R^(-1) * y # print(f\"{x = }\") # print(f\"{y = }\") return x,y# true# print(solve_xs_ys(s,c))# ret = (1.23343431936894440973263647479974540141395074556779828339916509613682879668610901423506961118285523166037774054833601787794419590891163752205158573276826154790166536984681500991748749778629881670438838666011425669518792357094873553000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005e230, -9.93315378106395196440156892634615357425859001976376351903878161126954317590016249318316631584063366449446002974804447367756266228508159317926113473123770241598131922105753478630709094061327843793983555725542453353312556415777678936999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999998e230), (2.95702891759040183827241488621026109955415212852401225663178715196876893509028690821994463400830412991408307468450766653970029004782754586267046590672581397139817053510458959806568392753705926800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e192, -1.93518098174342694414424160720807163740044134017573004218248685165604434384710484681124817651698709818703976889508767807895216618103609127904817977547152172876909535027087606807328610207963607999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999989e191)ret = (123343431936894440973263647479974540141395074556779828339916509613682879668610901423506961118285523166037774054833601787794419590891163752205158573276826154790166536984681500991748749778629881670438838666011425669518792357094873553, -993315378106395196440156892634615357425859001976376351903878161126954317590016249318316631584063366449446002974804447367756266228508159317926113473123770241598131922105753478630709094061327843793983555725542453353312556415777678937), (2957028917590401838272414886210261099554152128524012256631787151968768935090286908219944634008304129914083074684507666539700290047827545862670465906725813971398170535104589598065683927537059268, -193518098174342694414424160720807163740044134017573004218248685165604434384710484681124817651698709818703976889508767807895216618103609127904817977547152172876909535027087606807328610207963608)(x1, x2), (y1, y2) = retã“ã‚Œã§ã€part1ã¯ãŠã—ã¾ã„ã€‚part2é›£é–¢??ãªã®ã‹é¢¨å‘‚å…¥ã£ã¦ãŸã‚‰æ€ã„ã¤ãã¾ã—ãŸã€‚å…ã«ã‚‚è§’ã«ã‚‚ $e$ ã¯é€Ÿæ”»ã§ã‚ã‹ã‚‹ã®ã§ã€å‡ºã—ã¦ãŠãã¾ã™ã€‚x0,x1 = xy0,y1 = ypoly_e = (x0*c + x1*s)^2 + e*(c* y0 + s*y1)^2 - nprint(poly_e.roots())#[(1.1157800980263640943712375759161704818976014542355242141862733874983591656180100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e77, 1)]e = 111578009802636409437123757591617048189760145423552421418627338749835916561801æœ¬é¡Œã§ã™ã€‚ä»Šå›ã¯æ¡ä»¶ã¨ã—ã¦ $x1,y1,x2,y2$ ãŒæ¥•å††ä¸Šã®æœ‰ç†ç‚¹ã§ã‚ã‚‹ã“ã¨ã‹ã‚‰ã€$x_1^2 + e* y_1^2 = p*q,x_2^2 + e* y_2^2 = p*q$ ã®ç­‰å¼ãŒæˆã‚Šç«‹ã¤ã€‚ä¸€æ—¦ã€$\\mod p$ ã‚’å–ã‚‹ã¨\\[x_1^2 + e* y_1^2 \\equiv 0 \\mod p\\]\\[x_2^2 + e* y_2^2 \\equiv 0 \\mod p\\]ã“ã“ã§ã€ä¸Šã®å¼ã«ã¯ $y_2^2$ ã‚’ã€ä¸‹ã®å¼ã«ã¯ $y_1^2$ ã‚’ã€ã‹ã‘ã¦ã‚„ã‚‹ã¨ä»¥ä¸‹ã«ãªã‚‹ã€‚\\[(x_1y_2)^2 + e* (y_1y_2)^2 \\equiv 0 \\mod p\\]\\[(x_2y_1)^2 + e* (y_1y_2)^2 \\equiv 0 \\mod p\\]ä»®ã«ã€ã‚ã‚‹ $x_{tmp}$ ãŒåº§æ¨™ã«å­˜åœ¨ã™ã‚‹ã¨ $Â±y_{tmp}$ ã‚‚åŒæ§˜ã«å­˜åœ¨ã—ã¾ã™ã€‚ã“ã®ã“ã¨ã‚‚åŠ å‘³ã™ã‚‹ã¨\\[(x_1y_2)^2 \\equiv (x_2y_1)^2\\]\\[Â±x_1y_2 \\equiv \\mp x_2y_1\\]ã“ã‚Œã‚ˆã‚Š $p,q$ ã©ã¡ã‚‰ã‹ã®ç´ æ•°ãŒå‡ºã™ã“ã¨ãŒã§ãã‚‹ã®ã§å¾©å·ã—ã¦ãŠã‚ã‚Šã€‚p = GCD(int(x1*y2 -x2*y1),n)q = n//pprint(p)assert p*q == nn = ----[snipped]----ct = ----[snipped]----x = ----[snipped]----y = ----[snipped]----e = 111578009802636409437123757591617048189760145423552421418627338749835916561801p = 957509848415776008506125961998120495161250346184055094697245571121876444575553394581756735245207167681344755095903616730328731358607257251854603846193989936802222147961302618645021044609662945352893811478461448918625795339911124621ret = (123343431936894440973263647479974540141395074556779828339916509613682879668610901423506961118285523166037774054833601787794419590891163752205158573276826154790166536984681500991748749778629881670438838666011425669518792357094873553, -993315378106395196440156892634615357425859001976376351903878161126954317590016249318316631584063366449446002974804447367756266228508159317926113473123770241598131922105753478630709094061327843793983555725542453353312556415777678937), (2957028917590401838272414886210261099554152128524012256631787151968768935090286908219944634008304129914083074684507666539700290047827545862670465906725813971398170535104589598065683927537059268, -193518098174342694414424160720807163740044134017573004218248685165604434384710484681124817651698709818703976889508767807895216618103609127904817977547152172876909535027087606807328610207963608)(x1, x2), (y1, y2) = retq = n//pphi = (p-1)*(q-1)d = pow(int(e),-1,phi)m = pow(c,d,n)print(m)m = x1 ^ y1 ^ x2 ^ y2 ^ mprint(m.bit_length())print(long_to_bytes(int(m)))# HackTM{r07473_pr353rv35_50m37h1n6}ãŸã ã€å¾©å·ã™ã‚‹ã¨ HackTM{r07473_pr353rv35_50m37h1n6sã«ãªã‚‹ã®ã§ä½•ã‹ãƒŸã‚¹ã£ã¦ã‚‹å¯èƒ½æ€§ã‚ã‚‹ã‹ã‚‚â€¦????ã§ã‚‚ã€ã“ã“ã¾ã§æ¥ãŸã‚‰åˆå¿ƒè€…OSINTã—ã¦s â†’ }ã ã‚ã£ã¦ã“ã¨ã§å‡ºã—ãŸã‚‰é€šã‚Šã¾ã—ãŸã€‚GG[crypto] broken_oracle (canâ€™t solve)chall#!/usr/local/bin/python3\"\"\"implementation of https://www.cs.umd.edu/~gasarch/TOPICS/miscrypto/rabinwithrecip.pdf\"\"\"import osimport randomfrom dataclasses import dataclassfrom math import gcdfrom typing import List, Tupleimport gmpy2from Crypto.Util.number import bytes_to_long, getPrimefrom secret import flag@dataclassclass Pubkey: n: int c: int@dataclassclass Privkey: p: int q: int@dataclassclass Enc: r: int s: int t: int def __repr__(self) -&gt; str: return f\"r = {self.r}\\ns = {self.s}\\nt = {self.t}\"def crt(r1: int, n1: int, r2: int, n2: int) -&gt; int: g, x, y = gmpy2.gcdext(n1, n2) assert g == 1 return int((n1 * x * r2 + n2 * y * r1) % (n1 * n2))def gen_prime(pbits: int) -&gt; int: p = getPrime(pbits) while True: if p % 4 == 3: return p p = getPrime(pbits)def genkey(pbits: int) -&gt; Tuple[Pubkey, Privkey]: p, q = gen_prime(pbits), gen_prime(pbits) n = p * q c = random.randint(0, n - 1) while True: if gmpy2.jacobi(c, p) == -1 and gmpy2.jacobi(c, q) == -1: break c = random.randint(0, n - 1) pubkey = Pubkey(n=n, c=c) privkey = Privkey(p=p, q=q) return pubkey, privkeydef encrypt(m: int, pub: Pubkey) -&gt; Enc: assert 0 &lt; m &lt; pub.n assert gcd(m, pub.n) == 1 r = int((m + pub.c * pow(m, -1, pub.n)) % pub.n) s = int(gmpy2.jacobi(m, pub.n)) t = int(pub.c * pow(m, -1, pub.n) % pub.n &lt; m) enc = Enc(r=r, s=s, t=t) assert s in [1, -1] assert t in [0, 1] return encdef solve_quad(r: int, c: int, p: int) -&gt; Tuple[int, int]: \"\"\" Solve x^2 - r * x + c = 0 mod p See chapter 5. \"\"\" def mod(poly: List[int]) -&gt; None: \"\"\" Calculate mod x^2 - r * x + c (inplace) \"\"\" assert len(poly) == 3 if poly[2] == 0: return poly[1] += poly[2] * r poly[1] %= p poly[0] -= poly[2] * c poly[0] %= p poly[2] = 0 def prod(poly1: List[int], poly2: List[int]) -&gt; List[int]: \"\"\" Calculate poly1 * poly2 mod x^2 - r * x + c \"\"\" assert len(poly1) == 3 and len(poly2) == 3 assert poly1[2] == 0 and poly2[2] == 0 res = [ poly1[0] * poly2[0] % p, (poly1[1] * poly2[0] + poly1[0] * poly2[1]) % p, poly1[1] * poly2[1] % p, ] mod(res) assert res[2] == 0 return res # calculate x^exp mod (x^2 - r * x + c) in GF(p) exp = (p - 1) // 2 res_poly = [1, 0, 0] # = 1 cur_poly = [0, 1, 0] # = x while True: if exp % 2 == 1: res_poly = prod(res_poly, cur_poly) exp //= 2 if exp == 0: break cur_poly = prod(cur_poly, cur_poly) # I think the last equation in chapter 5 should be x^{(p-1)/2}-1 mod (x^2 - Ex + c) # (This change is not related to vulnerability as far as I know) a1 = -(res_poly[0] - 1) * pow(res_poly[1], -1, p) % p a2 = (r - a1) % p return a1, a2def decrypt(enc: Enc, pub: Pubkey, priv: Privkey) -&gt; int: assert 0 &lt;= enc.r &lt; pub.n assert enc.s in [1, -1] assert enc.t in [0, 1] mps = solve_quad(enc.r, pub.c, priv.p) mqs = solve_quad(enc.r, pub.c, priv.q) ms = [] for mp in mps: for mq in mqs: m = crt(mp, priv.p, mq, priv.q) if gmpy2.jacobi(m, pub.n) == enc.s: ms.append(m) assert len(ms) == 2 m1, m2 = ms if m1 &lt; m2: m1, m2 = m2, m1 if enc.t == 1: m = m1 elif enc.t == 0: m = m2 else: raise ValueError return mif __name__ == \"__main__\": pbits = 1024 pub, priv = genkey(pbits) while len(flag) &lt; 255: flag += os.urandom(1) enc_flag = encrypt(bytes_to_long(flag), pub) print(\"encrypted flag:\") print(enc_flag) while True: try: r, s, t = map(int, input(\"r, s, t = \").split(\",\")) enc = Enc(r=r, s=s, t=t) enc_dec_enc = encrypt(decrypt(enc, pub, priv), pub) print(\"decrypt(encrypt(input)):\") print(enc_dec_enc) except Exception: print(\"Something wrong...\")solveåˆã‚ã« $priv,pub$ ã™ã‚‰åˆ†ã‹ã£ã¦ãªã„ã®ã§ã€ä¸€æ—¦ã€$p,q$ ã‚’æ±‚ã‚ã¦ã„ãã€‚å…·ä½“çš„ã«ã¯ã€ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯dec â†’ enc ã‚’è¡Œã£ã¦ãã‚Œã‚‹ã‚‚ã®ã€ãŸã¾ã«å…¥åŠ›ã—ãŸ $enc$ ã§ã¯ãªã„å€¤ãŒå‡ºã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ã€ãã‚Œã‚’ä½¿ã£ã¦ $p,q$ ã‚’æ±‚ã‚ã¦ã„ãã€‚å¸°ã£ã¦ãã‚‹å€¤ã¨ã—ã¦ã¯(å¤šåˆ†) $a, a+k_1p,a+k_2q,a+k_3p+k_3q$çš„ãªæ„Ÿã˜ã ã¨æ€ã†ã€‚ãªã®ã§ã€GCD ã‚’ä¸Šæ‰‹ãä½¿ã£ã¦ã‚„ã‚‹def find_n(io,p,n): cnt = 1 factors =set() while True: ret = [] for _s in [-1,1]: for _t in [0,1]: tmp = send_ans(cnt,_s,_t) if False == tmp: return False ret.append(tmp[0]) if len(set(ret)) ==2: _ = abs(ret[0]-ret[1]) _ = factor(_,limit=10^8)[-1][0] factors.add(_) if len(set(ret)) ==4: _ = GCD(abs(ret[0]-ret[2]) ,abs(ret[3]-ret[1])) _ = factor(_,limit=10^8)[-1][0] factors.add(_) fac_list = list(factors) fac_list.sort() for i in fac_list: for k in fac_list: if GCD(i,k) !=1: factors.add(GCD(i,k)) if len(factors) &lt;3: cnt +=1 continue if int(fac_list[0]).bit_length() &lt; 1025 and int(fac_list[1]).bit_length() &lt; 1025 and int(fac_list[0])!=1 and int(fac_list[1])!=1: print(\"ret=\",int(fac_list[0]),int(fac_list[1])) return int(fac_list[0]),int(fac_list[1]) cnt +=1ã“ã‚Œã§ã€ $priv$ ã®å¾©å…ƒãŒçµ‚ã‚ã£ãŸã®ã§ã€$pub$ ã©ã†ã™ã£ã‹ãªãƒ¼å•é¡Œã®ç™ºç”Ÿæ¡ˆ1 $x^2 + E*x + c$ã®å‰°ä½™ç’°ã‚’è€ƒãˆã‚‹solve_quadé–¢æ•°ã§ $x^{(p-1)//2} \\equiv ax +b-1 \\mod x^2 + E*x + c$ ã‚’è€ƒãˆã¦ã„ã‚‹ã‚ˆã£ã¦ã€å®‰ç›´ã«2å¤‰æ•°ã®å‰°ä½™ç’°ã§ã„ã„ã‹ãªãã£ã¦è€ƒãˆã¦ã„ãŸã‚‰ toy implementation ã§ã„ã¤ã¾ã§ãŸã£ã¦ã‚‚çµ‚ã‚ã‚‰ãªã„â€¦æ¡ˆ2 æ¡ˆ1ã‚’ encã®è§£ã‚’$A_1,A_2$ ã¨ã—ã¦ã€€ã‚°ãƒ¬ãƒ–ãƒŠãƒ¼ã”ã‚ŠæŠ¼ã—$x^{(p-1)//2}$ ã‚’ $x^2 -Ex+c$ ãŒå‰²ã‚Šåˆ‡ã‚Œãªã„æ™‚ã«å€¤ãŒãƒã‚°ã‚‹ã®ã§ã€ã“ã®æ™‚ã®solve_quadé–¢æ•°ã®è§£ã‚’ $A_1,A_2$ ã¨ã™ã‚‹ã€‚ã“ã“ã§ã€$r = A_1 + {C \\over A_1}$ ã§ã‚ã‚‹ã“ã¨ã‹ã‚‰ $r = A_1 + A_1 * {C \\over A_1*A_2}$ã¨ãªã‚‹??\\[r1 + r2 = A_1 + A_1 * {C \\over A_1*A_2} + A_2 + A_2 * {C \\over A_2*A_1}\\]\\[r1 * r2 = (A_1 + A_1 * {C \\over A_1*A_2}) * (A_2 + A_2 * {C \\over A_2*A_1})\\]ä»¥ä¸Šã®å¼ãŒæˆã‚Šç«‹ã¡ãã†â€¦???ã§ã‚‚ã¨ã‘ã¬â€¦ã’ã›ã¬â€¦å¤šåˆ†ã‚ã£ã¦ãŸâ€¦.ã§ã‚‚ã€ é–“ã«åˆã‚ãªã„ã§ã™â€¦â€¦orz# PR.&lt;c&gt; = PolynomialRing(GF(q))PR.&lt;C,C_prime&gt; = PolynomialRing(GF(q))# C_prime = A1 * A2# i = A1 + A2polys = [ C_prime^2 + (i^2 - 2*C_prime)*C + C^2 - C_prime* dec[0] * dec[1], i * (C + C_prime) - C_prime * (dec[0] + dec[1]),]I = Ideal(polys)ans = I.variety()print(ans)è¿½è¨˜ç«¶æŠ€çµ‚äº†10åˆ†å¾Œã«æ±‚ã¾ã‚Šã¾ã—ãŸã€‚æ³£ããã†ã§ã™ã€‚ã€‚ã€‚æ–¹é‡æ¡ˆ2ã§åˆã£ã¦ã„ã¦ãã‚Œã§çµ‚ã‚ã‚Šã¾ã™ã€‚GGfrom pwn import *from server import decrypt, Privkey,Pubkey,Encfrom random import randintfrom factordb.factordb import FactorDBimport gmpy2from Crypto.Util.number import *poly_gcd = lambda g1, g2: g1.monic() if not g2 else poly_gcd(g2, g1%g2)def send_ans(r,s,t): io.sendlineafter(b\"r, s, t = \",(str(r)+\",\"+str(s)+\",\"+str(t)).encode()) if b\"Something\" in io.recvline(): return False return [int(_) for _ in io.recvline().decode().split(\"=\")[1].split(\",\")]p = 0n = 0def find_n(io,p,n): cnt = 1 p,n =0,0 factors =set() while True: ret = [] for _s in [-1,1]: for _t in [0,1]: tmp = send_ans(cnt,_s,_t) if False == tmp: return False ret.append(tmp[0]) if len(set(ret)) ==2: _ = abs(ret[0]-ret[1]) _ = factor(_,limit=10^8)[-1][0] factors.add(_) if len(set(ret)) ==4: _ = GCD(abs(ret[0]-ret[2]) ,abs(ret[3]-ret[1])) _ = factor(_,limit=10^8)[-1][0] factors.add(_) fac_list = list(factors) fac_list.sort() for i in fac_list: for k in fac_list: if GCD(i,k) !=1: factors.add(GCD(i,k)) if len(factors) &lt;3: cnt +=1 continue if int(fac_list[0]).bit_length() &lt; 1025 and int(fac_list[1]).bit_length() &lt; 1025 and int(fac_list[0])!=1 and int(fac_list[1])!=1: # print(\"ret=\",int(fac_list[0]),int(fac_list[1])) return int(fac_list[0]),int(fac_list[1]) return False cnt +=1def find_c(io,p,q): p = int(str(p)) q = int(str(q)) retc = [] for t_prime in [q,p]: for i in range(3,100): ret = [] for _t in [0,1]: # for _s in [-1,1]: ret.append(send_ans(i,1,_t)[0]) if len(set(ret)) !=2: continue # print(ret,i) if GCD(ret[0] - ret[1],t_prime) !=1: continue PR.&lt;C,C_prime&gt; = PolynomialRing(GF(t_prime)) polys = [ C_prime^2 + (i^2 - 2*C_prime)*C + C^2 - C_prime* ret[0] * ret[1], i * (C + C_prime) - C_prime * (ret[0] + ret[1]), ] I = Ideal(polys) ans = I.variety()[1] print(t_prime,ans) retc.append([t_prime,ans[C]]) break return retc while True: io = remote(\"34.141.16.87\", 50001) # io = process([\"python3\",\"server.py\"]) io.recvline() # rst exec(io.recvline(None).decode()) exec(io.recvline(None).decode()) exec(io.recvline(None).decode()) print(r,s,t) tmp = find_n(io,p,n) if False == tmp: io.close() continue q,p = tmp n = p*q if p&gt;q: p,q = q,p print(p,q) print(\"findc\") cs = find_c(io,p,q) C = int(CRT([int(cs[0][1]),int(cs[1][1])],[int(cs[0][0]),int(cs[1][0])])) print(\"C\",C) p = int(p) q = int(q) r = int(r) s = int(s) t = int(t) for c in cs: m = decrypt(Enc(r,s,t),Pubkey(n = p*q,c = C),Privkey(p=p,q=q)) print(decrypt(Enc(r,s,t),Pubkey(n = p*q,c = C),Privkey(p=p,q=q))) print(long_to_bytes(int(m))) exit()# b'HackTM{h4v3_y0u_r34lly_f0und_4ll_7h3_bu65...?}\\x8d\\xc3\\xd5~vH\\x918\\xd1\\t\\x92 \\x13v\\xd9\\xee\\x8aS&gt;B\\xd3\\xdbl\\xe5\\x88\\xcfE\\xfc\\xa1\\x18o@=\\x8b\\xfdI\\x987]\\xdc1\\xa2\"|\\xc6\\x0fO\\xc6\\x9c\\xa8\\xf9\\xd3\\xa3\\x01\\xdb\\x04\\t(+\\xe9\\xd7(s\\xbb\\xaa\\xb7\\xe2\\xba\\xd9\\xf4\\xfd\\xde\\xef\\x0f\\x84\\x85.\\xc01\\x97\\x13rJ\\xa0\\xba\\xa7\\x93&amp;\\x10\\xb8\\xde\\x08\\x1a\\x1f\\xb3I\\x8e\\x82\\r\\xb2\\xda]\\x1b;p\\x16\\xc7&gt;\\x86\\xb3\\x81\\xd2\\xf8\\x04\\xff\\x15S\\xf2\\xbe\\xcd\\x98\\xaaW\\xfd\\xe8\\x88\\xd9h\\x11\\x99\\x1bo\\xcaB\\x95\\x95\\xccA\\xefmx\\x9c\\xcf\\xe3f\\xd2\\xd9\\xf9\\xe71\\xefZ-d\\x8e\\x84\\xbf,\\xd6\\x06S\\x0b\\xafiyWX\\x8f\\x91,\":\\xc5\\xae\\xea\\x8f\\xd1\\x0b\\x93\\x13\\x02\\xe7&gt;\\xb2\\x16\\xf0\\x80\\xe4\\xb5j\\n\\xd3S_C\\xd7C\\x8c#\\xde\\xd1W\\x8b\\xfet\\n\\xaf\\rf" }, { "title": "bi0sCTF writeup", "url": "/posts/bi0sCTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, writeup", "date": "2023-01-26 00:00:00 +0900", "snippet": "åˆã‚ã«ãã†ã„ãˆã°ä»Šå¹´å…¥ã£ã¦ã‹ã‚‰æ›¸ã„ã¦ç„¡ã‹ã£ãŸãªãã¨ã‹æ€ã£ãŸã®ã§ä»Šæ›´ã§ã™ãŒæ›¸ãã¾ã™ã€‚ã¨ã„ã£ã¦ã‚‚ãã‚“ãªæ›¸ãã“ã¨ãªã„ã‚“ã§ã™ãŒã­â€¦ã¦ã‹ã€HNPãŒ32 solveã£ã¦ã¿ã‚“ãªè³¢ã™ãã§ã—ã‚‡â€¦æ­£ç›´ãƒ¬ãƒ™ãƒ«ä¸ŠãŒã‚Šã™ãã¦æ€–ã„ã§ã™â€¦[crypto] leaky-dsa [32 solve]challfrom Crypto.Util.number import *from secret import flagfrom hashlib import sha256p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffa = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffcb = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bE = EllipticCurve(GF(p), [a,b])G = E.gens()[0]q = G.order()priv = Integer(bytes_to_long(flag))def sign(msg, d): k = int.from_bytes(sha256(int(d).to_bytes(d.nbits()//8 + 1, 'big') + sha256(msg).digest()).digest(), 'big') z = int.from_bytes(sha256(msg).digest(),'big') r = int((k * G)[0]) % q s = (inverse_mod(k, q) * (z + d * r)) % q leak_k = (k &gt;&gt; 120) &lt;&lt; 120 return z, r, s, leak_kfor i in range(2): msg = input(\"Enter message: \").encode() print(sign(msg, priv))solveãªã‚“ã‹ã€$k$ã®ä¸Šä½120bitãŒãƒªãƒ¼ã‚¯ã•ã‚Œã¦ã„ã‚‹ã®ã§å®Ÿè³ªã®$k$ã®ãƒ“ãƒƒãƒˆã‚µã‚¤ã‚ºã¯136bitç¨‹åº¦ã€HNPã®LLLã§ãªã‚“ã¨ã‹ãªã‚Šãã†from pwn import *from Crypto.Util.number import *from random import randintfrom sage.modules.free_module_integer import IntegerLatticep = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffa = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffcb = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bE = EllipticCurve(GF(p), [a,b])# 256bitq = E.order()ret = []N =1for _ in range(N): io = remote(\"crypto.chall.bi0s.in\" ,10000) io.sendlineafter(b\": \",str(randint(0,100)).encode()) ret.append(eval(io.recvline(None).decode())) io.sendlineafter(b\": \",str(randint(0,100)).encode()) ret.append(eval(io.recvline(None).decode())) io.close()Z = [ret[i][0] for i in range(len(ret))]R = [ret[i][1] for i in range(len(ret))]S = [ret[i][2] for i in range(len(ret))]T = [ret[i][3] for i in range(len(ret))]N = len(Z)mat = matrix(QQ,N+2,N+2)for i in range(N): mat[i,i] = -q mat[-2,i] = (pow(S[i],-1,q) * (Z[i] - T[i]*S[i]))%q mat[-1,i] = (pow(S[i],-1,q) * R[i])%qmat[-2,-2] = 2^136mat[-1,-1] = 2^136/qfor row in mat.LLL(): if abs(row[-2]) == 2^136: d = abs(row[-1]) * q/2^136 print(long_to_bytes(int(d))) exit() # 3CC_S1gn1nG_1s_SECCY_6675636b# bi0sctf{3CC_S1gn1nG_1s_SECCY_6675636b}[crypto] bad2code [24 solve]challfrom Crypto.Util.number import *from secrets import FLAGassert len(FLAG) == 44FLAG_FORMAT = \"bi0s\"NBITS = len(FLAG)&lt;&lt;2a = 0xBAD2C0DEc = 0x6969m = 1&lt;&lt;NBITSseed = getRandomNBitInteger(NBITS)state = seedciphertext = []for i,f in enumerate(FLAG): state = (state*a+c)%m ciphertext.append((state&gt;&gt;(NBITS&gt;&gt;1))^^i^^ord(f))public = [1]for i in range(2, 91): public.append(public[-1]*i)q = sum(public)while True: r = getRandomInteger(100) if GCD(r, q) == 1: breakB = [r*i % q for i in public]def encrypt(ct): blen = ct.bit_length() ct = bin(ct)[2:] ct = [int(i) for i in ct] ct = [ct[i]*B[i] for i in range(len(ct))] return blen, sum(ct)ct = []for i in ciphertext: ct.append(encrypt(i))with open(\"ct.txt\", \"w\") as f: f.write(str(ct))print(r)# r = 439336960671443073145803863477solveãƒ•ã‚¡ã‚¤ãƒ«ã®å¤‰æ›´ã§$r$ã®å€¤ãŒåˆ†ã‹ã‚‹ã‚ˆã†ã«ãªã£ã¦ãŸã¿ãŸã„â€¦??(æœªç¢ºèª)ã¾ãã€æ°—ã‚’å–ã‚Šç›´ã—ã¦å•é¡Œã¯ã€truncated LCG â†’ xor â†’ bitã«ã—ã¦ç©ã®è¨ˆç®—ã‚’è¡Œã£ã¦ã„ã‚‹æ„Ÿã˜ãªã®ã§ã€é †ã«å¾Œã‚ã‹ã‚‰ã‚„ã£ã¦ã„ã bitã«ã—ã¦ç©ã®è¨ˆç®—ã¯$B$ãŒã‚ã‹ã‚‹ã®ã§LLLã§subset sum problemã§è§£æ±º truncated LCGã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å¾©å…ƒHITCON CTF 2022 writeup ã§æ›¸ã„ã¦ã‚ã‚‹æ„Ÿã˜ã§$ciphertext$ã®å¾©å…ƒã‚’è¡Œã†ã€‚truncated LCGã¯kurenaifã•ã‚“ãŒè©³ã—ãè§£èª¬ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã™ã‚Œã°okkurenaif@2/12ã¾ã§æ´»å‹•ãŠä¼‘ã¿ä¸­ on Twitter: â€œã€17å…†é€šã‚Šã€‘4bitã®å€¤20å€‹ã‹ã‚‰Javaã®ä¹±æ•°äºˆæ¸¬ã‚’ã™ã‚‹ã€kurenaifã€‘ https://t.co/JLONaT2ydz @YouTubeã‚ˆã‚Š æ ¼å­åŸºåº•ç°¡ç´„ã¨ã„ã†ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’ä½¿ã£ã¦ã€4bitã®å€¤ã‹ã‚‰ä¹±æ•°äºˆæ¸¬ã‚’ã™ã‚‹å‹•ç”»ã§ã™ï¼Javaã‚„æ ¼å­åŸºåº•ç°¡ç´„ã‚’çŸ¥ã‚‰ãªãã¦ã‚‚æ¥½ã—ã‚ã‚‹ã‚ˆã†ã«å‹•ç”»ã‚’ä½œã£ãŸã®ã§ã€ã‚ˆã‹ã£ãŸã‚‰ã¿ã¦ã¿ã¦ãã ã•ã„ï¼ https://t.co/PrDitaanHUâ€ / Twitterã‚ã¨ã¯å¹³æ–‡ç¯„å›²ã‚’1æ–‡å­—ã¥ã¤æ¢ç´¢ã—ã¦GG!!from Crypto.Util.number import *from tqdm import tqdm# assert len(FLAG) == 44FLAG_FORMAT = \"bi0s\"# NBITS = len(FLAG)&lt;&lt;2# 11 bitsNBITS = 44 &lt;&lt;2A = 0xBAD2C0DEC = 0x6969m = 1&lt;&lt;NBITScts = [(85, 2009755672435753240933297922620729942110285100089234834611189610638944428122270966606450209287004686147490741726074233399923807772025455384), (87, 4996607263053501712119670315411210635641476911112656716346186101581162098939506206462698692878856867719374177604968008598982986859155008123), (87, 4837953870616520482139098354277306810171956043791834010204071803405678054968703256907153189059041329376000508442178425613919361101370091597), (87, 2933251583165904105425041103443198171501175581919361545836839336222902826332690613281372817019459906816365925875888304559050438360535693754), (87, 3687643521316276110350069295074808763624177150637370283489602776297956670406673088896906135313859622547057266461156951352840606158133939326), (85, 1338269001646504891852362627714857562957599731250242281507737655117481275381522940187354460968741738873145343823622277547003496172474140929), (88, 7933296831307546148859657742504382496951023270916400508699917815337497611045057441275885597739792345698682705664067022591023419704320903682), (88, 5551940689407978486506000896917506389553250109195458521661213619690861850998613004330276887098156130761269810440548744569924180624922795113), (84, 4231118499738387243085586897653540321361890016337481573279774741827125072054069869204040621495890626440611926639348835434382399384680055422), (85, 4704615409370307656606356674605132679559694819773906599372238093928995241862651680281288235856744305731307534075261385839804274777809615349), (88, 8080256207998531514821351856269697662773084407605094205301308544428843939544685672982309353297946702140050231399104513874885470725033197665), (88, 5409126049900711181553897969759692389994841569000620092514718715454021797905578507700126871105210241868943216288008246115824215988452628610), (87, 9252119153621946581189075112355267174890952393437560488066048810424246555795717704306898381332924931192879341998003358581626937969846419514), (88, 4309485343027874993328683769447337855319861832898927390313412221773647599911173732334028315977555272520439642698050646195173212678056296824), (87, 7585821393024154059281324167310518147335428246416250953866063679865301977430635054486170591035445789330984486529581273451159109931487791502), (87, 4266559781861060657731014334455291598689251074723949797856286897802219958857948301662899795696748957745131495362941575798432727634477829169), (85, 2641970821454174926450206596995181582610648509828849026215891906920020076919398240347027542452996819530972432115175678566086129470049375389), (86, 3077438307667140950446795937461054813957511252383671895612002141778156796698300700433893422617209993376314581927862590976739430303756825799), (84, 6606999799754153651147831000154190219518207430742825676139927743071667153908159445512098245423654757585044526053832363134210629951000894424), (88, 5670578370066772514741437284311647297873639929831922637574590430528630079731096253156055423807240883352926044290617794045498770071653673648), (87, 6894132144232319468740512750496837680809983881874187255032194645685827169634783788480774942267705885439820208999500465383743432841886297780), (88, 6348559834296411797469331328911826454137045759724408730535584371919321718963812479226912064993936288733920150791627489465935504738729746712), (87, 7457067309408071136462520290099813600595760616382451252266638576757556195357758384430233685566475045370258747830063483558129016033041534121), (87, 7138834056650788599340304091245357448689914704543367476875970477848587821892811763578094466693024724929034161719556439516286550418480386826), (85, 4214620981374285095640824086913124961419729602098347661701803957979165936606167686524401563099707189265200486482516005732059773306234258420), (87, 7739066385937951930229094506964291860284170243142110190122036300802992602806430896564185899709833543891933679072444463084661529668059219104), (86, 7996763147644153267931052506581385268378745125996592054161290689392831593366496210631236238142447646254463386914159791951904746842709666621), (83, 2363927368088545362888027832425184786062409622322321649991521010872009124933023792724085312213031828468440431258319304817389205319949123017), (86, 8952178949693065428977346330331508030115172989418887909205463101008773555390353195154597245789628940426095401145185560848927781578325104633), (87, 5437733249052136209105079687557091961563919494484950700755430118355692330802405578709308644911805929080699188377572804834481019970451287210), (88, 6015299972513982077146707497576267202666793107003902152334693697774096888512046451228148219477544391600946101222260160929679756603685952858), (88, 4568852671731251436040898868989551602956632306950375030804513367391992286782270552341135397170272362552944089560054885656717064705695931608), (88, 5214418374014497232007521802148945843762329611158152570151078790657020448385624421117820553224634987052518291618670107521494031262847423514), (85, 4868781049816097655711690233312446779184038900364456479177916582789767967134191139603006712483609665048365174590374678749717762853252392898), (87, 7487878378499555558388350908281092245535427011554302229088273963701472371659945154073798520163320208196872977374676841353329741664704431049), (88, 4804650300297155317595282760599161747288241275410480931480258003053935686370721999717184367371623277273540661128542000775004283694728585525), (87, 6324353155591926121419512579497192374524354396151314193997508188259969434627055717937503525281909856550845807173753553651932260148517039625), (87, 5546469224661430242652418747991106002905180051710879985326544434722895447041925331360634907813012794515907098935485171653197695779005009826), (86, 6493922061250196900387871627336695511599800586007321943800903718034500613505566204881495072235610494479661303981584755703237874004730700241), (84, 3304267236247240014753455621608696126482869339445549240138779235284450054938719633292333925332195771054789798560540593262065547955691287860), (86, 7470707627092056238764393981318045721888042683539521453158125764519328859948265999477619788387120366063077899885955739104933799243393828710), (88, 6674831873895816998217860257081780104168741154329195649911902365299495130324698497916172758145782383658122037059537201009889153133307754158), (88, 5323014117483698150842190422231005724805137799598831691161862346623039247622359972881775361362745899238680458901399065283489317592046388919), (85, 3763698408921732607951773848228884704668238062686979349129116312470621538052054791662510364394420612090312977770614743449723324784458538150)]r = 439336960671443073145803863477public = [1]for i in range(2, 91): public.append(public[-1]*i)q = sum(public)B = [r*i % q for i in public]def encrypt(ct): blen = int(ct).bit_length() ct = bin(ct)[2:] ct = [int(i) for i in ct] ct = [ct[i]*B[i] for i in range(len(ct))] return blen, sum(ct)def recover_ciphertext(c): N = len(B) M = matrix(QQ, N+1,N+2 ) for i in range(N): M[i,i+1] = 1/65537 M[i,0] = -B[i] M[-1,0] = c M[-1,-1] = 2*q for row in M.LLL(): if abs(row[-1]) == 2*q: return list(row*65537)[:-1]state = []for i in range(4): ciphertext = [str(k) for k in recover_ciphertext(cts[i][1])] l = cts[i][0] c = int(\"\".join(ciphertext[:l+1]),2) state.append(int(c)^^int(i)^^int(ord(FLAG_FORMAT[i])))from attacks.lcg.truncated_state_recovery import attackret = attack(state,int(m).bit_length(), int(m).bit_length() - (NBITS &gt;&gt;1),m,A,C)pt = \"b\"assert (ret[2]*A+C)%m ==ret[3]assert (ret[0]*A+C)%m ==ret[1]s = ret[0]for i in range(1,44): for f in range(0,0xff): _s = (s*A+C)%m c = int(_s&gt;&gt;(NBITS&gt;&gt;1))^^int(i)^^int(f) ec = encrypt(c) if ec[1] == cts[i][1]: pt +=chr(f) s = _s break else: print(\"not found\") breakprint(pt)# bi0sctf{lcg_is_good_until_you_break_them_!!}" }, { "title": "2022å¹´ã®æŒ¯ã‚Šè¿”ã‚Š", "url": "/posts/2022/", "categories": "ctf", "tags": "ctf", "date": "2023-01-05 00:00:00 +0900", "snippet": "åˆã‚ã«2022å¹´ã‚‚çµ‚ã‚ã‚Š2023å¹´ãŒã‚„ã£ã¦ãã¾ã—ãŸã€‚å€‹äººçš„ã«ã¯2022å¹´å¾ŒåŠã‹ã‚‰2023å¹´ã®å‰åŠãŒã“ã“æœ€è¿‘ã®ä¸€ç•ªã®ç’°å¢ƒã®å¤‰åŒ–ã«ãªã‚‹æ°—ãŒã—ã¦ãšã£ã¨ãã‚ãã‚ã—ã¦ã¾ã™ã€‚æœ¬é¡Œã¨ãªã‚‹ã®ã¯2022å¹´ã®æŒ¯ã‚Šè¿”ã‚Š+2023å¹´ã®ç›®æ¨™ã§ã™ã‹ã­â€¦2022å¹´ã®æŒ¯ã‚Šè¿”ã‚Šå‰åŠã¯ç‰¹ã«ä½•ã‚‚ãªãã€å”¯ã€…å¤§å­¦ã®ç ”ç©¶ã‚„å­¦ä¼šã«å‚åŠ ã—ãŸã‚Šã‚’ã—ã¦ã‚‹å‚ã‚‰ã«CTFã«é©å½“ã«å‚åŠ ã™ã‚‹çš„ãª?æ„Ÿã˜ã§ã—ãŸã€‚ã—ã‹ã‚‚ä½•ã‚‚æƒ…å ±ã‚‚ãªãCTFTimeã¿ã¦å‚åŠ ã—ã¦discordã®è­°è«–ã‚’å‚ã‚‰ã‹ã‚‰è¦‹ã¦ã‚‹ã ã‘ãªã®ã§ã€ç‰¹ã«æ›¸ãã“ã¨ã‚‚ãªã„ã‚“ã§ã™ã‚ˆã­ã‡â€¦å¾ŒåŠã€ã¨ã„ã†ã‹SECCON CTF beginners in æœ­å¹Œã«å‚åŠ ã—ã¦ã‹ã‚‰ã®ç’°å¢ƒãŒå¤‰ã‚ã‚Šã™ãã§ã™ã­ã‡ã€‚å‚åŠ ã—ãŸå¾Œã«Twitterã§ã„ã‚ã‚“ãªäººã‚’ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦ã„ãã†ã¡ã«ãƒ•ã‚©ãƒ­ãƒã‚‚ã‚‰ãˆãŸã®ã§ã€ã“ã“ã§æœ€åˆã®æ‰¿èªæ¬²æ±‚ã®çˆ†ä¸ŠãŒã‚Š+ãƒ¢ãƒãƒ™ã®çˆ†ä¸ŠãŒã‚Šã¯å¤©äº•çŸ¥ã‚‰ãšã€‚ã€‚ã€‚ã•ã‚‰ã«ã€é©å½“ã«Twitterã§Sekai CTFã«ãƒãƒ¼ãƒ ã§å‡ºãŸã„ãªãçš„ãªã“ã¨ã‚’ã¤ã¶ã‚„ã„ã¦ã‚‹ã¨Satoooonã•ã‚“ã«æ‹¾ã£ã¦ã‚‚ã‚‰ãˆã¦2äººã§å‡ºãŸã‚Šã¨ã€ã“ã“ãŒå¤§ããªç’°å¢ƒã®å¤‰åŒ–ã§ã—ãŸã­ã€‚ã€‚ã€‚ãƒãƒ¼ãƒ ã§å‡ºã‚‹å–œã³ã‚’è¦šãˆãŸåƒ•ã¯SECCON CTF 2022 QUALSã«ãƒãƒ¼ãƒ ã§å‡ºã‚‹ã“ã¨ã«ãªã£ã¦misoã•ã‚“ã¨Iwancofã•ã‚“ã‚’è¿½åŠ ã™ã‚‹å½¢ã®4äººã§ã§ã¦æ±ºå‹ã¸ã¨é€²ã‚€ã“ã¨ãŒã§ãã¾ã—ãŸ(å€‹äººçš„ã«ã¯cryptoãŒè§£ã‘ãªãã¦çµæ§‹æ‚”ã—ã„â€¦orz)ã¨ã¾ãã€å‰åŠã«ã¯æƒ³åƒã‚‚ã—ã¦ã„ãªã‹ã£ãŸæ„Ÿã˜ã«ãªã‚Šã¾ã—ãŸã­ã€‚ã€‚ã€‚2023å¹´ã®äºˆå®š(?)ã¨ç›®æ¨™ä»Šåƒ•ãŒä¿®å£«2å¹´ã¨ã„ã†ã“ã¨ã‚‚ã‚ã‚Šã€2023å¹´ã¯ç¤¾ä¼šäººä¸€å¹´ç›®ã®å¹´ã«ãªã‚Šã¾ã™ã€‚ã¨ã„ã†ã“ã¨ã§2022å¹´ã¨ã¯ã¾ãŸé•ã£ãŸå½¢ã§ã®ç’°å¢ƒã®å¤‰åŒ–ãŒæ¥ã‚‹ã®ãŒç¢ºå®šã—ã¦ã„ã‚‹ã‚“ã§ã™ã‚ˆã­ã€‚ã€‚ã€‚ã§ã‚‚ã€ä¼šç¤¾ã§ã‚„ã‚‹æ¥­å‹™ã¯securityé–¢ä¿‚ãªã®ã§æ¯”è¼ƒçš„ã¾ã—ã‹ãªãã¨è€ƒãˆã¦ã„ã¾ã™ã€‚(å¤šåˆ†researcher??ã‚ã‹ã‚“ãªã„)ã•ã¦ã€ç›®æ¨™ã§ã™ãŒ æ­»ãªãªã„ rustã‚„ã‚ŒãŸã‚‰ã„ã„ãªã ZKPã‚’ã‚„ã‚‹(å¤šåˆ†zk-SNARKsã‹ãª) revã‚’åˆå¿ƒè€…ãƒ¬ãƒ™ãƒ«ã¯è¶Šãˆã¦ãŠããŸã„ã–ã£ã¨ã€ã“ã‚“ãªã‚‚ã‚“ã§ã™ã‹ã­ã€‚æ­»ãªãªã„ã¯ãªãœã‹ä¼šã†äººä¼šã†äººã«ã€ŒãŠå‰æ­»ã¬ãªã‚ˆã€ã¨ã„ã‚ã‚Œã‚‹ã®ã§ç›®æ¨™ã«å…¥ã‚Œã¦ã¾ã™ã€‚(ç­‹ãƒˆãƒ¬ã‚„ã‚ã†â€¦)ZKPã¯ä»Šãƒ›ãƒƒãƒˆãªåˆ†é‡(Asia cryptoã§ZKPã«é–¢ã™ã‚‹ã‚‚ã®ãŒã»ã¼ã»ã¼ã ã£ãŸã‚Š)ã§ç†è«–ã¯çŸ¥ã£ã¦ãŠããŸã„ãªã¨ã„ã†æ„Ÿã˜ã§ã™ã€‚ã‚ã¨ã¯ã€è‡ªåˆ†ãŒèˆˆå‘³æŒã£ã¦ã„ã‚‹éƒ¨åˆ†ãªã®ã§ã‚†ã‚‹ã‚†ã‚‹ã¨ã‚„ã£ã¦ã„ããŸã„æ‰€å­˜ã§ã™ã€‚ç· ã‚ä»Šã¯ã‚¶ãƒƒã‚¯ãƒªã“ã‚“ãªæ„Ÿã˜ã§ã‚„ã£ã¦ã„ã“ã†ã‹ãªãã¨æ€ã£ã¦ã„ã¾ã™ã€‚é€”ä¸­ã§è„‡é“ãã‚Œãã†ãªäºˆæ„Ÿã‚‚â€¦??ã¨ã‚Šã‚ãˆãšã€ä»Šå¹´ä¸€å¹´ã‚‚ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™ã€‚" }, { "title": "CTF advent calendar 2022", "url": "/posts/adventcalender2022/", "categories": "advent_calendar", "tags": "advent_calendar", "date": "2022-12-11 00:00:00 +0900", "snippet": "åˆã‚ã«CTF Advent Calendar 2022ã®15æ—¥ç›®ã¨ã„ã†ã“ã¨ã§è‰²ã€…æ›¸ãã¾ã™ã€‚å‰å›ã¯hamayanã•ã‚“ã®CTFã«ãŠã‘ã‚‹ã‚¹ãƒ†ã‚¬ãƒã‚°ãƒ©ãƒ•ã‚£å…¥é–€ã¨ã¾ã¨ã‚ - ã¯ã¾ã‚„ã‚“ã¯ã¾ã‚„ã‚“ã¯ã¾ã‚„ã‚“ã§ã—ãŸã€‚webã‚ã‹ã‚‰ãªã•ã™ãã‚‹ã®ã§ã€ã„ã¤ã‚‚webã®writeupå‚è€ƒã«ã•ã›ã¦ã‚‚ã‚‰ã£ã¦ã¾ã™ã€‚ã‚ã‚ŠãŒãŸã‚„ãƒ¼ï½â€¦ã¯ã˜ã‚ã¾ã—ã¦ã®æ–¹ã¯åˆã‚ã¾ã—ã¦ã€ãã†ã§ãªã„æ–¹ã‚‚åˆã‚ã¾ã—ã¦ã€kanonã§ã™ã€‚å»å¹´ã®11æœˆ(?)ã‹ã‚‰æœ¬æ ¼çš„ã«CTFã«å‚åŠ å§‹ã‚ãŸæ–°äººãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã™ã€‚(ãã†è€ƒãˆã‚‹ã¨1å¹´ã¨å°‘ã—ã—ã‹ã‚„ã£ã¦ãªã„..??)ã¾ããã‚Œã¯ã•ã¦ãŠãã€ã“ã®è¨˜äº‹ã¯æ–°ã—ãCTFã‚’å§‹ã‚ã‚‹äººã«å‘ã‘ã¦ã®è¨˜äº‹ã«ã—ã‚ˆã†ã‹ãªã¨æ€ã£ã¦ã„ã¾ã™ã€‚ç†ç”±ã¨ã—ã¦ã€åƒ•è‡ªèº«ãŒCTFã®ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã«å‚åŠ ã—ãŸ(?)ã®ãŒ2ã‹æœˆå‰ãªã®ã¨ãã‚Œã¾ã§ã®ç´„ä¸€å¹´é–“ã¯å€‹äººã§ã—ã‹ã‚‚twitterã¨ã‹ã‚‚ã‚„ã‚‰ãšã«CTFtimeã ã‘è¦‹ã¦CTFã«å‚åŠ ã—çµŒé¨“ç©ã‚“ã§ã¾ã—ãŸã€‚æ™‚é–“ã ã‘è¦‹ã‚‹ã¨çµæ§‹ç„¡é§„ãªã“ã¨ã‚„é€†ã«è‰¯ã‹ã£ãŸã“ã¨ã‚‚ã‚ã‚‹ã®ã§ä»Šã‹ã‚‰CTFã‚„ã£ã¦ã¿ã‚ˆã†ã‹ãª!!ã§ã‚‚ã©ã†ã—ãŸã‚‰ã„ã„ã‚“ã ã‚â€¦orzã£ã¦äººå‘ã‘ã«ç´¹ä»‹ã—ã¦ã„ã“ã†ã‹ãªã¨æ€ã£ã¦ã„ã¾ã™ã€‚ãŸã ã€è©±ã™ã‚‚ã®ã¯å€‹äººã®çµŒé¨“ã«åŸºã¥ã„ã¦ã„ã¾ã™ã®ã§ã€é–“é•ã£ã¦ãŸã‚‰ã™ã¿ã¾ã›ã‚“â€¦CTFç”¨ã®Twitterã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œã‚ã†ã¨ã‚Šã‚ãˆãšã€CTFã‚„ã£ã¦ã„ã‚‹äººã‚’ãƒãƒã£ã¨ãƒ•ã‚©ãƒ­ãƒ¼ã—ã¦ãŠãã¾ã™ã€‚ãã†ã™ã‚‹ã“ã¨ã§ã€è‰²ã€…ãªæƒ…å ±(CTFã®é–‹å‚¬æƒ…å ±ãƒ»writeupãƒ»è‰¯å•ç­‰ã€…)ãŒæ‰‹ã«å…¥ã‚Šã¾ã™ã€‚ã“ã‚Œã£ã¦ã€å‡„ãé‡è¦ãªæƒ…å ±ã§è‡ªåˆ†ã®ã‚¹ã‚­ãƒ«ã‚¢ãƒƒãƒ—ã«ã‚‚ã¤ãªãŒã‚Šã¾ã™ã—ã€ã¿ã‚“ãªã‚ã£ã¡ã‚ƒã‚¹ãƒ—ãƒ©ã‚„ã£ã¦ã‚‹ã‚„ã‚“ã£ã¦ãªã‚Šã¾ã™ã€‚ãã‚Œã¯ã•ã¦ãŠãã€ãƒãƒ¼ãƒ ã®ãŠèª˜ã„ã‚„é€†ã«ä»Šåº¦ä¸€ç·’ã«ã‚„ã‚Šã¾ã›ã‚“ã‹ã¨ã„ã£ãŸãƒãƒ¼ãƒ ãªè©±ã‚‚ã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚æ¨ªã®ã¤ãªãŒã‚Šã¯ã‚ã¡ã‚ƒå¤§äº‹ã€‚CTFã«å‚åŠ ã™ã‚‹ã«ã¯â€¦?åŸºæœ¬çš„ã«å¤§ä½“ã®CTFã«ã¯å‚åŠ ã§ãã¾ã™ã€‚ãŸã ã€æ±ºå‹æˆ¦ã‚„ç‰¹å®šåœ°åŸŸã®ã¿ã¨ã„ã£ãŸã‚‚ã®ã«ã¯å‚åŠ ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚(ãã‚Šã‚ƒãã†ã§ã™ã‚ˆã­ã€Wæ¯ã®æ±ºå‹ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆã«éƒ¨å¤–è€…ãŒå‚åŠ ã§ããªã„ã®ã¨åŒã˜ã§)åŸºæœ¬çš„ã«ã¯CTFtimeã§çºã¾ã£ã¦ç¢ºèªã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€ãŸã¾ã«ãƒ­ãƒ¼ã‚«ãƒ«ãªCTF(taskã•ã‚“ã®taskctfã‚„tsukuCTF)ã‚„ä¼æ¥­ã•ã‚“ãŒé–‹ã„ã¦ãã ã•ã‚‹ã‚‚ã®ã‚‚ã‚ã‚Šã¾ã™ã€‚ãã‚Œã‚‰ã¯åŸºæœ¬çš„ã«Twitterã§æƒ…å ±ãŒæµã‚Œã¦ãã‚‹ã®ã§ã€å‚åŠ ã—ãŸã„ã®ã§ã‚ã‚Œã°Twitterã«ã‚¢ãƒ³ãƒ†ãƒŠå¼µã‚‹æ–¹ãŒã„ã„ã‹ãªããªã‚“ã¦æ€ã£ã¦ã„ã¾ã™ã€‚(ãªã‚“ãªã‚‰åƒ•è‡ªèº«10æœˆã¾ã§ãã†ã„ã†ã‚‚ã®ã®å­˜åœ¨ã‚’çŸ¥ã‚‰ãªã‹ã£ãŸâ€¦)ã“ã‚“ãªæ„Ÿã˜ã§è‰²ã€…ãªCTFãŒã‚ã‚Šã€æœ€åˆã®å†…ã¯CTFtimeã®èª¬æ˜ã«ã‚ã‚‹é›£æ˜“åº¦ã«ãƒ“ã‚®ãƒŠãƒ¼ã‚‚å¤§ä¸ˆå¤«ã£ã¦æ›¸ã‹ã‚Œã¦ã„ã‚‹ã‚‚ã®ã‹ãƒ­ãƒ¼ã‚«ãƒ«ã§é–‹ã‹ã‚Œã‚‹(åˆå¿ƒè€…ã§ã‚‚æ¥½ã—ã‚ã‚‹ã‚‚ã®ãŒå¤šã„ã‚¤ãƒ¡ãƒ¼ã‚¸)ã‚‚ã®ã‚’é¸ã‚“ã æ–¹ãŒã„ã„ã§ã™ã€‚(å¤§ä¸ˆå¤«ãªäººã¯å•é¡Œãªã„ã§ã™ãŒã€é›£ã—ã„ã®ã ã¨æ™®é€šã«å¿ƒæŠ˜ã‚Œã¾ã™ã€‚ã€‚ã€‚)CTFã«å‚åŠ ã—ã¦ã¿ã‚‹..!!ãƒãƒ¼ãƒ ã£ã¦ã©ã†ãªã®??ã˜ã‚ƒã‚ã€å‚åŠ ã—ã‚ˆã†!!â€¦ ã‚ã‚Œã€ãƒãƒ¼ãƒ çµ„ã‚“ã§å‚åŠ ã™ã‚‹ã®??å‚åŠ ã™ã‚‹ã«ã‚ã£ãŸã£ã¦ãƒãƒ¼ãƒ æˆ¦ã§è¡Œã†CTFã‹ã€ã¯ãŸã¾ãŸå€‹äººæˆ¦ã§è¡Œã†CTFã®2ã¤ã‚ã‚Šã¾ã™ã€‚ãƒãƒ¼ãƒ çµ„ã‚€äººãŒã„ã‚Œã°ãã‚Œã«è¶Šã—ãŸã“ã¨ã¯ãªã„ã§ã™ãŒã€çµ„ã‚ãªã„å ´åˆã¯ä¸€äººã§å‚åŠ ã—ã¦ã‚‚å…¨ç„¶å•é¡Œãªã„ã§ã™ã€‚æœ€åˆã¯é †ä½ã‚ˆã‚Šã‚‚CTFã«æ…£ã‚Œã‚ˆã†ãŒãƒ¡ã‚¤ãƒ³ã«ãªã‚‹ã®ã§â€¦!!!(ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã¨ã‹discordã®ä½¿ã„æ–¹ç­‰ã€…)å•é¡Œã«ã‚¸ãƒ£ãƒ³ãƒ«ãŒã‚ã‚‹CTFã¯åŸºæœ¬çš„ã«ã‚¸ãƒ£ãƒ³ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚(ã¾ã‚Œã«ç‰¹å®šã‚¸ãƒ£ãƒ³ãƒ«ã®ã¿ã‚„ã‚¸ãƒ£ãƒ³ãƒ«ãŒè¤‡åˆã—ã¦ã„ã‚‹å ´åˆã‚‚â€¦)ä»¥ä¸‹ã«ç°¡å˜ã«æ›¸ã„ã¦ã¿ã¾ã™ã€‚ crypto æ˜”ã®ã‚‚ã®ã‹ã‚‰ç¾åœ¨ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¾ã§æš—å·ã‚’è§£èª­ã—ã‚ˆã†ãœ web Webã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è§£æã—ã‚ˆã†ãœ reversing å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£æã—ã‚ˆã†ãœ pwn ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚„ã°ã„æ‰€ã‚’æ¢ã—ã¦çªã“ã†ãœ forensics ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æƒ…å ±ã‚’æŠœãå‡ºã—ã¦ã¿ã‚ˆã†ãœ misc ãã®ä»–è«¸ã€…ãªã‚“ã ãœ ã¨ã‚Šã‚ãˆãšã€æŒ™ã’ã¦ã¿ã¾ã—ãŸãŒã¶ã£ã¡ã‚ƒã‘å€‹äººã®æ€§æ ¼ã¨çŸ¥è­˜ã¨èˆˆå‘³ã§ã©ã®åˆ†é‡ãŒå¾—æ„ãªã®ã‹ã¯ç•°ãªã‚Šã¾ã™ã®ã§ã€ä¸€åº¦ã™ã¹ã¦ã®åˆ†é‡ã‚’è§¦ã£ã¦è¡Œã‘ãã†ã¨æ€ã†åˆ†é‡ã‚’ä¸­å¿ƒã«å§‹ã‚ã‚‹ã¨ã„ã„ã§ã™ã€‚(åƒ•ã¯å¤§å­¦é™¢ã®ç ”ç©¶æŸ„cryptoã‚„ã£ã¦ã¾ã™)å…ˆã®è©±ã«ã¯ãªã‚Šã¾ã™ãŒã€ãã®åˆ†é‡ãŒã‚ã‚‹ç¨‹åº¦è§£ã‘ã‚‹ã‚ˆã†ã«ãªã‚‹ã¨ä»–ã®åˆ†é‡ã§ä½¿ãˆã‚‹çŸ¥è­˜ã‚‚æ„å¤–ã¨ã‚ã£ãŸã‚Šã—ã¾ã™ã€‚ãªã®ã§ã€ã¾ãšã¯å¾—æ„ãªåˆ†é‡ã‚’ã‚ã‚‹ç¨‹åº¦ä½œã£ã¦ã‹ã‚‰ã»ã‹ã®åˆ†é‡ã‚‚æŒ‘æˆ¦ã™ã‚‹ã¨ã„ã„ã®ã‹ãªãã¨æ€ã£ã¦ã„ã¾ã™ã€‚å‚åŠ ã—ãŸã‘ã©è§£ã‘ãªã£ãŸâ€¦orzå®‰å¿ƒã—ã¦ãã ã•ã„!!è§£ã‘ãªãã¦ã‚‚è§£ã‘ãŸäººãŸã¡ãŒwriteupã¨ã—ã¦è§£ãæ–¹ã‚’å…¬é–‹ã—ã¦ãã‚Œã¦ã„ã‚‹å ´åˆã‚„CTFã®é‹å–¶è€…ãŸã¡ãŒæƒ³å®šè§£ã‚’å…¬é–‹ã—ã¦ãã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã‚’è¦‹ã¦ä»Šã¾ã§è‡ªåˆ†ãŒçŸ¥ã‚‰ãªã£ãŸæ‰‹æ³•ãƒ»çŸ¥è­˜ãƒ»æŠ€è¡“ã‚’å¸åã—ã¦è‡ªåˆ†ã®ã‚‚ã®ã«ã™ã‚‹ã®ã‚‚å¤§ããªå­¦ã³ã«ãªã‚Šã¾ã™ã€‚ã˜ã‚ƒã‚ã©ã“ã«ä¸ŠãŒã£ã¦ã„ã‚‹ã®ã‹ã¨ã„ã†ã¨ã€discordã«ä¸ŠãŒã‚‹ã“ã¨ãŒå¤§åŠã§ã™ãŒã€googleã§ã€Œã€‡ã€‡CTF writeupã€ã¨ã‹ã§æ¤œç´¢ã™ã‚‹ã¨è¦‹ã¤ã‹ã‚‹ã¨ãã‚‚ã‚ã‚Šã¾ã™ã€‚ãŸã ã€æ™‚ã¨å ´åˆã«ã‚ˆã£ã¦ã¯writeupãŒç¦æ­¢(æœŸé–“ç¦æ­¢ã¯ãŸã¾ã«ã‚ã‚‹)ã‚„writeupãŒä¸ŠãŒã£ã¦ãªã‹ã£ãŸã‚Šã™ã‚‹å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚ãã®å ´åˆã¯ã€ã‚ãã‚‰ã‚ã¾ã—ã‚‡ã†â€¦(discordã§èã„ã¦ã‚‚ã„ã„ã¨ã¯æ€ã„ã¾ã™ãŒã€ç›¸æ‰‹æ–¹ã‚‚å–„æ„ã§ã‚„ã£ã¦ãã‚Œã¦ã„ã‚‹ã®ã§è¿”ä¿¡ãŒè¿”ã£ã¦ãã‚‹ã‹ã¯æœªçŸ¥æ•°â€¦)ãã—ã¦ã€æ™‚é–“ãŒã‚ã‚Œã°upsolve(è§£ããªãŠã—)ã™ã‚‹ã®ã‚‚ã„ã„ã¨æ€ã„ã¾ã™ã€‚(æ€è€ƒã®ãƒˆãƒ¬ãƒ¼ã‚¹ã£ã¦ã‚ã¡ã‚ƒå¤§äº‹)è§£ã‘ãŸ!!ãªã‚‰writeupæ›¸ãã¾ã—ã‚‡ã†!!ãã‚Œã‚’ä¸–ç•Œã«å…¬é–‹ã™ã‚‹ã‹ã©ã†ã‹ã¯ç½®ã„ã¦ãŠãã¨ã—ã¦ã€è‡ªåˆ†ã®æ€è€ƒãŒwriteupæ›¸ãã“ã¨ã§çºã¾ã‚Šã¾ã™ã—ã€æ–‡ç« ã§æ€è€ƒã‚’èª¬æ˜ã™ã‚‹ã„ã„æ©Ÿä¼šã«ã‚‚ãªã‚Šã¾ã™ã€‚(åƒ•ã¿ãŸã„ã«ä¸‹æ‰‹ã«ã¯ãªã‚‰ãªã„ã§ã­ã€‚ç´„æŸã ã‚ˆ)çµå±€ãƒãƒ¼ãƒ ã¯çµ„ã‚€ã¹ãâ€¦??1äººã§å‚åŠ ã™ã‚‹ãƒ¡ãƒªãƒƒãƒˆãƒ»ãƒ‡ãƒ¡ãƒªãƒƒãƒˆãƒ¡ãƒªãƒƒãƒˆã¯ã‚ã£ã¡ã‚ƒæ°—æ¥½ã€‚ãƒ‡ãƒ¡ãƒªãƒƒãƒˆã¯1äººã§ã™ã¹ã¦è¡Œã†ã®ã§è² æ‹…ãŒåŠç«¯ãªã„ã—ã€å¯‚ã—ã„ã€‚ãƒãƒ¼ãƒ ã§å‚åŠ ã™ã‚‹ãƒ¡ãƒªãƒƒãƒˆãƒ»ãƒ‡ãƒ¡ãƒªãƒƒãƒˆãƒ¡ãƒªãƒƒãƒˆã¯å˜ç´”ã§ã€äººæ•°ãŒå¢—ãˆã¦è² æ‹…ãŒæ¸›ã‚‹ã€‚ãƒ¯ã‚¤ãƒ¯ã‚¤ã§ãã‚‹ã€‚ãƒ‡ãƒ¡ãƒªãƒƒãƒˆã¯è²¢çŒ®ã—ãªã„ã¨ã¨ã„ã†ãƒ—ãƒ¬ãƒƒã‚·ãƒ£ãƒ¼ãŒã‚ã‚‹ã€‚å€‹äººçš„ãªæ„è¦‹å¤§å­¦ã®ç ”ç©¶å®¤ã®äººãŸã¡ã‚„ã€å…ˆè¼©ãƒ»å‹é”ã«CTFã«èˆˆå‘³æŒã¡ãã†ãªäººãŒã„ã‚Œã°å£°ã‚’ã‹ã‘ã¦ä¸€ç·’ã«ã‚„ã‚‹ã£ã¦ã®ã¯ã„ã„ã¨æ€ã„ã¾ã™ã—ã€å¤§å­¦ã®ã‚µãƒ¼ã‚¯ãƒ«ã§CTFã‚’ã‚„ã£ã¦ã‚‹ã‚ˆã†ãªæ‰€ã‚‚ã‚ã£ãŸã‚Šã—ã¾ã™ã€‚ãã†ã„ã†æ‰€ã«è©±ã‚’èãã«è¡Œã£ã¦ã¿ã‚‹ã®ã‚‚ã‚ã‚Šãªã®ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãã†ã„ã†å ´åˆã‚’é™¤ãã¨ã€åˆã‚ã¯1äººã®æ–¹ãŒã„ã„ã®ã‹ãªãã¨æ€ã£ã¦ã„ã¾ã™ã€‚å¼·ã„äººã¨å‡ºã‚‹ã¨æœ€åˆã¯è²¢çŒ®ã§ããªãã¦æ¥½ã—ã‚€ã“ã¨ã‚ˆã‚Šç”³ã—è¨³ãªã•ãŒå‹æ‰‹ã—ã¾ã—ã¾ã™ã—ã€åˆå¿ƒè€…åŒå£«ã§ãƒãƒ¼ãƒ ã§å‡ºã¦ã‚‚ã€åŒã˜å•é¡Œã‚’è¤‡æ•°äººã§è§£ãå ´åˆã‚’é™¤ã„ã¦ã‚½ãƒ­ã¨å¤‰ã‚ã‚‰ãªã„ã®ã§ã¯ã¨æ€ã£ã¦ã—ã¾ã—ã¾ã™ã€‚åŒã˜å•é¡Œã‚’è¤‡æ•°äººã§è§£ãå ´åˆã¯ã€ãã‚Œã‚’ç¶šã‘ã‚‹ã¨å•é¡Œã®å–ã‚Šåˆã„ã«ãªã£ã¦ã—ã¾ã†ã“ã¨ãŒå¤šã„ã®ã‹ãªãã£ã¦å‹æ‰‹ã«æ€ã£ã¦ã¾ã™ã€‚(çµŒé¨“ãªã—)ãªã®ã§ã€è‡ªåˆ†ãŒåˆå¿ƒè€…å’æ¥­ã—ãŸãªãâ€¦!!ã¨æ€ã£ãŸã‚‰ãƒãƒ¼ãƒ ã‚’çµ„ã‚€ã®ãŒã„ã„ã¨æ€ã„ã¾ã™ã€‚ã—ã‹ã‚‚ã€è‡ªåˆ†ã®è‹¦æ‰‹ãªåˆ†é‡ãŒå¾—æ„ãªäººã¨çµ„ã‚€ã¨å¾—æ„ãªéƒ¨åˆ†ã«é›†ä¸­ã§ãã¦ã‹ã¤ã€è‹¦æ‰‹ã®éƒ¨åˆ†ã§ã‚‚å¾—ç‚¹ã—ã¦ãã‚Œã‚‹ã¨ã„ã†ã¾ã•ã«ä¸€çŸ³äºŒé³¥ã«ãªã‚Šã¾ã™ã€‚ã©ã†ã‚„ã£ã¦ã¿ã¤ã‘ã‚‹ã®â€¦é‡è‰¯CTFerã®äººãŒã„ã‚‹ã®ã‹å•é¡Œã§â€¦è‡ªåˆ†ãŒåˆå¿ƒè€…å’æ¥­ã—ãŸãªãâ€¦ã¨æ€ã†é ƒã«ã¯Twitterã«CTFèˆˆå‘³ã‚ã‚‹ã‚ˆã£ã¦äººãŸã¡ã¨ç›¸äº’ãƒ•ã‚©ãƒ­ãƒ¼ã«ãªã£ã¦ã„ã‚‹ã¯ãšã§ã™ã€‚(ã¡ã‚ƒã‚“ã¨å‹•ã‹ã—ã¦ã„ã‚Œã°)åŒã˜å®ŸåŠ›ãã†ãªäººã«ä¸€ç·’ã«å‡ºã¾ã›ã‚“ã‹ã£ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã£ã¦ã¿ã‚‹ã®ãŒã„ã„ã®ã‹ã¨æ€ã„ã¾ã™ã€‚(è«¸èª¬ã‚ã‚Š)ã˜ã‚ƒã‚ã€å¼·ããªã‚‹ã«ã¯â€¦?ã¨ã‚Šã‚ãˆãšã€CTFã«å‡ºã¦å‡ºã¦ã€å‡ºã¦ãã ã•ã„ã€‚å‡ºã¦å•é¡Œã‚’æ­»ã¬ã»ã©è§£ã„ã¦ã€çŸ¥ã‚‰ãªã„ã“ã¨ã‚’çŸ¥ã£ã¦ç†è§£ã‚’æ·±ã‚ã¦ãã ã•ã„ã€‚ã“ã“ã¾ã§ãã‚Œã°â€¦ã‚‚ã†å¾Œã¯ã€ä¸Šã‚’ç›®æŒ‡ã—ã¦ç²¾é€²ã™ã‚‹ã®ã¿ã§ã™â€¦!!!! ãŠäº’ã„é ‘å¼µã‚Šã¾ã—ã‚‡ã†æœ€å¾Œã«åƒ•ã¯ã„ã¤ã§ã‚‚èª°ã§ã‚‚ã‚¦ã‚§ãƒ«ã‚«ãƒ ã§ã™ã®ã§ãŠæ°—è»½ã«ãŠèª˜ã„ãã ã•ã„â€¦!!ã‚½ãƒ­éãã¦ã‚½ãƒ­ã®æ„Ÿè¦šãŒæŸ“ã¿ã¤ã„ã¦ã¾ã™ãŒâ€¦ï½µï½°ï¾ï½²ï½¶ï¾ï½°â€¦æ¬¡å›ã¯Laikaã•ã‚“ãŒãªã«ã‹æ›¸ã„ã¦ãã‚Œã‚‹ã¿ãŸã„ã§ã™ã€‚ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚" }, { "title": "shakti CTF 2022 writeup", "url": "/posts/shakti-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-12-11 00:00:00 +0900", "snippet": "åˆã‚ã«solveãŒå°‘ãªã„ã‚‚ã®ã‚’â€¦CRTã®ä½¿ã„æ–¹ãŒé¢ç™½ã‹ã£ãŸã®ã§å¾Œã§è‡ªåˆ†ãªã‚Šã«ã„ã˜ã£ã¦ã¿ã¾ã™ã€‚[crypto] d0uble_cbc [16 solve]challfrom Crypto.Cipher import AES from Crypto.Util.Padding import pad,unpad from Crypto.Util.strxor import strxorfrom secret import key,flag ,ivfrom os import * def encryptt(pt): return (AES.new(key,AES.MODE_CBC,iv)).encrypt(pad(pt,16)) def decryptt(ct): if len(ct)%16 == 0: return (AES.new(key,AES.MODE_CBC,iv)).decrypt(ct) elif len(ct)%16 != 0: return (unpad((AES.new(key,AES.MODE_CBC,iv)).decrypt(ct) , 16)) def verify_ivv(iv,iv_detected): if iv.hex() == iv_detected: print(\"Yooo... you are going good, move forward with some more courage\") return True else: print(\"Don't lose hope buddy , you can get through this, try again \") return Falsedef sign(iv,key,message): try: cbc = AES.new(key, AES.MODE_CBC,iv) messageblocks = [message[i:i + 16] for i in range(0, len(message), 16)] tag = cbc.encrypt(messageblocks[0]) for i in range(1,len(messageblocks)): cbc1 = AES.new(key, AES.MODE_CBC,tag) tag = cbc1.encrypt(messageblocks[i]) return tag.hex() except: print(\"\\nNo padding done here !, try again \") exit() def main(): print(\"******************************Welcome to the john's CBC server************************\") print(\"You really wanna get into the system? \\n then search for IV \") print(\"Choose 1 option among four \\n \\t 1.Encrypt the plain text \\n \\t 2.Decrypt the ciphertext \\n \\t 3.feed IV \\n \\t 4.exit\") op = int(input()) if op == 1: print(\"I will provide the encrypted text for you\") print(\"Input the plaintext in hex format\\n\") pt = input() ct = encryptt(bytes.fromhex(pt)).hex() print(f\"cipher text for provided\" , ct); if op == 2: print(\"I will provide the reasonable plaintext for you\") print(\"Input the cipher text in bytes to decrypt\") ct = input() pt = decryptt(bytes.fromhex(ct)).hex() print(f\"decrypted text for provided\" , pt); if op == 3: print(\"Provide reasonable IV to proceed further\") iv_detected = input() verify_iv = verify_ivv(iv,iv_detected) print(verify_iv) if verify_iv: print(\"Let me see whether you are worth enough to gain my gold coins.\") print(\"To prove yourself, give me two different hex-encoded messages that could sign to the same tag.\") print(\"Now press '0' to get your hex inputs signed and press 1 to submit two same messages\") iv_detected = bytes.fromhex(iv_detected) x = input() if x == '0': print(\"Input hash encoded message:\\n\") msg = bytes.fromhex(input()) x = sign(iv_detected,key,msg) print(\"\\n Tag for your message\") print(x) if x == '1': msg1 = bytes.fromhex(input(\"\\nMessage #1: \\n\")) msg2 = bytes.fromhex(input(\"\\nMessage #2: \\n\")) if(msg1 == msg2): print(\"\\nThis is not a correct way to do this, think again!!!\") exit() if(msg1 != msg2 and sign(iv_detected,key,msg1)==sign(iv_detected,key,msg2)): print(flag) exit() else: print(\"\\nOops! They don't match!...Better luck next time!\") exit() if op==4: exit() if __name__ == '__main__': main()solve$m = m_1+m_2$ã¨ã—ã€$c_1 = enc(m_1 \\oplus iv),c_2 = enc(m_2 \\oplus c_1)$ã¨ã—ã¦ãŠãã¾ã™ã€‚ã“ã“ã§ã®$+$ã¯æ–‡å­—åˆ—ã®çµåˆã§ã™ã€‚æ›´ã«$mâ€™_2 = dec(c_2)\\oplus iv,mâ€™_1 = dec(c_1) \\oplus c_2$ã¨ã‚‚ã—ã¦ãŠãã¾ã™ã€‚part1ç›®æ¨™ : ivã®å°å‡ºãã‚Œãã‚Œæ—¢çŸ¥ã®å¤‰æ•°ã¯$m_1,m_2,c_1,c_2,mâ€™_1,mâ€™_2$ã®6ã¤ã€‚$c_1 = enc(m_1 \\oplus iv),mâ€™_1 = dec(c_1) \\oplus c_2$ã‚’çºã‚ã¦$dec(c1) = m_1 \\oplus iv=mâ€™_1\\oplus mâ€™_2$ã‚ˆã‚Š$iv = m_1 \\oplus mâ€™_1\\oplus c_2$ã§æ±‚ã¾ã‚‹from attacks.cbc.padding_oracle import attackfrom pwn import *def bxor(a,b): return bytes([ a_^b_ for a_,b_ in zip(a,b)])BLOCK_SIZE = 16m1 = b\"1\"*16m2 = b\"2\"*16print((m1+m2).hex())# 3131313131313131313131313131313132323232323232323232323232323232enc = bytes.fromhex(\"1ff6715f925f8101e755d865142ca76964a478eee818f9153509586f9a05133d8831c0ab6a1dc68a83cdc8754b360909\")c1 = enc[:BLOCK_SIZE]c2 = enc[BLOCK_SIZE:BLOCK_SIZE*2]print(\"ct\",(c2+c1+enc[BLOCK_SIZE*2:]).hex())plain = bytes.fromhex(\"6c9b2b0cd01dca6cb60589084b71f13e14ca21bea959b17b675a0a01c65b46696b4219a16a576804c24c901a9e39a444\")m1_prime = plain[BLOCK_SIZE:]iv_cal = bxor(bxor(c2,m1_prime),m1)print(iv_cal)iv = b\"A_happy_cbc_mode\"print(iv.hex())part 2ç›®æ¨™ : $enc(m_1)ã¨enc(m_2)ã®æœ€çµ‚ãƒ–ãƒ­ãƒƒã‚¯ãŒåŒã˜ \\ and\\ m_1 \\neq m_2$æš—å·éƒ¨åˆ†ã¯ã€ãªãœã‹åˆ†ã‘ã¦ã„ã‚‹ã‘ã©AES-CBCã¨åŒã˜å‹•ä½œã™ã‚‹ã®ã§ã€ç´°ã‹ã„ã“ã¨ã¯æ°—ã«ã—ãªã„ã€‚ã¨ã„ã†ã“ã¨ã§ã€$mâ€™ = m_2$ã¨$mâ€™â€™ = m_1+m_2$ã‚’ç”¨æ„ã™ã‚‹ãŒã€$iv\\neq enc(m_1\\oplus iv)$ã§ã¯ãªã„ãŸã‚å‹•ã‹ãªã„ã€‚å…ˆã»ã©ã‚ˆã‚Š$c_1$ãŒæ—¢çŸ¥ãªã“ã¨ã‚’åˆ©ç”¨ã—ã¦ã¨ã—ã¦$mâ€™ = m_2\\oplus c_1 \\oplus iv$ã¨$mâ€™â€™ = m_1+m_2$ã¨ã™ã‚Œã°æ±‚ã¾ã‚‹ã€‚enc123 = (m1+m2).hex()enc23 = (bxor(bxor(c1,iv),m2)).hex()print(enc123)print(enc23)# shaktictf{double_cheese_double_mac_yummyyyy_4120686170707920636263206d6f6465}[crypto] r3deem_r4Nd0mã€€[6 solve]challfrom hashlib import sha256from Crypto.Util.number import *from secret import p,q,r,flag# p,q,r = getPrime(256),getPrime(256),getPrime(256)n = p*q*re = 65537phi = (p-1)*(q-1)*(r-1)d = inverse(e,phi)ct = pow(bytes_to_long(flag),e,n)h =int(sha256(flag).hexdigest(),16)dp = d%(p-1)dq = d%(q-1)dr = d%(r-1)sp = pow(h,dp,p)sq = pow(h,dq,q)sr = pow(h,dr,r)s = (((sp*q*r*(inverse(q*r,p)))%n) + (sq*p*r*(inverse(p*r,q)) %(n)) + ((sr*p*q*(inverse((p*q),r)))%n))%n from r3d33m_r4Nd0m import sp,sq,sr,h,e,n,ctfrom Crypto.Util.number import * from secret import flag,p,q,rdef crt(sp1,sq1,sr1,p,q,r): s1 = (sp1*q*r*(inverse((q*r),p)))%n s2 = (sq1*p*r*(inverse((p*r),q)))%n s3 = (sr1*p*q*(inverse((p*q),r)))%n s = (s1+s2+s3)%n return s1,s2,s3,s def server(): print(f\"Welcome to this small crt game\\nI am a poor kid, I am here to do a small job which can help me to coverup my small expenses.\\nSo, My job is to do some simple calulations for inputs provided.\\n\\nAs part of game rules, intially I will give you some parameters, using that parameters and this server try to get me the flag , then you can get the treasure\\nParameters provided\\nn = {n}\\ne = {e}\\nh = {h}\\nct = {ct}\\nPlease try to give valid input, if I am unable do good calulations, my boss will fire me :( \\nYou have two options:\\n\\n1. Input '1' to get sp,sq,sr values and it's computation values from our server\\n2. Input '2' to input your own sp,sq,sr and get corresponding computatuion values\" ) x = input() if x == '1': print(f\"sp = {sp}\\nsq = {sq}\\nsr = {sr}\") s1,s2,s3,s = crt(sp,sq,sr,p,q,r) print(f\"s1 = {s1}\\ns2 = {s2}\\ns3 = {s3}\\ns = {s}\") if x == '2': print(\"Get customized s1,s2,s3 and s values.\") print(\"Input sp,sq,sr values\") sp_u = int(input(\"\\nInput your sp value: \")) sq_u = int(input(\"\\nInput your sq value: \")) sr_u = int(input(\"\\nInput your sr value: \")) s1_u,s2_u,s3_u,s_u = crt(sp_u,sq_u,sr_u,p,q,r) print(f\"s1 = {s1_u}\\ns2 = {s2_u}\\ns3 = {s3_u}\\ns = {s_u}\")if __name__ == '__main__': server() solveRSAã§æš—å·ã•ã‚Œã€ãã®ç´ æ•°ã§CRTã‚’è¡Œã†ã‚‚ã®ãŒæ¸¡ã•ã‚Œã‚‹ã€‚ã¨ã‚Šã‚ãˆãšã€ç´ æ•°$p,q,r$ãŒã‚ã‹ã‚‰ãªã„ã¨å§‹ã¾ã‚‰ãªã„ã®ã§ã€CRTã‚’ã†ã¾ãç”¨ã„ã¦å‰²ã‚Šå‡ºã—ã¦ã„ãã€‚$s_1 = q*r * (q*r \\mod p) -k*n=q*r * ((q*r \\mod p) -k*p) $ã‚ˆã‚Š$q*r=GCD(s_1,n)$ã‹ã‚‰$p$ãŒã‚ã‹ã‚‹ã€‚ã“ã‚Œã‚’åŒæ§˜ã«ã™ã‚Œã°ä»–ã®å€¤ã‚‚ã™ãã«æ±‚ã¾ã‚‹ã€‚from Crypto.Util.number import *n = 671193456450696209294538401092132200835318782822322315634822979842491480350953125013703551172675245349609262913412939263137349891298234146269765976476713743829345089919755818249576374672896649899144345865055014963972247204207494479e = 65537ct = 562424961019202732191255280916393150126209218444188556517270687960305550759526781461098153889147500792001380371454899207533680446302990359819605368684890785759571941069404593981778618037030554910233447127875225743078821221483182353s1 = 299975575615366431743442900345501820171302184916013790549258989583702124067113757045635815940516169014707886648203282728770493017593176259766163134766679080376970009232489603551294208308458498129957898345431067389579567886412734956s2 = 634658493680316046522130611451479798630743814754138967420984564261348394927938620704099453345768485030779025330014580509993617335353452850125123544790400738121047937373231722413387921371961136162073670869158916961134003314014005256s3 = 470074781431408813402769135661849283210474606932730644990171152572265111532273848127919937536197133365570762332224403240917868298063908774205995365446224500933717346898118648118764091769080701066160085582010046429901107442705628137s = 62321937825698873079265845274566500341883040958238771690768746732332669825419975850248104477131296711839148483616387953407278868414069591557750092049876831773045113664328337584293472103707035559902963066490000852670184234717379391p = n//GCD(s1,n)q = n//GCD(s2,n)r = n//GCD(s3,n)assert n == p*q*rd = pow(e,-1,(p-1)*(q-1)*(r-1))print(long_to_bytes(int(pow(ct,d,n))))" }, { "title": "HITCON CTF 2022 writeup", "url": "/posts/HITCON-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-11-30 12:00:00 +0900", "snippet": "åˆã‚ã«HITCONã§ãƒœã‚³ã‚‰ã‚ŒãŸã®ã§ãƒ¡ãƒ¢æ›¸ãbabyssschallfrom random import SystemRandomfrom Crypto.Cipher import AESfrom hashlib import sha256from secret import flagrand = SystemRandom()def polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])DEGREE = 128SHARES_FOR_YOU = 8 # I am really stingy :)poly = [rand.getrandbits(64) for _ in range(DEGREE + 1)]shares = []for _ in range(SHARES_FOR_YOU): x = rand.getrandbits(16) y = polyeval(poly, x) shares.append((x, y))print(shares)secret = polyeval(poly, 0x48763)key = sha256(str(secret).encode()).digest()[:16]cipher = AES.new(key, AES.MODE_CTR)print(cipher.encrypt(flag))print(cipher.nonce)solveShamirâ€™s Secret SharingãŒãƒ¢ãƒãƒ¼ãƒ•ã®å•é¡Œä»Šå›ã«ãŠã‘ã‚‹è„†å¼±æ€§ã¯ã€ã€Œ$\\mod p$ã§ã®æ¼”ç®—ã§ãªã„ ã€ãƒ»ã€Œ$x$åº§æ¨™ã®æ¡ãŒå¤§ãã„ã€ã®äºŒç‚¹ $\\mod p$ã§ã®æ¼”ç®—ã§ãªã„ã€€â‡’ã€€$y = \\sum a_ix_i$ ã‚ˆã‚Šæ•´æ•°ç’°ä¸Šã®å¤šé …å¼ã¨ã¨ãˆã‚‰ã‚Œã‚‹ $x$åº§æ¨™ã®æ¡ãŒå¤§ãã„ã€€â‡’ã€€$a_0 \\equiv \\sum a_i*x_i \\mod x$ã§ã‚ã‚‹ãŸã‚$a_0$ã®ãƒ“ãƒƒãƒˆãŒ$x$ã®ãƒ“ãƒƒãƒˆç¨‹åº¦æŒã¤çµæœã¨ã—ã¦1ã¤ç›®ã§GCDã‚„LCMã¨ã„ã£ãŸæ•´æ•°ã§ã®è©±ãŒæˆã‚Šç«‹ã¤ã€‚ãã—ã¦ã€2ã¤ç›®ã§$x$ã®ãƒ“ãƒƒãƒˆç¨‹åº¦æŒã¤ã®ã§çµ„ã¿åˆã‚ã›ã¦CRTï¼‘ã§å¾©å…ƒã§ãã‚‹ã¾ãŸã€æ ¼å­ã§ã®HNPã¿ãŸãè€ƒãˆã‚‰ã‚Œã‚‹ã€‚solve1lists = [(41458, 3015894889650529600470920314593280408459518223054415623846810748413393737686521849609926975694824777687791824408686652245102687392987299828716863372946074882798754477101786150262288970710451710086966378817944448615584285684364802621112755627795146504720812935041851556318832824799502759754100408717888912062197676588256634343721633045179136302533777168978134770315363985448879229514802330846792965525004570768212871252658334277172395338054448791891165981203069346039654617938169527772805687564575525262812469960675835101499054296722994451502140787064163668418661661374437567033971648550576296023422536253955229), (3389, 188433716494377932944071544153838579057591833387651830021721770473524507947811754295899393634645349682360212761145039355690817927625249659010181081209481357850193656763556243022791637306094953982811471415645267589939465925098159204147714779617946431727015863707468081949286110249296858079354949234074465541940264775783884708819566758872542606519408358277173683256608326688673226933790117016596834640875497643330432185114931410656582728964222203181026468387428893233826461), (20016, 100434774699078525844435127144579870564983915777345068724291926367405061427748836490810414860997895358378538088786283372231649911113841061354335739776409724471256377867811133591349442950556374825868587940833009529662869081130218551306459690738900795035660420986807973542512081415453215211908130387754214098414826747340962722685373241806099462750595976574593799013733614097923338311883793416643213898201680852118540438376386415411317989072583126108177482838299109479175882214603698768498421016054035672774286507312986602290254323930575001551875601243671354491241420409219), (50683, 444545881882748849210617532697661279371689521082184772844723908765173319859389018743414369945234307906596253496624659734919646710483514374218993496994560985318096082923429834553341897367168830049334302307406087637232329348570485341223211629167329394484624055745054495405880099706580380696671879365741197827080224977821589102425678989782880274304484630899425664722718972847034030888019348402685383311095030884356731112886316823960378572796288532824588478234949384868912708000223119984161992105752059185137674711077940232530298853451166664700609238496874366152042676602089571801873748042888046623717879084695143810047335029), (6445, 101461065764578261241074518788237888467081270902741849861528201922043223477790661159690684156056890167304291810116447916457265705130707166062372766839626095333813681671546097679623755546322833727082145873422243641505450049118758544298328784536759107951763715458884889255549767465897671061295486677353893450789955616926292534325337544782386120469581214993770910137353221116457111551538222138388416162630076391624447865248920466274175229034129561913505977209131490066291917549232913771218316393849495621818397), (1359, 301175604076484656987097022479686300460199620068959954988990822483114048418823291831080744590394713639405681060973359346474547015206086229256524657214311815578895906855833813636970640902962286472992468394831014254279137613828904924898823470285520515090889491445149243620044782726415898188702226878029241518020146726699446397961112596830223444821094650508662477147134721631935528182772284099429814417490160457082241680661), (45286, 244867719210730952183489456726726432791149629831242968845409984537752132549250274779516590253042559196452609852176114909791657154092483479876795482861784431886143414585698773882088948703730268947925790809436449512089696895048994874003651088538416399435467483409931121063976149037130454114161175715871108284419975118570732022104749321213013756795645219060997019373915339235627535694458093194617642834806820772479160496966470147893963746139947337914575231526069667124822677688977724313174612816604463495630041075005651663546036363128325535621487658461744362098985183050127661470315454320073092665472364666768205258769), (5649, 4766101906865350375503575239791521167258753430948472304582908507542293595346756303331383584550516424087839316050412570112796817549423179461056531056102741963677007097061600281918678364910813585444151640384802648969082273001142879806475184857246441212406056540028447374033197873299250076862108042582790928405869475508762352345569281589853917902601519294573327847401601789315980414998055948162169170771240383220643819333682845459742335249254576151835966500230706707674854493184181354958093926469960861)]enc = b'G$\\xf5\\x9e\\xa9\\xb1e\\xb5\\x86w\\xdfz\\xbeP\\xecJ\\xb8wT&lt;&lt;\\x84\\xc5v\\xb4\\x02Z\\xa4\\xed\\x8fB\\x00[\\xc0\\x02\\xf9\\xc0x\\x16\\xf9\\xa4\\x02\\xb8\\xbb'nonce = b'\\x8f\\xa5z\\xb4mZ\\x97\\xe9'from sage.all import *from Crypto.Cipher import AESfrom hashlib import sha256def polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])x = []y = []a = []for xi, yi in lists: x.append(xi) y.append(yi)for i in range(129): ai_dist = [] for xi, yi in zip(x,y): ai_dist.append(yi%xi) a.append(CRT(ai_dist,x)) for k in range(len(x)): y[k] = (y[k] - a[i])//x[k]secret = polyeval(a, 0x48763)key = sha256(str(secret).encode()).digest()[:16]cipher = AES.new(key, AES.MODE_CTR,nonce=nonce)print(cipher.decrypt(enc))b'hitcon{doing_SSS_in_integers_is_not_good_:(}'solve2ç·šå½¢å’Œã¨ã¿ãªã—ã¦æ ¼å­è§£ã«æŒã¡è¾¼ã‚€ã¨ã‚‚ã§ãã‚‹ã€ã€ã€ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆãŒãƒŸã‚¹ã—ã¦ã„ãŸã¨ã“ã‚ã§ã€ã€ã€ã„ã‚„ã€ã­ï¼Ÿï¼Ÿï¼ŸLLLã§å°æ•°ä½¿ãˆã‚‹ã®å®Œå…¨ã«æŠœã‘ã¦ã¾ã—ãŸã‚ˆãã‚ˆãè€ƒãˆã‚Œã°ã€$2^{64}$ã§ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã™ã‚‹ã¨æ ¼å­ã®è§£ã§$0$ãŒä¸¦ã¶ã‚ã‘ãªã„ã‚„ãªã„ã‹ã¨â€¦ãªã‚“ãªã‚‰ã€åŒã˜ã“ã¨ã‚’secretã§è€ƒãˆã¦ã‚„ã£ã¦ã‚‹ã—â€¦from random import SystemRandomfrom Crypto.Cipher import AESfrom hashlib import sha256def polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])shares = [(41458, 3015894889650529600470920314593280408459518223054415623846810748413393737686521849609926975694824777687791824408686652245102687392987299828716863372946074882798754477101786150262288970710451710086966378817944448615584285684364802621112755627795146504720812935041851556318832824799502759754100408717888912062197676588256634343721633045179136302533777168978134770315363985448879229514802330846792965525004570768212871252658334277172395338054448791891165981203069346039654617938169527772805687564575525262812469960675835101499054296722994451502140787064163668418661661374437567033971648550576296023422536253955229), (3389, 188433716494377932944071544153838579057591833387651830021721770473524507947811754295899393634645349682360212761145039355690817927625249659010181081209481357850193656763556243022791637306094953982811471415645267589939465925098159204147714779617946431727015863707468081949286110249296858079354949234074465541940264775783884708819566758872542606519408358277173683256608326688673226933790117016596834640875497643330432185114931410656582728964222203181026468387428893233826461), (20016, 100434774699078525844435127144579870564983915777345068724291926367405061427748836490810414860997895358378538088786283372231649911113841061354335739776409724471256377867811133591349442950556374825868587940833009529662869081130218551306459690738900795035660420986807973542512081415453215211908130387754214098414826747340962722685373241806099462750595976574593799013733614097923338311883793416643213898201680852118540438376386415411317989072583126108177482838299109479175882214603698768498421016054035672774286507312986602290254323930575001551875601243671354491241420409219), (50683, 444545881882748849210617532697661279371689521082184772844723908765173319859389018743414369945234307906596253496624659734919646710483514374218993496994560985318096082923429834553341897367168830049334302307406087637232329348570485341223211629167329394484624055745054495405880099706580380696671879365741197827080224977821589102425678989782880274304484630899425664722718972847034030888019348402685383311095030884356731112886316823960378572796288532824588478234949384868912708000223119984161992105752059185137674711077940232530298853451166664700609238496874366152042676602089571801873748042888046623717879084695143810047335029), (6445, 101461065764578261241074518788237888467081270902741849861528201922043223477790661159690684156056890167304291810116447916457265705130707166062372766839626095333813681671546097679623755546322833727082145873422243641505450049118758544298328784536759107951763715458884889255549767465897671061295486677353893450789955616926292534325337544782386120469581214993770910137353221116457111551538222138388416162630076391624447865248920466274175229034129561913505977209131490066291917549232913771218316393849495621818397), (1359, 301175604076484656987097022479686300460199620068959954988990822483114048418823291831080744590394713639405681060973359346474547015206086229256524657214311815578895906855833813636970640902962286472992468394831014254279137613828904924898823470285520515090889491445149243620044782726415898188702226878029241518020146726699446397961112596830223444821094650508662477147134721631935528182772284099429814417490160457082241680661), (45286, 244867719210730952183489456726726432791149629831242968845409984537752132549250274779516590253042559196452609852176114909791657154092483479876795482861784431886143414585698773882088948703730268947925790809436449512089696895048994874003651088538416399435467483409931121063976149037130454114161175715871108284419975118570732022104749321213013756795645219060997019373915339235627535694458093194617642834806820772479160496966470147893963746139947337914575231526069667124822677688977724313174612816604463495630041075005651663546036363128325535621487658461744362098985183050127661470315454320073092665472364666768205258769), (5649, 4766101906865350375503575239791521167258753430948472304582908507542293595346756303331383584550516424087839316050412570112796817549423179461056531056102741963677007097061600281918678364910813585444151640384802648969082273001142879806475184857246441212406056540028447374033197873299250076862108042582790928405869475508762352345569281589853917902601519294573327847401601789315980414998055948162169170771240383220643819333682845459742335249254576151835966500230706707674854493184181354958093926469960861)]enc = b'G$\\xf5\\x9e\\xa9\\xb1e\\xb5\\x86w\\xdfz\\xbeP\\xecJ\\xb8wT&lt;&lt;\\x84\\xc5v\\xb4\\x02Z\\xa4\\xed\\x8fB\\x00[\\xc0\\x02\\xf9\\xc0x\\x16\\xf9\\xa4\\x02\\xb8\\xbb'nonce = b'\\x8f\\xa5z\\xb4mZ\\x97\\xe9'DEGREE = 128SHARES_FOR_YOU = 8 # I am really stingy :)N = DEGREE+1m = matrix(QQ, N+1 ,N+1+SHARES_FOR_YOU)for i in range(SHARES_FOR_YOU): for k in range(N): m[k,i] = pow(shares[i][0],k)B = 2^64for i in range(N): # m[i,i+SHARES_FOR_YOU] = 2^64 m[i,i+SHARES_FOR_YOU] = 1/Bfor i in range(SHARES_FOR_YOU): m[-1,i] = -1*shares[i][1]# m[-1,-1] = 2^2048m[-1,-1] = 1M = m.LLL()for row in (M*B): if abs(row[-1]) != B: continue # secret = polyeval([r//2^64 for r in row], 0x48763) secret = polyeval([int(r) for r in row[8:-1]], 0x48763) key = sha256(str(secret).encode()).digest()[:16] cipher = AES.new(key, AES.MODE_CTR,nonce=nonce) # if b\"HIT\" in cipher.decrypt(enc): print(cipher.decrypt(enc)) exit()print(\"[-] not find\")secretchallimport random, osfrom Crypto.Util.number import getPrime, bytes_to_longp = getPrime(1024)q = getPrime(1024)n = p * qflag = open('flag','rb').read()pad_length = 256 - len(flag)m = bytes_to_long(os.urandom(pad_length) + flag)assert(m &lt; n)es = [random.randint(1, 2**512) for _ in range(64)]cs = [pow(m, p + e, n) for e in es]print(es)print(cs)solve1$c_i \\equiv m_i^{(p + e_i)} \\mod n$ã‚ˆã‚Š$\\sum (p + e_i)*{a_i}=0$ã¨ãªã‚‹$a_i$ã‚’ã„ãã¤ã‹æ¢ã™ã€‚ã‚‚ã—ã€ã“ã‚Œã‚‰ãŒè¦‹ã¤ã‹ã‚‹ãªã‚‰$\\prod m_i^{(p + e_i)*{a_i}} \\mod n \\equiv \\prod c_i^{a_i} = 1 $ã¨ãªã‚‹ã€‚ã•ã‚‰ã«é€šå¸¸ã§ã‚ã‚Œã°$n$ãŒã‚ã‹ã£ã¦ã„ãªã„ã®ã§å‰°ä½™ã‚’å–ã‚‹ã“ã¨ãŒã§ããªã„ãŒå³è¾ºã‚’å˜å…ƒã¨ã—ã¦ã„ã‚‹ãŸã‚$a_i$ãŒè² ã®å€¤ã«ãªã‚‹ã®ã§ã‚ã‚Œã°å³è¾ºã«ç§»é …ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã‚ˆã£ã¦ã€LLLã‚’ä½¿ã£ã¦æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãªé …ã‚’æ±‚ã‚ã¦ã„ãã€‚$\\sum (p + e_i)*{a_i} = \\sum e_i * a_i + p*\\sum 1* a_i =0$ã‚ˆã‚Š1åˆ—ç›®ã¯$e_i$ã®é …ã‚’ã€2åˆ—ç›®ã«ã¯$1$ã‚’é…ç½®ã™ã‚‹ã€‚æ®‹ã‚Šã¯å˜ä½è¡Œåˆ—ã«ã—ã¦ã©ã®é …ãŒä½•å›ä½¿ã‚ã‚ŒãŸã®ã‹ã®ç¢ºèªã®é …($a_i$)ã¨ãªã‚‹ã€‚\\[\\left[\\begin{array}{ccccc}e_0 &amp; 1 &amp; 1 &amp; \\cdots&amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots&amp;\\ddots&amp; 0 \\\\ e_n &amp; 1 &amp; 0 &amp; \\cdots &amp; 1 \\end{array}\\right]\\]ãŒã“ã‚Œã§æ±‚ã‚ã‚‹ã¨æƒ³å®šã—ã¦ã„ãŸåˆæ‰‹2é …ç­”ãˆãŒ$0$ã¨ã¯ãªã‚‰ãšä»¥ä¸‹ã¿ãŸã„ã«ãªã‚‹ã€‚(115, -47, 90, 120, -30, 4, 88, 13, -86, 18, -20, -149, -4, 212, -85, 106, -20, -94, 5, 32, 26, 114, 48, -15, -51, -252, 2, 113, -19, -26, 75, -118, 48, -15, -112, 187, -96, -89, -12, -46, 198, -101, -5, -31, -164, 97, -145, -127, 59, 33, 125, -26, -84, -252, 35, 43, 192, -24, 129, -179, 29, -9, 140, 11, 51, -4)$a_i$ã®é …ã®å¤§ãã•ãŒ$0$ã‚ˆã‚Šã‚‚å¤§ãã„ãŸã‚å¼•ã£å¼µã‚‰ã‚Œã¦$0$ãŒå‡ºãªããªã‚‹ã€‚ã‚ˆã£ã¦ã€$a_i$ã®é …ã‚’å°ã•ãã—ã¦ã‚„ã‚‹ã¨\\[\\left[\\begin{array}{ccccc}e_0 &amp; 1 &amp; 1/65537 &amp; \\cdots&amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots&amp;\\ddots&amp; 0 \\\\ e_n &amp; 1 &amp; 0 &amp; \\cdots &amp; 1/65537 \\end{array}\\right]\\](0, 0, -202/65537, -8/65537, 28/65537, 227/65537, 253/65537, 61/65537, -3/65537, -128/65537, -2/65537, -83/65537, 31/65537, -85/65537, -51/65537, 85/65537, -123/65537, 2/65537, 191/65537, 62/65537, 23/65537, 227/65537, -151/65537, -8/65537, -108/65537, 257/65537, -16/65537, -67/65537, -221/65537, 120/65537, -85/65537, -79/65537, -67/65537, 19/65537, -20/65537, 44/65537, 30/65537, 125/65537, 25/65537, 220/65537, -33/65537, -128/65537, 50/65537, -24/65537, 117/65537, 19/65537, -15/65537, -104/65537, -23/65537, -173/65537, -100/65537, 84/65537, 1/65537, -27/65537, 40/65537, -59/65537, -47/65537, -53/65537, -63/65537, 173/65537, -103/65537, -31/65537, 1/65537, 3/65537, -29/65537, 1/65537)æƒ³å®šã—ã¦ã„ãŸã‚ˆã†ã«åˆæ‰‹2é …ç­”ãˆãŒ$0$ã«ãªã£ãŸã®ã§ä¿‚æ•°ãŒ$a_i/65537$ã«$65537$ã‹ã‘ã¦ã‚„ã£ã¦æ¬²ã—ã„$a_i$ãŒæ±‚ã¾ã‚‹ã€‚ã‚ã¨ã¯ã€$a_i$ã®å€¤ãŒæ­£ã‹è² ã‹ã§åˆ†ã‘ã¦å·®ã‚’å–ã‚Œã°$n$ã®å€æ•°ã¨ãªã‚‹$\\prod c_i^{a^+_i} - \\prod c_i^{a^-_i} =K*n $ã“ã‚Œã‚’ã„ãã¤ã‹ç¹°ã‚Šè¿”ã—ã¦GCDã‚’å–ã£ã¦ã†ã¾ãæ±‚ã‚ã¦ã‚„ã‚Œã°ã„ã„ãã®å¾Œã¯common modulus attackã§GGfrom sage.all import *from ast import literal_evalfrom factordb.factordb import FactorDBfrom Crypto.Util.number import *lines = open(\"./output.txt\",\"r\").readlines()es = literal_eval(lines[0].strip())cs = literal_eval(lines[1].strip())K = 0x10001N = len(es)m = matrix(QQ,N,N+2)for i in range(N): m[i,0] = es[i] m[i,1] = 1 m[i,i+2] = 1/(K)m = m.LLL()def serch_n(m): minas = 1 plus = 1 assert sum(m[2:])*K == 0 assert sum([m_*e_ for m_, e_ in zip(m[2:],es)]) == 0 for i,ei in enumerate(m[2:]): ei *= K ei = int(ei) if ei &lt; 0: minas = int(minas*cs[i]**(-1*ei)) if ei &gt; 0: plus = int(plus*cs[i]**ei) return plus-minask = 1n = serch_n(m[0])while m[k][0] == 0 and m[k][1] == 0 and k &lt; N: n = GCD(n,serch_n(m[k])) k +=1 if int(n).bit_length()&lt; 6300: f = FactorDB(int(n)) f.connect() n = f.get_factor_list()[-1] assert n.bit_length() == 2048 print(n) break # n = 17724789252315807248927730667204930958297858773674832260928199237060866435185638955096592748220649030149566091217826522043129307162493793671996812004000118081710563332939308211259089195461643467445875873771237895923913260591027067630542357457387530104697423520079182068902045528622287770023563712446893601808377717276767453135950949329740598173138072819431625017048326434046147044619183254356138909174424066275565264916713884294982101291708384255124605118760943142140108951391604922691454403740373626767491041574402086547023530218679378259419245611411249759537391050751834703499864363713578006540759995141466969230839from attacks.rsa.common_modulus import attackmpe1_inv = inverse(cs[0],n)e = [e-es[0] for e in es[1:]]c = [c*pow(cs[0],-1,n)%n for c in cs[1:]]find = Falsefor i in range(len(e)): for j in range(len(e)): if gcd(e[i],e[j]) == 1: m = attack(n, e[i], c[i], e[j], c[j] ) print(long_to_bytes(m)) exit()# hitcon{K33p_ev3rythIn9_1nd3p3ndent!}solve2@maple3142ã•ã‚“ã‹ã‚‰åŠ©è¨€ã„ãŸã ãã¾ã—ã¦$p$ã‚’å¾©å…ƒã—ã¦ã€ä¸Šè¨˜ã®ã‚ˆã†ã«$n$ã‚’æ±‚ã‚ã¦é€šå¸¸ã®RSAã®ã‚ˆã†ã«å¾©å…ƒã™ã‚‹æ–¹æ³•ã€‚$m^{(1 + e_i)} = c_i \\mod p$ã§ã‚ã‚‹ã®ã§ã€æ±‚ã‚æ–¹ã¯ã»ã¼åŒã˜ãªã®ã§åŒã˜ä»¥ä¸‹ã®æ§˜ã«æ ¼å­ã‚’çµ„ã‚€\\[\\left[\\begin{array}{ccccc}e_0+1 &amp; 1/65537 &amp; \\cdots&amp; 0 \\\\ \\vdots &amp; \\vdots&amp;\\ddots&amp; 0 \\\\ e_n+1 &amp; 0 &amp; \\cdots &amp; 1/65537 \\end{array}\\right]\\]from sage.all import *from ast import literal_evalfrom factordb.factordb import FactorDBfrom Crypto.Util.number import *lines = open(\"./output.txt\",\"r\").readlines()es = literal_eval(lines[0].strip())cs = literal_eval(lines[1].strip())K = 0x10001N = len(es)m = matrix(QQ,N,N+1)for i in range(N): m[i,0] = es[i] + 1 m[i,i+1] = 1/(K)# m^(p + e_i) = c_i mod n# m^(1 + e_i) = c_i mod pm = m.LLL()def serch_n(m): minas = 1 plus = 1 assert sum([m_*(e_ + 1) for m_, e_ in zip(m[1:],es)]) == 0 for i,ei in enumerate(m[1:]): ei *= K ei = int(ei) if ei &lt; 0: minas = int(minas*cs[i]**(-1*(ei))) if ei &gt; 0: plus = int(plus*cs[i]**(ei)) return plus-minask = 1n = serch_n(m[0])print(k,int(n).bit_length())while m[k][0] == 0 and k &lt; N: n_ = serch_n(m[k]) print(k,int(n_).bit_length()) n = GCD(n,n_) k +=1 if int(n).bit_length()&lt; 6300: f = FactorDB(int(n)) f.connect() p = f.get_factor_list()[-1] # [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 13, 13, 13, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 114123489471785231935784934808971699969409921187241213856052699152350022529522625133249122600992294384493330729753558097354310956450782137388609095123051712848950720360020186805006589596948820312938610934162552701552428320073591829720623902109809701883779673050594202312941073709061911680769616320309646800153] assert p.bit_length() == 1024 print(p) break p = 114123489471785231935784934808971699969409921187241213856052699152350022529522625133249122600992294384493330729753558097354310956450782137388609095123051712848950720360020186805006589596948820312938610934162552701552428320073591829720623902109809701883779673050594202312941073709061911680769616320309646800153" }, { "title": "SECCON CTF 2022 writeup", "url": "/posts/SECCON-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-11-14 14:00:00 +0900", "snippet": "åˆã‚ã«SECCONã§ã¡ã‚‡ã£ã¨å‡ºæ¥ãªã‹ã£ãŸã“ã¨ãŒå¤šã™ããŸã®ã§åˆ†ã‹ã‚‹ç¯„å›²ã§çºã‚ã¾ã—ãŸã€‚jyankenã¨witches_symmetric_examã¯ã¾ãŸæ¬¡å›ã«ã§ã‚‚â€¦ãã‚Œã‚ˆã‚Šã‚‚å•é¡Œãªã®ãŒthis_is_not_lsbãŒã»ã‚“ã¨ã«LLLã§è§£ã‘ã‚‹ã®ã‹ã¨ã„ã†ã“ã¨ã§ã€æ‰‹å…ƒã§çµ„ã‚“ã æ„Ÿã˜å…¨éƒ¨å¤±æ•—ã—ãŸã®ã§ãªãˆã¦ã¾ã™ã€‚ã¯ã„ã€‚ã€‚ã€‚å¹´æœ«ã¾ã§ã«bité•·ã•ã§ã®EHNPã¨HNPã®ãŠæ°—æŒã¡ã‚’ç†è§£ã—ãŸã„æ‰€å­˜ã§ã™ã€‚(ãŒã‚“ã°ã‚‹ã¾ã™â€¦!!)pqpqchallfrom Crypto.Util.number import *from Crypto.Random import *from flag import flagp = getPrime(512)q = getPrime(512)r = getPrime(512)n = p * q * re = 2 * 65537assert n.bit_length() // 8 - len(flag) &gt; 0padding = get_random_bytes(n.bit_length() // 8 - len(flag))m = bytes_to_long(padding + flag)assert m &lt; nc1p = pow(p, e, n)c1q = pow(q, e, n)cm = pow(m, e, n)c1 = (c1p - c1q) % nc2 = pow(p - q, e, n)print(f\"e = {e}\")print(f\"n = {n}\")# p^e - q^e mod nprint(f\"c1 = {c1}\")# (p-q)^e mod nprint(f\"c2 = {c2}\")# m^e mod nprint(f\"cm = {cm}\")solve1STEP : $p,q,r$ã®å°å‡º$c_1 \\equiv p^e - q^e \\mod n,c_2 \\equiv (p-q)^e \\mod n$ã§ã‚ã‚‹ã“ã¨ã‚ˆã‚Š$c_1-c_2 \\equiv (p^e - q^e) - (p^e+q^e + \\sum^{e-1}{i=1}\\ _eC_ip^i(-q)^{e-i})\\equiv q(-2q^{e-1}+ \\sum^{e-1}{i=1}\\ _eC_ip^i(-q)^{e-i-1}))$ã¨ãªã‚‹ã€‚ã‚ˆã£ã¦ã€$n=pqr$ã§ã‚ã‚‹ã“ã¨ã‚ˆã‚Š$c_1-c_2$ã¨$n$ã®GCDã‚’å–ã‚Œã°$q$ãŒæ±‚ã¾ã‚‹ã€‚$c_1 \\equiv p^e \\mod q$, $e=2*65537$ã§ã‚ã‚‹ã®ã§ $d \\equiv 65537^{-1} \\mod q-1$ã¨ã™ã‚Œã°$p^2 \\equiv c_1^d \\mod q $ã¨ãªã‚‹ã€‚ã‚ˆã£ã¦ã€$p^2$ã®å¹³æ–¹æ ¹ã‚’æ±‚ã‚ã‚‹ã“ã¨ã§$p$ãŒã‚‚ã¨ã¾ã‚‹ã¨åŒæ™‚ã«$n$ã‚ˆã‚Š$r$ã‚‚æ±‚ã¾ã‚‹ã€‚2STEP : å¾©å·$GCD(e,(p-1)(q-1)(r-1))) \\neq1 $ã‚ˆã‚Šå˜ç´”ãªè¨ˆç®—ã§ã¯$d$ãŒæ±‚ã¾ã‚‰ãªã„ã®ã§ã€ç´ æ•°ã”ã¨ã«å¾©å…ƒã—ã¦CRTã§æ±‚ã‚ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚ã‚ˆã£ã¦$GCD(\\frac{e}{2},(p-1)(q-1)(r-1))) =1 $ã‚ˆã‚Šå˜ç´”ãªè¨ˆç®—ã§$\\frac{e}{2}$ã®é€†å…ƒã‚’æ±‚ã‚ã‚‹ã“ã¨ã§ä»¥ä¸‹ã®å¼ãŒæ±‚ã¾ã‚‹ã€‚$ d_p \\equiv \\frac{e}{2}^{-1} \\mod p-1,d_q \\equiv \\frac{e}{2}^{-1} \\mod q-1,d_r \\equiv \\frac{e}{2}^{-1} \\mod r-1$ã‚ˆã£ã¦ã€$m_p^2 \\equiv cm^{d_p} \\mod p,m_q^2 \\equiv cm^{d_q} \\mod q,m_r^2 \\equiv cm^{d_r} \\mod r$ ã¨ãªã‚Šãã‚Œãã‚Œã®å¹³æ–¹æ ¹ã‚’çµ„ã¿åˆã‚ã›ã¦CRTã§å¾©å…ƒã—ã¦flagãŒæ±‚ã¾ã‚‹ã€‚from Crypto.Util.number import *from Crypto.Random import *from itertools import product e = 131074n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866# 1019 601 739# 36230691# e = 131074# n = 452577641# c1 = 64229228# c2 = 200519200# cm = 18095470m = bytes_to_long(b\"1234567890\")# p*qq = GCD(c1-c2,n)assert n%q == 0pr = n// qassert isPrime(q)p2 = pow(c1,pow(e//2,-1,q-1),q)# print(pow(c1,pow(e//2,-1,q-1),q))# print(pow(823,e,q))# print(823%q,pow(823,2,q))# print(p2,q)# print(mod(p2, q).sqrt(all = True))# p = 7572427786695057270624844967644562609112132599800420296747189080920032359205995588384031542287784540006438555802994008688795974493684400576592403320929717for p in mod(p2, q).sqrt(all = True): for i in range(2): p = int(p) p += i*q # print(p,isPrime(p)) if n%p==0: # print(p) breakp = 7572427786695057270624844967644562609112132599800420296747189080920032359205995588384031542287784540006438555802994008688795974493684400576592403320929717assert isPrime(p)assert isPrime(q)assert n%p==0assert n%q==0 r = n//(p*q)# print(r)assert isPrime(r)assert n%r==0def search(c,p): assert pow(mod(pow(c,pow(e//2,-1,p-1),p), p).sqrt(all = True)[0],e,p)==c return mod(pow(c,pow(e//2,-1,p-1),p), p).sqrt(all = True)for cp,cq,cr in list(product(search(cm,p),search(cm,q),search(cm,r))): print(int(cp)) # input() tmp = CRT([int(cp),int(cq),int(cr)],[p,q,r]) if b\"SECCON\" in long_to_bytes(tmp): print(long_to_bytes(tmp)) # SECCON{being_able_to_s0lve_this_1s_great!}BBBchallfrom Crypto.Util.number import bytes_to_long, getPrimefrom random import randintfrom math import gcdfrom secret import FLAGfrom os import urandomassert len(FLAG) &lt; 100def generate_key(rng, seed): e = rng(seed) while True: for _ in range(randint(10,100)): e = rng(e) p = getPrime(1024) q = getPrime(1024) phi = (p-1)*(q-1) if gcd(e, phi) == 1: break n = p*q return (n, e)def generate_params(): p = getPrime(1024) a = randint(0, p-1) return (p,a)def main(): p,a = generate_params() print(\"[+] The parameters of RNG:\") print(f\"{a=}\") print(f\"{p=}\") b = int(input(\"[+] Inject [b]ackdoor!!: \")) rng = lambda x: (x**2 + a*x + b) % p keys = [] seeds = [] for i in range(5): seed = int(input(\"[+] Please input seed: \")) seed %= p if seed in seeds: print(\"[!] Same seeds are not allowed!!\") exit() seeds.append(seed) n, e = generate_key(rng, seed) if e &lt;= 10: print(\"[!] `e` is so small!!\") exit() keys.append((n,e)) flag = bytes_to_long(FLAG + urandom(16)) for n,e in keys: c = pow(flag, e, n) print(\"[+] Public Key:\") print(f\"{n=}\") print(f\"{e=}\") print(\"[+] Cipher Text:\", c)if __name__ == \"__main__\": main()upsolveç«¶æŠ€æ™‚ç«¶æŠ€æ™‚è€ƒãˆã¦ã„ãŸã“ã¨ã¨ã—ã¦ã¯ã€ã“ã®å•é¡Œã®ç‰¹å¾´ã¨ã—ã¦ $n_i$ åŒå£«ã«å¯¾ã—ã¦ã®å…±é€šãªç´ æ•°ã¯ãªã„ $b$ã§äºŒæ¬¡é–¢æ•°ã‚’æ“ä½œã§ãã‚‹ ãã®äºŒæ¬¡é–¢æ•°ã‹ã‚‰$e$ãŒç”Ÿæˆ FLAGã«å¯¾ã—ã¦128bitã®padding $e$ã¯LCG(2æ¬¡é–¢æ•°)ã‚’é©å½“ã«ç¹°ã‚Šè¿”ã™(10-100å›) $e$ãŒ11ä»¥ä¸ŠãŒè¦‹ãˆãŸã®ã§ã€1ã‹ã‚‰Hastadâ€™s broadcast attack ãŒã§ãã‚‹ã®ã‹ãªãã¨æ€ã„ã¤ã¤ã€åˆã‚ã«11å€‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã‚‰ãã‚Œãã‚Œ$e=11$ã¨å›ºå®šã—ãŸã‚‚ã®ã‚’å–ã£ã¦ãã¦Hastadâ€™s broadcast attack ã‚„ã‚‹ã¨å½“ãŸã‚Šå‰ã§ã™ãŒç­”ãˆã¯å‡ºã¾ã›ã‚“(3. ã®paddingã«ã‚ˆã£ã¦)ã€‚ãªã‚‰ã€$e=12$ã«ã—ã¦2ä¹—æ ¹ã‚’2å›ã€3ä¹—æ ¹ã‚’3å›ã¨ã‚Œã°å‡ºã‚‹ã‹ãªã¨æ€ã„ã¤ã¤å®Ÿè¡Œã™ã‚‹ã¨ã€ãã‚‚ãã‚‚$GCD(e,phi)\\neq 1$ã¨ãªã‚Šãã‚‚ãã‚‚ã§ããªã‹ã£ãŸã€‚ã©ã†ã—ãŸã‚‚ã‚“ã‹ãªã¨æ€ã£ã¦ã„ã‚‹ã¨ã€2æ¬¡é–¢æ•°ã®æ€§è³ªã¨ã—ã¦æœ€å¤§2å€‹ã®è§£ã‚’ã‚‚ã¤ã“ã¨ãŒã‚ã‚Šã€ã•ã‚‰ã«è¨€ãˆã°$b$ã§è§£ã‚’11ã«ã—ã¦ã„ã‚‹ã®ã§ã‚‚ã†1ã¤ã®è§£ã‚‚11ã¨ãªã‚‹ã“ã¨ãŒè¨€ãˆã¾ã™ã€‚ã“ã‚Œã§2ã¤ã®seedã®å€¤ãŒå¾—ã‚‹ã“ã¨ãŒã§ããŸã®ã§ã€æ®‹ã‚Šã¯ä»¥ä¸‹ã®å¼ $\\lim_{n \\rightarrow\\inf} e_{n+1} = e_n^2 + a*e_n +b$ ãªã®ã§ãªã‚“ã‹ã“ã‚Œè¦‹ãŸã“ã¨ã‚ã‚‹ãªãã¨æ€ã„ã¾ã—ã¦ã€‚ã€‚ã€‚å°‘ã—é•ã„ã¾ã™ãŒã‚¤ãƒ¡ãƒ¼ã‚¸ã¨ã—ã¦é©å½“ãªå½¢ã§è¡¨ã™ã¨ã“ã‚“ãªæ„Ÿã˜â€¦ãªã‚‰ã€$\\lim_{n \\rightarrow\\inf} e_{n+1} = e_n$ã§ã‚ã‚‹ã“ã¨ã‚’è¿½åŠ ã—ã¦è€ƒãˆã‚‹ã¨$e_n = e_{n-1} \\neq e_{n-2},\\lim_{n \\rightarrow\\inf} e_{n} = e_{n-2}$ã§ã‚‚å•é¡Œãªã„ã‚ˆãªã¨è€ƒãˆãŸã®ã§é€†é †ã¨ãªã‚‹$n \\rightarrow n-1\\rightarrow n-2$ã§$e$ã®å€¤ã‚’æ±‚ã‚ã‚Œã‚‹ã˜ã‚ƒã‚“â€¦!!ã¨ãªã£ãŸã®ã§ã€å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚ºã«ç§»ã‚Šã¾ã™ã€‚ã“ã“ã§å•é¡ŒãŒç™ºç”Ÿsageã£ã¦.roots()ãŒã‚ã‚Šã¾ã™ã‚ˆã­â€¦æ–¹ç¨‹å¼ã®æ ¹ã‚’æ±‚ã‚ã‚‹ã‚„ã¤â€¦ã‚ã‚Œã®å­˜åœ¨ã‚’å®Œå…¨ã«å¿˜ã‚Œã¦ã„ãŸã®ã§2æ¬¡æ–¹ç¨‹å¼ã®è§£ã®å…¬å¼ã‚’å®Ÿè£…ã—ãŸã®ã§ã™ãŒã€ã“ã‚Œã‚„ã£ã¡ã‚ƒã„ã¾ã—ãŸâ€¦ã‚‚ã†ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ãªã„ã®ã§ã‚ã‚Œãªã‚“ã§ã™ãŒå®Ÿè£…ãƒŸã‚¹ã£ã¦çµ‚ã‚ã‚Šã¾ã—ãŸâ€¦upsolveæ™‚ã¦ã“ã¨ã§ã€sageã®.roots()ã‚’ä½¿ã£ã¦å®Ÿè£…ã—ã¾ã—ãŸâ€¦orzfrom pwn import *from gmpy2 import irootfrom Crypto.Util.number import *from sage.all import *def const_e(x, a, p): return (-x**2 - x*(a-1))%pwhile True: ret = set() def serch_roots(p,a,e,b): PR = PolynomialRing(GF(p),\"x\") x = PR.gen() for i in (x*x +a*x +b -e).roots(): if len(ret)&gt;4: return ret if i[0] in ret: continue ret.add(i[0]) print(\"[+] find \",len(ret)) serch_roots(p,a,int(i[0]),b) return None ns = [] es = [] cts = [] e_ = 11 io = remote( \"BBB.seccon.games\" ,8080) # io = process([\"python3\",\"chall.py\"]) io.recvline() exec(io.recvline().decode()) exec(io.recvline().decode()) io.recvuntil(b\"!!: \") print(\"[+]p\",bin(p)[-9:]) b = const_e(e_,a,p) print(\"fin\") io.sendline(str(b).encode()) li = serch_roots(p,a,e_,b) if li == None: io.close() continue for i in list(li): io.recvuntil(b\" seed: \") io.sendline(str(i).encode()) for i in range(5): io.recvline() exec(io.recvline().decode()) exec(io.recvline().decode()) ns.append(n) es.append(e) cts.append(eval(io.recvline().decode().replace(\"[+] Cipher Text: \",\"\"))) io.close() c = CRT(cts,ns) tmp = iroot(int(c),e_) print(tmp) if tmp[1] == True: print(long_to_bytes(iroot(int(c),e_)[0])) exit()[+] Opening connection to BBB.seccon.games on port 8080: Done[+]p 111011001fin[+] find 1[+] find 2[+] find 3[+] find 4[+] find 5[*] Closed connection to BBB.seccon.games port 8080(mpz(2883019091813529219737035153484934929534955887753874746941092955853444099264575760415715710120591467702376578902084283075705374264225673611778863370445183048344031472894050836959651658562832755850169071594495017590365639338557184317630010978441644681967727625313646557515818101), True)b'SECCON{Can_you_find_d_in_bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbdbbbbbbbbbbbbbbbbbbbbbbbbbbbbb?}\\xf2\\x07\\xb3\\xce\\x19\\xb8\\x8bNH\\xb0\\xa6\\xac\\x10E$u'isufficientchallfrom random import randintfrom Crypto.Util.number import getPrime, bytes_to_longfrom secret import FLAG# f(x,y,z) = a1*x + a2*x^2 + a3*x^3# + b1*y + b2*y^2 + b3*y^3# + c*z + s mod pdef calc_f(coeffs, x, y, z, p): ret = 0 ret += x * coeffs[0] + pow(x, 2, p) * coeffs[1] + pow(x, 3, p)*coeffs[2] ret += y * coeffs[3] + pow(y, 2, p) * coeffs[4] + pow(y, 3, p)*coeffs[5] ret += z * coeffs[6] ret += coeffs[7] return ret % pp = getPrime(512)# [a1, a2, a3, b1, b2, b3, c, s]coeffs = [randint(0, 2**128) for _ in range(8)]key = 0for coeff in coeffs: key &lt;&lt;= 128 key ^= coeffcipher_text = bytes_to_long(FLAG) ^ keyprint(cipher_text)shares = []for _ in range(4): x = randint(0, p) y = randint(0, p) z = randint(0, 2**128) w = calc_f(coeffs, x, y, z, p) packed_share = ((x,y), w) shares.append(packed_share)print(p)print(shares)\tç«¶æŠ€æ™‚$ w = a_1*x + a_2*x^2 + a_3*x^3+ b_1*y + b_2*y^2 + b_3*y^3+ c*z + s \\mod p $ ã€$x,y$ã¯128bitã€$p$ã¯512bitã€ãã‚Œä»¥å¤–ã¯128bitã§å¼ã¯4æœ¬ä¸ãˆã‚‰ã‚Œã¦ã„ã¾ã™ã€‚æ—¢çŸ¥ã®å€¤ã¯ã€ãã‚Œãã‚Œã®å¼ã®$x,y,w$ã ã‘ã§ã€ç›®æ¨™ã¯ä¿‚æ•°$a,b,z,c,s$ã®å¾©å…ƒã¨ãªã‚Šã¾ã™ã€‚ã¯ã˜ã‚ã«ã€ã¾ãNHPãªã®ã§LLLã‹ãªã¨â€¦æ€ã£ã¦æ ¼å­ã‚’çµ„ã¿ã¾ã™ã€‚å…·ä½“çš„ã«çµ„ã‚“ã æ ¼å­ã¯ä»¥ä¸‹ã®ã‚‚ã®ã§ã™ã€‚(ããã§ã‹ã„ã§ã™ãŒ)ç©ºç™½éƒ¨åˆ†ã¯0ã§ã™\\[\\begin{bmatrix} p &amp; &amp; &amp; \\\\ &amp; p &amp;&amp; \\\\ &amp; &amp; p &amp; \\\\ &amp; &amp; &amp; p &amp;&amp;&amp;&amp;\\\\ x_0 &amp; x_1 &amp; x_2 &amp; x_3 &amp; 2^{128}\\\\ x_0^2 &amp; x_1^2 &amp; x_2^2 &amp; x_3^2 &amp;&amp; 2^{128} \\\\ x_0^3 &amp; x_1^3 &amp; x_2^3 &amp; x_3^3 &amp;&amp;&amp; 2^{128} \\\\ y_0 &amp; y_1 &amp; y_2 &amp; y_3 &amp;&amp;&amp;&amp; 2^{128}\\\\ y_1^2 &amp; y_1^2 &amp; y_2^2 &amp; y_3^2 &amp;&amp;&amp;&amp;&amp; 2^{128} \\\\ y_1^3 &amp; y_1^3 &amp; y_2^3 &amp; y_3^3 &amp;&amp;&amp;&amp;&amp;&amp; 2^{128}\\\\ -w_0 &amp; -w_1 &amp; -w_2 &amp; -w_3 &amp;&amp;&amp;&amp;&amp;&amp;&amp; 2^{512} \\\\\\end{bmatrix}\\]ã“ã“ã§ $ 0\\simeq c*z + s = a_1*x + a_2*x^2 + a_3*x^3+ b_1*y + b_2*y^2 + b_3*y^3 -w +kp$ã¨$a,b$ã®ä¿‚æ•°ãŒ128bitãƒ¬ãƒ™ãƒ«ãªã®ã§å¯¾è§’æˆåˆ†ã«$1*2^{128}$ã‚’ã€$w$ã¯ä¸€åº¦ã—ã‹ä½¿ã„ãŸããªã„ã®ã§$1*2^{512}$ã‚’ä¸ãˆã¦ã‚„ã£ã¦LLLã‚’è¡Œã†ã€‚ãã†ã™ã‚‹ã¨ã©ã“ã‹ã®è¡Œãƒ™ã‚¯ãƒˆãƒ«ã«ä»Šå›ç”¨ã„ãŸ$a,b$ã®å€¤ã«$2^{128}$ã•ã‚ŒãŸã‚‚ã®ã¨ã€$2^{512}$ãŒå‡ºã¦ãã‚‹ã®ã§æ¢ã›ã°ä»Šå›ç”¨ã„ãŸå€¤ã‚’æ±‚ã‚ã‚‹ã“ã¨ãŒã§ããŸã€‚ã‚ˆã£ã¦ä»Šå›æ±‚ã¾ã£ãŸä¿‚æ•°ã¯$a,b,c,s$ã®å†…$a,b$ã¨ãªã‚Šæ®‹ã‚Šã®$c,s$ã«ã¤ã„ã¦ã¯åˆ¥é€”æ±‚ã‚ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚ã“ã“ã‹ã‚‰è¡Œåˆ—ã®æˆåˆ†ã‹ã‚‰$c*z_i + s$ã®å€¤ã¯æ±‚ã¾ã‚‹ãŒã™ã¹ã¦ã®å¤‰æ•°ãŒæœªçŸ¥æ•°ã§ã©ã†ã™ã‚‹ã®ã‹ã‚ã‹ã‚‰ãªãã¦è©°ã‚“ã â€¦orzm = matrix(ZZ,N,N)for i in range(4): m[4,i] = x[i] m[5,i] = pow(x[i],2,p) m[6,i] = pow(x[i],3,p) m[7,i] = y[i] m[8,i] = pow(y[i],2,p) m[9,i] = pow(y[i],3,p) m[10,i] = -w[i]for i in range(N): m[i,i] = 2^128 # m[i,i] = 1for i in range(4): m[i,i] = pm[10,10] = 2^512m = m.LLL()upsolveã“ã‚Œã‚’æ±‚ã‚ã‚‹ã®ã¯æ„å¤–ã¨å˜ç´”ã§GCDã§ã—ãŸã€‚(ç«¶æŠ€ä¸­ã‚„ã£ãŸè¨˜æ†¶ã‚ã‚‹ã‚“ã ã‘ã©ãªãâ€¦???)$h_i \\equiv c*z_i + s \\mod p $ã¨ã™ã‚‹ã¨$c,z_i,s$ã¯128bitã§$p$ã¯512bitã‚ˆã‚Šå®Ÿã¯ã€$h_i = c*z_i + s$ã¨ã‚‚è¡¨ã›ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ã€‚æœ€å¤§å…¬ç´„æ•°ã‚’ç”¨ã„ã¦$c = GCD(h_i -h_{i+1},h_{i+1} -h_{i+2})$ã§æ±‚ã¾ã‚Šã¾ã™ã€‚ã€‚ã€‚ã¦ã“ã¨ã§ã€$h$ã®å¼ã«ãŠã„ã¦$c$ã®å€¤ãŒå‡ºã‚‹ã“ã¨ãŒã‚ã‹ã£ãŸã€‚ã“ã“ã§ã€128bitã‚’128bitã§å‰²ã‚‹ã¨å•†ã®å¤§ãã•ã¯ã„ãã¤ã§ã—ã‚‡ã†ã‹â€¦?ç­”ãˆã¯0 or 1 ãªã®ã§ã€ã“ã‚Œã‚’ç”¨ã„ã‚‹ã¨$s$ã‚‚æ±‚ã¾ã‚Šã¾ã™ã€‚$s = h_i\\%c + \\delta_ic$ã€€ã“ã“ã§ã€$\\delta$ã¯0ã‹1ã®æ•°ã§ã™ã€‚ã“ã‚Œã§ã™ã¹ã¦ã®ä¿‚æ•°ãŒå‡ºãã‚ã£ãŸã®ã§keyã‚’å¾©å…ƒã—ã¦flagãŒæ±‚ã¾ã‚Šã¾ã™ã€‚from Crypto.Util.number import *ct = 115139400156559163067983730101733651044517302092738415230761576068368627143021367186957088381449359016008152481518188727055259259438853550911696408473202582626669824350180493062986420292176306828782792330214492239993109523633165689080824380627230327245751549253757852668981573771168683865251547238022125676591p = 8200291410122039687250292442109878676753589397818032770561720051299309477271228768886216860911120846659270343793701939593802424969673253182414886645533851xyw = [((6086926015098867242735222866983726204461220951103360009696454681019399690511733951569533187634005519163004817081362909518890288475814570715924211956186561, 180544606207615749673679003486920396349643373592065733048594170223181990080540522443341611038923128944258091068067227964575144365802736335177084131200721), 358596622670209028757821020375422468786000283337112662091012759053764980353656144756495576189654506534688021724133853284750462313294554223173599545023200), ((1386358358863317578119640490115732907593775890728347365516358215967843845703994105707232051642221482563536659365469364255206757315665759154598917141827974, 4056544903690651970564657683645824587566358589111269611317182863269566520886711060942678307985575546879523617067909465838713131842847785502375410189119098), 7987498083862441578197078091675653094495875014017487290616050579537158854070043336559221536943501617079375762641137734054184462590583526782938983347248670), ((656537687734778409273502324331707970697362050871244803755641285452940994603617400730910858122669191686993796208644537023001462145198921682454359699163851, 7168506530157948082373212337047037955782714850395068869680326068416218527056283262697351993204957096383236610668826321537260018440150283660410281255549702), 1047085825033120721880384312942308021912742666478829834943737959325181775143075576517355925753610902886229818331095595005460339857743811544053574078662507), ((5258797924027715460925283932681628978641108698338452367217155856384763787158334845391544834908979711067046042420593321638221507208614929195171831766268954, 4425317882205634741873988391516678208287005927456949928854593454650522868601946818897817646576217811686765487183061848994765729348913592238613989095356071), 866086803634294445156445022661535120113351818468169243952864826652249446764789342099913962106165135623940932785868082548653702309009757035399759882130676)]x = []y = []w = []for i in range(4): x.append(xyw[i][0][0]) y.append(xyw[i][0][1]) w.append(xyw[i][1])N = 11m = matrix(ZZ,N,N)for i in range(4): m[4,i] = x[i] m[5,i] = pow(x[i],2,p) m[6,i] = pow(x[i],3,p) m[7,i] = y[i] m[8,i] = pow(y[i],2,p) m[9,i] = pow(y[i],3,p) m[10,i] = -w[i]for i in range(N): m[i,i] = 2^128 # m[i,i] = 1for i in range(4): m[i,i] = pm[10,10] = 2^512m = m.LLL()#cz+ scz_s = []coffs = []for k in range(4):\tcz_s.append(abs(m[-1,k]))for k in range(4,N-1):\tcoffs.append(m[-1,k]//2^128)c = GCD(cz_s[0]-cz_s[1],cz_s[1]-cz_s[2])coffs.append(c)s = cz_s[0]%ccoffs.append(s)print(cz_s)print(coffs)key = 0for coff in coffs: key &lt;&lt;= 128 key ^^= coff cipher_text = int(ct) ^^ keyprint(long_to_bytes(cipher_text))b'SECCON{Unfortunately_I_could_not_come_up_with_a_more_difficult_problem_than_last_year_sorry...-6fc18307d3ed2e7673a249abc2e0e22c}'this_is_not_lsbchallfrom Crypto.Util.number import *from flag import flagp = getStrongPrime(512)q = getStrongPrime(512)e = 65537n = p * qphi = (p - 1) * (q - 1)d = pow(e, -1, phi)print(f\"n = {n}\")print(f\"e = {e}\")print(f\"flag_length = {flag.bit_length()}\")# Oops! encrypt without padding!c = pow(flag, e, n)print(f\"c = {c}\")# padding format: 0b0011111111........def check_padding(c): padding_pos = n.bit_length() - 2 m = pow(c, d, n) m = c return (m &gt;&gt; (padding_pos - 8)) == 0xFFwhile True: c = int(input(\"c = \")) print(check_padding(c))ç«¶æŠ€ä¸­ãªã‚“ã‹Downunderctfã®RSA oracle iv ã¨ã‹ sekaictfã®EZmazeã¨ã‹ã§è¦‹ãŸã“ã¨ã‚ã‚‹ãªãã¨æ€ã„ã¤ã¤isufficientã¨åŒã˜æ„Ÿã˜ã§æ ¼å­çµ„ã‚“ã§ã¾ã—ãŸâ€¦from sage.modules.free_module_integer import IntegerLatticefrom pwn import *from Crypto.Util.number import *# Directly taken from rbtree's LLL repository# From https://oddcoder.com/LOL-34c3/, https://hackmd.io/@hakatashi/B1OM7HFVIdef Babai_CVP(mat, target):\tM = IntegerLattice(mat, lll_reduce=True).reduced_basis\tG = M.gram_schmidt()[0]\tdiff = target\tfor i in reversed(range(G.nrows())):\t\tdiff -= M[i] * ((diff * G[i]) / (G[i] * G[i])).round()\treturn target - diffdef solve(mat, lb, ub, weight = None):\tnum_var = mat.nrows()\tnum_ineq = mat.ncols()\tmax_element = 0 \tfor i in range(num_var):\t\tfor j in range(num_ineq):\t\t\tmax_element = max(max_element, abs(mat[i, j]))\tif weight == None:\t\tweight = num_ineq * max_element # sanity checker\tif len(lb) != num_ineq:\t\tprint(\"Fail: len(lb) != num_ineq\")\t\treturn\tif len(ub) != num_ineq:\t\tprint(\"Fail: len(ub) != num_ineq\")\t\treturn\tfor i in range(num_ineq):\t\tif lb[i] &gt; ub[i]:\t\t\tprint(\"Fail: lb[i] &gt; ub[i] at index\", i)\t\t\treturn \t# heuristic for number of solutions\tDET = 0\tif num_var == num_ineq:\t\tDET = abs(mat.det())\t\tnum_sol = 1\t\tfor i in range(num_ineq):\t\t\tnum_sol *= (ub[i] - lb[i])\t\tif DET == 0:\t\t\tprint(\"Zero Determinant\")\t\telse:\t\t\tnum_sol //= DET\t\t\t# + 1 added in for the sake of not making it zero...\t\t\tprint(\"Expected Number of Solutions : \", num_sol + 1)\t# scaling process begins\tmax_diff = max([ub[i] - lb[i] for i in range(num_ineq)])\tapplied_weights = []\tfor i in range(num_ineq):\t\tineq_weight = weight if lb[i] == ub[i] else max_diff // (ub[i] - lb[i])\t\tapplied_weights.append(ineq_weight)\t\tfor j in range(num_var):\t\t\tmat[j, i] *= ineq_weight\t\tlb[i] *= ineq_weight\t\tub[i] *= ineq_weight\t# Solve CVP\ttarget = vector([(lb[i] + ub[i]) // 2 for i in range(num_ineq)])\tresult = Babai_CVP(mat, target)\tfor i in range(num_ineq):\t\tif (lb[i] &lt;= result[i] &lt;= ub[i]) == False:\t\t\tprint(\"Fail : inequality does not hold after solving\")\t\t\tbreak \t# recover x\tfin = None\tif DET != 0:\t\tmat = mat.transpose()\t\tfin = mat.solve_right(result)\t\t## recover your result\treturn result, applied_weights, finwhile True: conn = remote('this-is-not-lsb.seccon.games', 8080) # conn = process([\"python3\",\"problem.py\"]) n = int(conn.recvline().decode().strip().split('n = ')[1]) e = int(conn.recvline().decode().strip().split('e = ')[1]) flag_length = int(conn.recvline().decode().strip().split('flag_length =')[1]) c = int(conn.recvline().decode().strip().split('c = ')[1]) print(n,e,c) print(flag_length) def query(c): conn.sendlineafter(b\"c = \",str(c).encode()) return eval( conn.recvline().decode()) def blinded_query(r, c): return query((pow(r, e, n) * c) % n) rs_and_Us = [] while len(rs_and_Us) &lt; 50: r = randint(1, n) r_ = r if blinded_query(r, c): rs_and_Us.append([r, int(n).bit_length() - 2]) print('got!', len(rs_and_Us)) N = len(rs_and_Us)+1 m = matrix(ZZ,N,N) for i in range(N-1): m[0,i+1] = rs_and_Us[i][0] for i in range(N): m[i,i] = n m[0,0] = 1 ub = [u for _,u in rs_and_Us] sol = solve(m,[0]*N, [flag_length]+ub) print(sol) sol = sol[0] print(sol) print(long_to_bytes(abs(sol))) conn.close() try: if \"SECCON\" in long_to_bytes(abs(sol)): exit() if sol &gt; 2^flag_length: sol = -sol % n print(long_to_bytes(abs(sol))) if \"SECCON\" in long_to_bytes(abs(sol)): exit() except: continueupsolveãŸã ã€ã“ã‚Œã ã¨æ±‚ã¾ã‚‰ãªã‹ã£ãŸã®ã§è‰²ã€…ãªupsolveæ‹è¦‹ã•ã›ã¦ã‚‚ã‚‰ã£ã¦å¾—ãŸã‚¢ã‚¤ãƒ‡ã‚£ã‚¢ã‚’ç”¨ã„ã¦çµ„ã‚“ã§è¦‹ã¾ã—ãŸãŒã©ã‚Œã‚‚ãƒ€ãƒ¡ã§ã—ãŸã€‚ã€‚ã€‚(æ³£)ã‚„ã£ã±ã‚ŠLLLã®ãŠæ°—æŒã¡ã¯é›£ã—ã„ã§ã™ã­ã‡â€¦ã“ã‚Œãªã‚‰å‹•ãã¾ã—ãŸã‚ˆçš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚ã‚Œã°ãŠå¾…ã¡ã—ã¦ã¾ã™ã€‚ã€‚m(_ _)m" }, { "title": "buckeye CTF 2022 writeup", "url": "/posts/buckeye-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-11-07 10:00:00 +0900", "snippet": "åˆã‚ã«Nu1L ctf ã§pocã‹ã‘ãªãã¦æ’ƒæ²ˆã€‚ã€‚ã€‚[crypto] megaxord [312 solve]challbytesã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿solveé †ã«æ¢ç´¢ã—ã¦çµ‚ã‚ã‚Šdef bxor(a,b): return bytes([_a^b for _a in a])f = open(\"megaxord.txt\",\"rb\").read()for i in range(256): if b\"buckeye{\" in bxor(f,i): for x in bxor(f,i).decode().split(\" \"): if \"buckeye{\" in x: print(x) exit() # buckeye{m1gh7y_m0rph1n_w1k1p3d14_p4g3}[crypto] Twin prime RSA [ 167 solve]challimport Crypto.Util.number as cunwhile True: p = cun.getPrime(1024) q = p + 2 if cun.isPrime(q): breakn = p * qe = 0x10001phi = (p - 1) * (q - 1)d = pow(e, -1, phi)FLAG = cun.bytes_to_long(b\"buckeye{?????????????????????????????????????????????????????????????}\")c = pow(FLAG, e, n)assert pow(c, d, n) == FLAGprint(f\"n = {n}\")print(f\"c = {c}\")\"\"\"Output:n = 20533399299284046407152274475522745923283591903629216665466681244661861027880216166964852978814704027358924774069979198482663918558879261797088553574047636844159464121768608175714873124295229878522675023466237857225661926774702979798551750309684476976554834230347142759081215035149669103794924363457550850440361924025082209825719098354441551136155027595133340008342692528728873735431246211817473149248612211855694673577982306745037500773163685214470693140137016315200758901157509673924502424670615994172505880392905070519517106559166983348001234935249845356370668287645995124995860261320985775368962065090997084944099c = 786123694350217613420313407294137121273953981175658824882888687283151735932871244753555819887540529041840742886520261787648142436608167319514110333719357956484673762064620994173170215240263058130922197851796707601800496856305685009993213962693756446220993902080712028435244942470308340720456376316275003977039668016451819131782632341820581015325003092492069871323355309000284063294110529153447327709512977864276348652515295180247259350909773087471373364843420431252702944732151752621175150127680750965262717903714333291284769504539327086686569274889570781333862369765692348049615663405291481875379224057249719713021\"\"\"solveäºŒæ¬¡æ–¹ç¨‹å¼çµ„ã¿ç«‹ã¦ã¦$p,q$æ±‚ã‚ã¦çµ‚ã‚ã‚Šæœ€è¿‘ã‚°ãƒ¬ãƒ–ãƒŠãƒ¼ã§ã‚µãƒœã£ã¦ãŸã‹ã‚‰çœŸé¢ç›®ã«ã‚„ã‚Šã¾ã—ãŸã¾ã‚‹â€¦from Crypto.Util.number import *from gmpy2 import irootn = 20533399299284046407152274475522745923283591903629216665466681244661861027880216166964852978814704027358924774069979198482663918558879261797088553574047636844159464121768608175714873124295229878522675023466237857225661926774702979798551750309684476976554834230347142759081215035149669103794924363457550850440361924025082209825719098354441551136155027595133340008342692528728873735431246211817473149248612211855694673577982306745037500773163685214470693140137016315200758901157509673924502424670615994172505880392905070519517106559166983348001234935249845356370668287645995124995860261320985775368962065090997084944099c = 786123694350217613420313407294137121273953981175658824882888687283151735932871244753555819887540529041840742886520261787648142436608167319514110333719357956484673762064620994173170215240263058130922197851796707601800496856305685009993213962693756446220993902080712028435244942470308340720456376316275003977039668016451819131782632341820581015325003092492069871323355309000284063294110529153447327709512977864276348652515295180247259350909773087471373364843420431252702944732151752621175150127680750965262717903714333291284769504539327086686569274889570781333862369765692348049615663405291481875379224057249719713021p = (-2+iroot(4+4*n,2)[0])//2q =n//passert n == p*qphi = (p-1)*(q-1)e = 0x10001print(long_to_bytes(pow(c, pow(e,-1,phi), n)))# buckeye{B3_TH3R3_OR_B3_SQU4R3__abcdefghijklmonpqrstuvwxyz__0123456789}[crypto] fastfor [ 111 solve]challfrom PIL import Imageimport numpydef check_hash(fi): image = numpy.asarray(Image.open('static/IMG.png')) submission = numpy.asarray(Image.open(fi)) if image.shape != submission.shape: return False same = numpy.bitwise_xor(image, submission) if (numpy.sum(same) == 0): return False im_alt = numpy.fft.fftn(image) in_alt = numpy.fft.fftn(submission) im_hash = numpy.std(im_alt) in_hash = numpy.std(in_alt) if im_hash - in_hash &lt; 1 and im_hash - in_hash &gt; -1: return True return Falsesolve2ã¤ã®ç”»åƒã®å…¥åŠ›ã‹ã‚‰è¿‘ã„æ¨™æº–åå·®ã®å€¤ã‚’æ±‚ã‚ã‚ã‚‰ã—ã„ã§ã™ã€‚ãŠè©¦ã—æ„Ÿè¦šã§IMG.pngã®0,0ãƒãƒ£ãƒ³ã‚¯ã®å€¤ã‚’+1ã—ãŸã‚‚ã®ã‚’çªã£è¾¼ã‚“ã ã‚‰ãƒ•ãƒ©ã‚°å‡ºãŸâ€¦import check_hashfrom PIL import Imageimg2 = Image.open('static/IMG.png')img2.putpixel((0,0),(159, 227, 255, 118))img2.save(\"test.png\")print(check_hash.check_hash(\"test.png\"))# buckeye{D33p_w0Rk_N07_WhY_574ND4RD_d3V}[crypto] powerball [ 78 solve]challimport express from 'express'import http from 'http'import { Server } from 'socket.io'import crypto from 'crypto'function nextRandomNumber () { return (multiplier * seed) % modulus}function areArraysEqual (a, b) { return ( a.length === b.length &amp;&amp; a.every((x, i) =&gt; { return x === b[i] }) )}function seedToBalls (n) { const balls = [] for (let i = 0; i &lt; 10; i++) { balls.push(Number(n % 100n)) n = n / 100n } return balls}const app = express()app.use(express.static('static'))const server = http.createServer(app)const io = new Server(server)const modulus = crypto.generatePrimeSync(128, { safe: true, bigint: true })const multiplier = (2n ** 127n) - 1nlet seed = 2nfor (let i = 0; i &lt; 1024; i++) { seed = nextRandomNumber()}let winningBalls = seedToBalls(seed)let lastLotteryTime = Date.now()setInterval(() =&gt; { seed = nextRandomNumber() winningBalls = seedToBalls(seed) lastLotteryTime = Date.now()}, 60 * 1000)io.on('connection', (socket) =&gt; { socket.ticket = { balls: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], submissionTime: 0 } socket.on('updateRequest', () =&gt; { let flag = '' if ( areArraysEqual(socket.ticket.balls, winningBalls) &amp;&amp; socket.ticket.submissionTime &lt; lastLotteryTime ) { flag = process.env.FLAG } socket.emit('update', { last_winning_seed: seed.toString(), flag: flag }) }) socket.on('submitBalls', (balls) =&gt; { if (!(Array.isArray(balls) &amp;&amp; balls.length === 10)) return for (let i = 0; i &lt; 10; i++) { if (typeof balls[i] !== 'number') return } socket.ticket = { balls: balls, submissionTime: Date.now() } })})server.listen(3000, () =&gt; { console.log('Ready')})const socket = io() // eslint-disable-line no-undeflet seenFlag = falsefunction seedToBalls (n) { const balls = [] for (let i = 0; i &lt; 10; i++) { balls.push(Number(n % 100n)) n = n / 100n } return balls}function handleUpdate (update) { console.log(update) if (update.flag &amp;&amp; !seenFlag) { alert(update.flag) seenFlag = true } const balls = seedToBalls(BigInt(update.last_winning_seed)) for (let i = 0; i &lt; 10; i++) { document.getElementById(`ball${i}`).innerText = balls[i] }}function initSocket () { socket.on('update', handleUpdate) socket.emit('updateRequest') setInterval(() =&gt; { console.log(Date.now() / 1000) socket.emit('updateRequest') }, 5000)}function sendBallsIfAvailable () { const balls = [] for (let i = 0; i &lt; 10; i++) { const a = parseInt(document.getElementById(`input-ball${i}`).value) if (isNaN(a) || a &lt; 0 || a &gt;= 100) return balls.push(a) } console.log(`Submitting balls ${balls}`) socket.emit('submitBalls', balls)}function initInput () { for (let i = 0; i &lt; 10; i++) { document.getElementById(`input-ball${i}`).onkeypress = (event) =&gt; { const n = parseInt(event.key) if (isNaN(n)) return false setTimeout(sendBallsIfAvailable, 100) } document.getElementById(`input-ball${i}`).onpaste = (event) =&gt; { const n = event.clipboardData.getData('Text') if (isNaN(n)) return false setTimeout(sendBallsIfAvailable, 100) } }}initSocket()initInput()solveå€‹äººçš„ã«ã¯node jsã®ä»•æ§˜ã‚’ç†è§£ã™ã‚‹ã®ã«æ™‚é–“ãŒã‹ã‹ã£ãŸâ€¦(console.logä½¿ãˆã‚‹ã¨æ€ã£ã¦ãªãã¦ã“ã‚ŒãŒeasyãªã‚ã‘ãªã„ã‚„ã‚ã¨ã‹æ€ã£ã¦ãŸã¨ã‹ã€æ€ã£ã¦ãªã‹ã£ãŸã¨ã‹orz)ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§å‹•ã„ã¦ã„ã‚‹ã®ã¯main.jsãªã®ã§console.logã‹ã‚‰update.last_winning_seedã‚’æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã‚ˆã£ã¦äºŒé …é–“æ¼¸åŒ–å¼$ball_{n+1} \\equiv a*ball_n \\pmod p$ã‹ã‚‰$p$ã®å€¤ãŒæ±‚ã¾ã‚‹ã€‚ã“ã®å•é¡Œã®ç›®æ¨™ã¨ã—ã¦ã€ç”»é¢ã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ä¹±æ•°ã‚ˆã‚Šã‚‚å¾Œã®ä¹±æ•°ã‚’æ±‚ã‚ã¦å…¥åŠ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ã€ä»ŠãŒä½•é …ç›®ã‹èª¿ã¹ã¦ã‚„ã‚Œã°OKfrom sage.all import *from Crypto.Util.number import *def int_to_ball(a): ret = [] for i in range(10): # print(a%100) ret.append(a%100) a = a//100 return ret[::-1]a = 2**127 -1s1 = 38386045261155976433540741815806908550s2 = 43312535513384515088100925378630654634s3 = 201038737730550603713123190637463026163nowball = 76544625579486203475251392218240548059p = factor(gcd(s2*a-s3,s1*a-s2))[-1][0]nowball = GF(p)(nowball)win = GF(p)(2)a = GF(p)(a)for i in range(2**26): if int(win)==int(nowball): print(int_to_ball(int(win))[::-1]) win = win*a print(int_to_ball(int(win))[::-1]) win = win*a print(int_to_ball(int(win))[::-1]) win = win*a print(int_to_ball(int(win))[::-1]) break win = win*a# buckeye{y3ah_m4yb3_u51nG_A_l1N34r_c0nGru3Nt1al_G3n3r4t0r_f0r_P0w3rB4lL_wA5nt_tH3_b3st_1d3A}[crypto] bounce [ 97 solve]challimport randomwith open('sample.txt') as file: line = file.read()with open('flag.txt') as file: flag = file.read()samples = [line[i:i+28] for i in range(0, len(line) - 1 - 28, 28)]samples.insert(random.randint(0, len(samples) - 1), flag)i = 0while len(samples) &lt; 40: samples.append(samples[len(samples) - i - 2]) i = random.randint(0, len(samples) - 1)encrypted = []for i in range(len(samples)): x = samples[i] if i &lt; 10: nonce = str(i) * 28 else: nonce = str(i) * 14 encrypted.append(''.join(str(ord(a) ^ ord(b)) + ' ' for a,b in zip(x, nonce)))with open('output.txt', 'w') as file: for i in range(0, 4): file.write('input: ' + samples[i] + '\\noutput: ' + encrypted[i] + '\\n') file.write('\\n') for i in range(4, len(samples)): file.write('\\ninput: ???\\n' + 'output: ' + encrypted[i])solveãã®ã¾ã¾çªã£è¾¼ã‚“ã§çµ‚ã‚ã‚Šâ€¦f = open(\"output.txt\").readlines()part1_input = [f[i][7:-1] for i in range(0,8,2)]part1_output = [[ k for k in f[i+1][8:-2].split(\" \") ]for i in range(0,8,2)]part2_output = [[ int(k) for k in f[i+1][8:-2].split(\" \") ]for i in range(10,len(f),2)]output = part1_output+part2_outputfor i in range(len(output)): x = output[i] if i &lt; 10: nonce = str(i) * 28 else: nonce = str(i) * 14 if \"eye\" in ''.join(chr(int(a) ^ ord(b)) for a,b in zip(x, nonce)): print(''.join(chr(int(a) ^ ord(b)) for a,b in zip(x, nonce)))# buckeye{some_say_somefish:)}[crypto] SSSHIT [ 41 solve]cahllimport Crypto.Util.number as cunimport randomimport astdef evaluate_polynomial(polynomial: list, x: int, p: int): return ( sum( (coefficient * pow(x, i, p)) % p for i, coefficient in enumerate(polynomial) ) % p )N_SHARES = 3def main(): print( f\"I wrote down a list of people who are allowed to get the flag and split it into {N_SHARES} using Shamir's Secret Sharing.\" ) MESSAGE = cun.bytes_to_long(b\"qxxxb, BuckeyeCTF admins, and NOT YOU\") p = cun.getPrime(512) polynomial = [MESSAGE] + [random.randrange(1, p) for _ in range(N_SHARES - 1)] points = [(i, evaluate_polynomial(polynomial, i, p)) for i in range(1, N_SHARES + 1)] print(\"Your share is:\") print(points[0]) print(\"The other shares are:\") for i in range(1, len(points)): print(points[i]) print() print(\"Now submit your share for reconstruction:\") your_input = ast.literal_eval(input(\"&gt;&gt;&gt; \")) if ( type(your_input) is not tuple or len(your_input) != 2 or type(your_input[0]) is not int or type(your_input[1]) is not int or your_input[0] != 1 or not (0 &lt;= your_input[1] &lt; p) ): print(\"Bad input\") return points[0] = your_input xs = [point[0] for point in points] ys = [point[1] for point in points] y_intercept = 0 for j in range(N_SHARES): product = 1 for i in range(N_SHARES): if i != j: product = (product * xs[i] * pow(xs[i] - xs[j], -1, p)) % p y_intercept = (y_intercept + ys[j] * product) % p reconstructed_message = cun.long_to_bytes(y_intercept) if reconstructed_message == b\"qxxxb, BuckeyeCTF admins, and ME\": print(\"Here's your flag:\") print(\"buckeye{?????????????????????????????????????????}\") else: print(f\"Sorry, only these people can see the flag: {reconstructed_message}\")main()solve2ã¤ã®ä¹±æ•°ã‚’$r_1,r_2$ã¨ã—ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’$m$ã¨ã™ã‚‹ã¨æœ€åˆã®å¤šé …å¼ã®éƒ¨åˆ†ã§$points_i = i^{2} *r_2 + i*r_1 + m \\pmod p, (1 \\leq i\\leq 3)$ã‚’æ±‚ã‚ã¦ã„ã‚‹ãŒã€ãã‚Œãã‚Œã®pointsã®å€¤ã¯ã‚ã‹ã‚‹ã®ã§ãã‚Œã‚’ã†ã¾ãç”¨ã„ã‚‹ã“ã¨ã§$p$ã‚’å¾©å…ƒã§ãã€ãã“ã‹ã‚‰$r_1,r_2$ã‚’æ±‚ã‚ã‚‰ã‚Œã‚‹ã€‚æš—å·ã‚’æ±‚ã‚ã¦ã„ã‚‹éƒ¨åˆ†ã‚’é–¢æ•°ã¨ã—ã¦ã€å…¥åŠ›ã«ã€$points_i,i$ã‚’ä¸ãˆ$f(points_1,points_2,points_3,1,2,3)$ã¨ã§ãã‚‹ã€‚ã“ã“ã§$points_1$ã¯ã“ã¡ã‚‰ã§æŒ‡å®šã§ãã‚‹ä»»æ„ã®å€¤ã§å‡ºåŠ›ã¨ã—ã¦â€qxxxb, BuckeyeCTF admins, and MEâ€ã‚’å‡ºã™ã‚ˆã†ã«å¤‰åŒ–ã•ã›ã¦ã‚„ã‚Œã°OKfrom pwn import *from Crypto.Util.number import *from sage.all import *io = remote(\"pwn.chall.pwnoh.io\" ,13382)# io = process([\"python3\",\"chall.py\"])#295 bitMESSAGE = bytes_to_long(b\"qxxxb, BuckeyeCTF admins, and NOT YOU\")#255 bitreconstructed_message = bytes_to_long(b\"qxxxb, BuckeyeCTF admins, and ME\")def recover(points): y = points[1] p = factor(y[2]-3*y[1]+3*y[0]-MESSAGE)[-1][0] assert int(p).bit_length() == 512 return pdef catch(): points = [[],[]] io.recvline() io.recvline() p = eval(io.recvline().decode()) points[0].append(p[0]) points[1].append(p[1]) io.recvline() p = eval(io.recvline().decode()) points[0].append(p[0]) points[1].append(p[1]) p = eval(io.recvline().decode()) points[0].append(p[0]) points[1].append(p[1]) return pointsdef calc(points,p): N_SHARES = 3 xs = points[0] y = [0]+points[1][1:] pro = 0 pro += (xs[0]*pow(xs[0]-xs[1],-1,p)*xs[2]*pow(xs[2]-xs[1],-1,p)*y[1])%p pro += (xs[0]*pow(xs[0]-xs[2],-1,p)*xs[1]*pow(xs[1]-xs[2],-1,p)*y[2])%p y0 = ((reconstructed_message - pro)*pow(xs[1]*pow(xs[1]-xs[0],-1,p)*xs[2]*pow(xs[2]-xs[0],-1,p),-1,p))%p return y0points = catch()p = recover(points)io.recvuntil(b\"&gt; \")y0 = calc(points,int(p))io.sendline(f\"(1,{y0})\".encode())io.interactive()# buckeye{tH1s_SSS_sch3Me_c0uLd_u5e_s0M3_S1gna7Ur3s}[crypto] Quad prime RSA [ 23 solve]challimport Crypto.Util.number as cunp = cun.getPrime(500)while True: q = cun.getPrime(1024) r = q + 2 if cun.isPrime(r): breaks = cun.getPrime(500)n_1 = p * qn_2 = r * se = 0x10001d_1 = pow(e, -1, (p - 1) * (q - 1))d_2 = pow(e, -1, (r - 1) * (s - 1))FLAG = cun.bytes_to_long(b\"buckeye{??????????????????????????????????????????????????????????????????????}\")c_1 = pow(FLAG, e, n_1)c_2 = pow(FLAG, e, n_2)assert pow(c_1, d_1, n_1) == FLAGassert pow(c_2, d_2, n_2) == FLAGprint(f\"n_1 = {n_1}\")print(f\"n_2 = {n_2}\")print(f\"c_1 = {c_1}\")print(f\"c_2 = {c_2}\")\"\"\"Output:n_1 = 266809852588733960459210318535250490646048889879697803536547660295087424359820779393976863451605416209176605481092531427192244973818234584061601217275078124718647321303964372896579957241113145579972808278278954608305998030194591242728217565848616966569801983277471847623203839020048073235167290935033271661610383018423844098359553953309688771947405287750041234094613661142637202385185625562764531598181575409886288022595766239130646497218870729009410265665829n_2 = 162770846172885672505993228924251587431051775841565579480252122266243384175644690129464185536426728823192871786769211412433986353757591946187394062238803937937524976383127543836820456373694506989663214797187169128841031021336535634504223477214378608536361140638630991101913240067113567904312920613401666068950970122803021942481265722772361891864873983041773234556100403992691699285653231918785862716655788924038111988473048448673976046224094362806858968008487c_1 = 90243321527163164575722946503445690135626837887766380005026598963525611082629588259043528354383070032618085575636289795060005774441837004810039660583249401985643699988528916121171012387628009911281488352017086413266142218347595202655520785983898726521147649511514605526530453492704620682385035589372309167596680748613367540630010472990992841612002290955856795391675078590923226942740904916328445733366136324856838559878439853270981280663438572276140821766675c_2 = 111865944388540159344684580970835443272640009631057414995719169861041593608923140554694111747472197286678983843168454212069104647887527000991524146682409315180715780457557700493081056739716146976966937495267984697028049475057119331806957301969226229338060723647914756122358633650004303172354762801649731430086958723739208772319851985827240696923727433786288252812973287292760047908273858438900952295134716468135711755633215412069818249559715918812691433192840\"\"\"solveå°‘ã—å¼å¤‰å½¢ã—ã¦ã‚„ã‚‹ã¨$n_1 = p*q, n_2 = (q+2)*r $ã¨ãªã‚Šå°‘ã—å±•é–‹ã—ã¦$n_1 = p*q, n_2 = q*r + 2*r $ã“ã‚Œã¯$n_i = p_i*q + r_i$ã®å½¢ã§è¡¨ã›ã‚Œã‚‰ã‚Œã‚‹ã®ã§ã€Approximate GCD Problemã¨è¦‹ã¦è§£ãã“ã¨ãŒã§ãã¾ã™â€¦scriptã¯ã“ã‚Œã‚’ä½¿ã„ã¾ã—ãŸã€‚ä¾¿åˆ©â€¦!!å®Ÿéš›ã¯é€£åˆ†æ•°ã‚’æƒ³å®šã—ã¦ã„ãŸãã†â€¦???ãªã‚‹ã»ã©â€¦n_1 = 266809852588733960459210318535250490646048889879697803536547660295087424359820779393976863451605416209176605481092531427192244973818234584061601217275078124718647321303964372896579957241113145579972808278278954608305998030194591242728217565848616966569801983277471847623203839020048073235167290935033271661610383018423844098359553953309688771947405287750041234094613661142637202385185625562764531598181575409886288022595766239130646497218870729009410265665829n_2 = 162770846172885672505993228924251587431051775841565579480252122266243384175644690129464185536426728823192871786769211412433986353757591946187394062238803937937524976383127543836820456373694506989663214797187169128841031021336535634504223477214378608536361140638630991101913240067113567904312920613401666068950970122803021942481265722772361891864873983041773234556100403992691699285653231918785862716655788924038111988473048448673976046224094362806858968008487c_1 = 90243321527163164575722946503445690135626837887766380005026598963525611082629588259043528354383070032618085575636289795060005774441837004810039660583249401985643699988528916121171012387628009911281488352017086413266142218347595202655520785983898726521147649511514605526530453492704620682385035589372309167596680748613367540630010472990992841612002290955856795391675078590923226942740904916328445733366136324856838559878439853270981280663438572276140821766675c_2 = 111865944388540159344684580970835443272640009631057414995719169861041593608923140554694111747472197286678983843168454212069104647887527000991524146682409315180715780457557700493081056739716146976966937495267984697028049475057119331806957301969226229338060723647914756122358633650004303172354762801649731430086958723739208772319851985827240696923727433786288252812973287292760047908273858438900952295134716468135711755633215412069818249559715918812691433192840from Crypto.Util.number import *# n1 = q*p + 0*s# n2 = (q+2)+r = q*s + 2*s# I use https://github.com/jvdsn/crypto-attacks/blob/master/attacks/acd/ol.pydef attack(x, rho): \"\"\" Solves the ACD problem using the orthogonal based approach. More information: Galbraith D. S. et al., \"Algorithms for the Approximate Common Divisor Problem\" (Section 4) :param x: the x samples, with xi = p * qi + ri :param rho: the bit length of the r values :return: the secret integer p and a list containing the r values, or None if p could not be found \"\"\" def symmetric_mod(x, m): \"\"\" Computes the symmetric modular reduction. :param x: the number to reduce :param m: the modulus :return: x reduced in the interval [-m/2, m/2] \"\"\" return int((x + m + m // 2) % m) - int(m // 2) assert len(x) &gt;= 2, \"At least two x values are required.\" R = 2 ** rho B = matrix(ZZ, len(x), len(x) + 1) for i, xi in enumerate(x): B[i, 0] = xi B[i, i + 1] = R B = B.LLL() K = B.submatrix(row=0, col=1, nrows=len(x) - 1, ncols=len(x)).right_kernel() q = K.an_element() r0 = symmetric_mod(x[0], q[0]) p = abs((x[0] - r0) // q[0]) r = [symmetric_mod(xi, p) for xi in x] if all(-R &lt; ri &lt; R for ri in r): return int(p), r q,s = attack([n_1,n_2], 513)p = n_1//qphi = (p-1)*(q-1)e = 0x10001print(long_to_bytes(int(pow(c_1, pow(e,-1,phi), n_1))))# buckeye{I_h0p3_y0u_us3D_c0nt1nu3d_fr4ct10Ns...th4nk5_d0R5A_f0r_th3_1nsp1r4t10n}" }, { "title": "ASIS CTF 2022 writeup", "url": "/posts/ASIS-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-10-15 15:59:00 +0900", "snippet": "åˆã‚ã«ASISã§ã™ã€‚ç¥­ã‚Šã¨è¢«ã£ã¦æ­»ã¬ã‹ã¨æ€ã„ã¾ã—ãŸã¾ã‚‹ã€‚ã€‚[crypto] Binnedã€€[148 solve]chall#!/usr/bin/env python3from Crypto.Util.number import *from gensafeprime import *from flag import flagdef keygen(nbit):\tp, q = [generate(nbit) for _ in range(2)]\treturn (p, q)def encrypt(m, pubkey):\treturn pow(pubkey + 1, m, pubkey ** 3)p, q = keygen(512)n = p * qflag = bytes_to_long(flag)enc = encrypt(flag, n)print(f'pubkey = {n}')print(f'enc = {enc}')solveencryptã§$enc = (pubkey+1)^m \\pmod {pubkey^3}$ ã§æš—å·ã•ã‚Œã¦ã„ã‚‹ã®ã§å¼å¤‰å½¢ã‚’æ–½ã™ã€‚\\(enc =(pub+1)^m \\pmod {pub^3} \\\\= \\sum_{i=0}^m \\ _m C_i(pub^i+1^{m-i}) \\pmod {pub^3}\\\\= 1 +m*pub + \\frac{m*(m-1)}{2}pub^2\\\\\\)ã¨ãªã‚‹ã®ã§ã€æ–¹ç¨‹å¼ã‚’è§£ã„ã¦ã‚„ã‚Œã°$m$ãŒæ±‚ã¾ã‚‹ã€‚from Crypto.Util.number import *pubkey = 125004899806380680278294077957993138206121343727674199724251084023100054797391533591150992663742497532376954423241741439218367086541339504325939051995057848301514908377941815605487168789148131591458301036686411659334843972203243490288676763861925647147178902977362125434420265824374952540259396010995154324589enc = 789849126571263315208956108629196540107771075292285804732934458641661099043398300667318883764744131397353851782194467024270666326116745519739176492710750437625345677766980300328542459318943175684941281413218985938348407537978884988013947538034827562329111515306723274989323212194585378159386585826998838542734955059450048745917640814983343040930383529332576453845724747105810109832978045135562492851617884175410194781236450629682032219153517122695586503298477875749138129517477339813480115293124316913331705913455692462482942654717828006590051944205639923326375814299624264826939725890226430388059890231323791398412019416647826367964048142887158552454494856771139750458462334678907791079639005383932256589768726730285409763583606927779418528562990619985840033479201147509241313757191997545174262930707521451438204766627975109619779824255444258160PR.&lt;m,n&gt; = QQ[]polys = [ 2*m*n + (m^2 - m )*n*n - 2 *(enc -1) , pubkey - n,]I = Ideal(polys)ans = I.variety(ring=ZZ)[0]print(ans)m, n = ans[m], ans[n]print(long_to_bytes(m))[crypto] Chaffymaskingã€€[61 solve]chall#!/usr/bin/env python3import numpy as npimport binasciiimport os, sysfrom flag import FLAGdef die(*args):\tpr(*args)\tquit()def pr(*args):\ts = \" \".join(map(str, args))\tsys.stdout.write(s + \"\\n\")\tsys.stdout.flush()def sc(): \treturn sys.stdin.buffer.readline()def pad(inp, length):\tresult = inp + os.urandom(length - len(inp))\treturn resultdef byte_xor(a, b):\treturn bytes(_a ^ _b for _a,_b in zip(a,b)) def chaffy_mask(salt, LTC, m, n):\tq = n ** 2\thalf1_salt = salt[:m // 8]\thalf2_salt = salt[m // 8:]\txor_salts = int.from_bytes(byte_xor(half1_salt, half2_salt), \"big\")\tif xor_salts == 0:\t\thalf1_salt = byte_xor(half1_salt, os.urandom(m))\thalf1_binStr = \"{:08b}\".format(int(half1_salt.hex(),16))\tif(len(half1_binStr) &lt; m):\t\thalf1_binStr = \"0\" * (m - len(half1_binStr)%m) + half1_binStr\thalf2_binStr = \"{:08b}\".format(int(half2_salt.hex(),16))\tif(len(half2_binStr) &lt; m):\t\thalf2_binStr = \"0\" * (m - len(half2_binStr)%m) + half2_binStr\t\tvec_1 = np.array(list(half1_binStr), dtype=int)\tvec_1 = np.reshape(vec_1, (m,1))\tvec_2 = np.array(list(half2_binStr), dtype=int)\tvec_2 = np.reshape(vec_2, (m,1))\t\tout_1 = LTC.dot(vec_1) % q\tout_2 = LTC.dot(vec_2) % q\t\tflag_vector = np.array([ord(i) for i in FLAG])\tflag_vector = np.reshape(flag_vector, (n,1))\tmasked_flag = (flag_vector ^ out_1 ^ out_2) % 256\tmasked_flag = np.reshape(masked_flag, (n,))\tmasked_flag = ''.join([hex(_)[2:].zfill(2) for _ in masked_flag])\treturn masked_flag.encode('utf-8')def main():\tborder = \"|\"\tpr(border*72)\tpr(border, \" Welcome to chaffymask combat, we implemented a masking method to \", border)\tpr(border, \" hide our secret. Masking is done by your 1024 bit input salt. Also \", border)\tpr(border, \" I noticed that there is a flaw in my method. Can you abuse it and \", border)\tpr(border, \" get the flag? In each step you should send salt and get the mask. \", border)\tpr(border*72)\tm, n = 512, 64 \tIVK = [\t3826, 476, 3667, 2233, 1239, 1166, 2119, 2559, 2376, 1208, 2165, 2897, 830, 529, 346, 150, 2188, 4025, \t3667, 1829, 3987, 952, 3860, 2574, 959, 1394, 1481, 2822, 3794, 2950, 1190, 777, 604, 82, 49, 710, 1765, \t3752, 2970, 952, 803, 873, 2647, 2643, 1096, 1202, 2236, 1492, 3372, 2106, 1868, 535, 161, 3143, 3370, \t1, 1643, 2147, 2368, 3961, 1339, 552, 2641, 3222, 2505, 3449, 1540, 2024, 618, 1904, 314, 1306, 3173, \t4040, 1488, 1339, 2545, 2167, 394, 46, 3169, 897, 4085, 4067, 3461, 3444, 118, 3185, 2267, 3239, 3612, \t2775, 580, 3579, 3623, 1721, 189, 650, 2755, 1434, 35, 3167, 323, 589, 3410, 652, 2746, 2787, 3665, 828, \t3200, 1450, 3147, 720, 3741, 1055, 505, 2929, 1423, 3629, 3, 1269, 4066, 125, 2432, 3306, 4015, 2350, \t2154, 2623, 1304, 493, 763, 1765, 2608, 695, 30, 2462, 294, 3656, 3231, 3647, 3776, 3457, 2285, 2992, \t3997, 603, 2342, 2283, 3029, 3299, 1690, 3281, 3568, 1927, 2909, 1797, 1675, 3245, 2604, 1272, 1146, \t3301, 13, 3712, 2691, 1097, 1396, 3694, 3866, 2066, 1946, 3476, 1182, 3409, 3510, 2920, 2743, 1126, 2154, \t3447, 1442, 2021, 1748, 1075, 1439, 3932, 3438, 781, 1478, 1708, 461, 50, 1881, 1353, 2959, 1225, 1923, \t1414, 4046, 3416, 2845, 1498, 4036, 3899, 3878, 766, 3975, 1355, 2602, 3588, 3508, 3660, 3237, 3018, \t1619, 2797, 1823, 1185, 3225, 1270, 87, 979, 124, 1239, 1763, 2672, 3951, 984, 869, 3897, 327, 912, 1826, \t3354, 1485, 2942, 746, 833, 3968, 1437, 3590, 2151, 1523, 98, 164, 3119, 1161, 3804, 1850, 3027, 1715, \t3847, 2407, 2549, 467, 2029, 2808, 1782, 1134, 1953, 47, 1406, 3828, 1277, 2864, 2392, 3458, 2877, 1851, \t1033, 798, 2187, 54, 2800, 890, 3759, 4085, 3801, 3128, 3788, 2926, 1983, 55, 2173, 2579, 904, 1019, \t2108, 3054, 284, 2428, 2371, 2045, 907, 1379, 2367, 351, 3678, 1087, 2821, 152, 1783, 1993, 3183, 1317, \t2726, 2609, 1255, 144, 2415, 2498, 721, 668, 355, 94, 1997, 2609, 1945, 3011, 2405, 713, 2811, 4076, \t2367, 3218, 1353, 3957, 2056, 881, 3420, 1994, 1329, 892, 1577, 688, 134, 371, 774, 3855, 1461, 1536, \t1824, 1164, 1675, 46, 1267, 3652, 67, 3816, 3169, 2116, 3930, 2979, 3166, 3944, 2252, 2988, 34, 873, \t1643, 1159, 2822, 1235, 2604, 888, 2036, 3053, 971, 1585, 2439, 2599, 1447, 1773, 984, 261, 3233, 2861, \t618, 465, 3016, 3081, 1230, 1027, 3177, 459, 3041, 513, 1505, 3410, 3167, 177, 958, 2118, 326, 31, 2663, \t2026, 2549, 3026, 2364, 1540, 3236, 2644, 4050, 735, 280, 798, 169, 3808, 2384, 3497, 1759, 2415, 3444, \t1562, 3472, 1151, 1984, 2454, 3167, 1538, 941, 1561, 3071, 845, 2824, 58, 1467, 3807, 2191, 1858, 106, \t3847, 1326, 3868, 2787, 1624, 795, 3214, 1932, 3496, 457, 2595, 3043, 772, 2436, 2160, 3428, 2005, 2597, \t1932, 101, 3528, 1698, 3663, 900, 3298, 1872, 1179, 3987, 3695, 3561, 1762, 3785, 3005, 2574, 6, 1524, \t2738, 1753, 2350, 558, 800, 3782, 722, 886, 2176, 3050, 221, 1925, 564, 1271, 2535, 3113, 1310, 2098, \t3011, 964, 3281, 6, 1326, 741, 189, 2632, 373, 1176, 548, 64, 1445, 2376, 1524, 2690, 1316, 2304, 1336, \t2257, 3227, 2542, 3911, 3460\t]\tLTC = np.zeros([n, m], dtype=(int))\tLTC[0,:] = IVK\tfor i in range(1, n):\t\tfor j in range(m // n + 1):\t\t\tLTC[i,j*n:(j+1)*n] = np.roll(IVK[j*n:(j+1)*n], i)\tfor _ in range(5):\t\tpr(border, \"Give me your salt: \")\t\tSALT = sc()[:-1]\t\tSALT = pad(SALT, m // 4)\t\tMASKED_FLAG = chaffy_mask(SALT, LTC, m, n)\t\tpr(border, f'masked_flag = {MASKED_FLAG}')if __name__ == '__main__':\tmain()solveæ°—ã«ã™ã¹ããªã®ã¯ã€ãƒ©ãƒ³ãƒ€ãƒ ãŒå…¥ã‚‹éƒ¨åˆ†ã®ä»¥ä¸‹ã®äºŒã‹æ‰€def pad(inp, length):\tresult = inp + os.urandom(length - len(inp))\treturn result\t# line 33xor_salts = int.from_bytes(byte_xor(half1_salt, half2_salt), \"big\")if xor_salts == 0: half1_salt = byte_xor(half1_salt, os.urandom(m))padé–¢æ•°ã¯$length = len(inp)$ã§ãƒ©ãƒ³ãƒ€ãƒ æ€§ãŒæ¶ˆå»ã§ãã€xor_saltsã¯ $half1salt \\neq half2salt$ã«ã™ã‚Œã°ã„ã„ã€‚ã‚ã¨ã¯MITHã¿ãŸãä¸Šã‹ã‚‰$out1 ,out2$ãŒã€ä¸‹ã‹ã‚‰$maskedflag$ãŒæ±‚ã¾ã‚‹ã®ã§é †ã«é€†ç®—ã—ã¦ä»¥ä¸‹ã®xorã§ç­”ãˆã‚’å‡ºã›ã°ã„ã„masked_flag = (flag_vector ^ out_1 ^ out_2) % 256ãŸã ã€ãªã‚“ã§5å›ã‚‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ä»˜ã—ã¦ã‚‹ã®ã‹â€¦import numpy as npimport binasciiimport os, sysfrom pwn import *io = remote(\"65.21.255.31\" ,31377)# io = process([\"python3\",'chaffymasking.py'])io.recvuntil(b\"| Gi\")def send(slt): io.recvline() io.sendline(slt) # print(io.recvline()) # io.interactive() masked_flag = eval(io.recvline(None).decode()[16:]) return masked_flagm, n = 512, 64 IVK = [\t3826, 476, 3667, 2233, 1239, 1166, 2119, 2559, 2376, 1208, 2165, 2897, 830, 529, 346, 150, 2188, 4025, \t3667, 1829, 3987, 952, 3860, 2574, 959, 1394, 1481, 2822, 3794, 2950, 1190, 777, 604, 82, 49, 710, 1765, \t3752, 2970, 952, 803, 873, 2647, 2643, 1096, 1202, 2236, 1492, 3372, 2106, 1868, 535, 161, 3143, 3370, \t1, 1643, 2147, 2368, 3961, 1339, 552, 2641, 3222, 2505, 3449, 1540, 2024, 618, 1904, 314, 1306, 3173, \t4040, 1488, 1339, 2545, 2167, 394, 46, 3169, 897, 4085, 4067, 3461, 3444, 118, 3185, 2267, 3239, 3612, \t2775, 580, 3579, 3623, 1721, 189, 650, 2755, 1434, 35, 3167, 323, 589, 3410, 652, 2746, 2787, 3665, 828, \t3200, 1450, 3147, 720, 3741, 1055, 505, 2929, 1423, 3629, 3, 1269, 4066, 125, 2432, 3306, 4015, 2350, \t2154, 2623, 1304, 493, 763, 1765, 2608, 695, 30, 2462, 294, 3656, 3231, 3647, 3776, 3457, 2285, 2992, \t3997, 603, 2342, 2283, 3029, 3299, 1690, 3281, 3568, 1927, 2909, 1797, 1675, 3245, 2604, 1272, 1146, \t3301, 13, 3712, 2691, 1097, 1396, 3694, 3866, 2066, 1946, 3476, 1182, 3409, 3510, 2920, 2743, 1126, 2154, \t3447, 1442, 2021, 1748, 1075, 1439, 3932, 3438, 781, 1478, 1708, 461, 50, 1881, 1353, 2959, 1225, 1923, \t1414, 4046, 3416, 2845, 1498, 4036, 3899, 3878, 766, 3975, 1355, 2602, 3588, 3508, 3660, 3237, 3018, \t1619, 2797, 1823, 1185, 3225, 1270, 87, 979, 124, 1239, 1763, 2672, 3951, 984, 869, 3897, 327, 912, 1826, \t3354, 1485, 2942, 746, 833, 3968, 1437, 3590, 2151, 1523, 98, 164, 3119, 1161, 3804, 1850, 3027, 1715, \t3847, 2407, 2549, 467, 2029, 2808, 1782, 1134, 1953, 47, 1406, 3828, 1277, 2864, 2392, 3458, 2877, 1851, \t1033, 798, 2187, 54, 2800, 890, 3759, 4085, 3801, 3128, 3788, 2926, 1983, 55, 2173, 2579, 904, 1019, \t2108, 3054, 284, 2428, 2371, 2045, 907, 1379, 2367, 351, 3678, 1087, 2821, 152, 1783, 1993, 3183, 1317, \t2726, 2609, 1255, 144, 2415, 2498, 721, 668, 355, 94, 1997, 2609, 1945, 3011, 2405, 713, 2811, 4076, \t2367, 3218, 1353, 3957, 2056, 881, 3420, 1994, 1329, 892, 1577, 688, 134, 371, 774, 3855, 1461, 1536, \t1824, 1164, 1675, 46, 1267, 3652, 67, 3816, 3169, 2116, 3930, 2979, 3166, 3944, 2252, 2988, 34, 873, \t1643, 1159, 2822, 1235, 2604, 888, 2036, 3053, 971, 1585, 2439, 2599, 1447, 1773, 984, 261, 3233, 2861, \t618, 465, 3016, 3081, 1230, 1027, 3177, 459, 3041, 513, 1505, 3410, 3167, 177, 958, 2118, 326, 31, 2663, \t2026, 2549, 3026, 2364, 1540, 3236, 2644, 4050, 735, 280, 798, 169, 3808, 2384, 3497, 1759, 2415, 3444, \t1562, 3472, 1151, 1984, 2454, 3167, 1538, 941, 1561, 3071, 845, 2824, 58, 1467, 3807, 2191, 1858, 106, \t3847, 1326, 3868, 2787, 1624, 795, 3214, 1932, 3496, 457, 2595, 3043, 772, 2436, 2160, 3428, 2005, 2597, \t1932, 101, 3528, 1698, 3663, 900, 3298, 1872, 1179, 3987, 3695, 3561, 1762, 3785, 3005, 2574, 6, 1524, \t2738, 1753, 2350, 558, 800, 3782, 722, 886, 2176, 3050, 221, 1925, 564, 1271, 2535, 3113, 1310, 2098, \t3011, 964, 3281, 6, 1326, 741, 189, 2632, 373, 1176, 548, 64, 1445, 2376, 1524, 2690, 1316, 2304, 1336, \t2257, 3227, 2542, 3911, 3460\t]LTC = np.zeros([n, m], dtype=(int))LTC[0,:] = IVKfor i in range(1, n):\tfor j in range(m // n + 1):\t\tLTC[i,j*n:(j+1)*n] = np.roll(IVK[j*n:(j+1)*n], i)def byte_xor(a, b):\treturn bytes(_a ^ _b for _a,_b in zip(a,b)) def pad(inp, length):\tassert len(inp) == length\tresult = inp + os.urandom(length - len(inp))\treturn resultdef make_chaffy_mask(salt, LTC, m, n):\tq = n ** 2\thalf1_salt = salt[:m // 8]\thalf2_salt = salt[m // 8:]\txor_salts = int.from_bytes(byte_xor(half1_salt, half2_salt), \"big\")\tif xor_salts == 0:\t\treturn None,None\t\t# half1_salt = byte_xor(half1_salt, os.urandom(m))\thalf1_binStr = \"{:08b}\".format(int(half1_salt.hex(),16))\tif(len(half1_binStr) &lt; m):\t\thalf1_binStr = \"0\" * (m - len(half1_binStr)%m) + half1_binStr\thalf2_binStr = \"{:08b}\".format(int(half2_salt.hex(),16))\tif(len(half2_binStr) &lt; m):\t\thalf2_binStr = \"0\" * (m - len(half2_binStr)%m) + half2_binStr\t\tvec_1 = np.array(list(half1_binStr), dtype=int)\tvec_1 = np.reshape(vec_1, (m,1))\tvec_2 = np.array(list(half2_binStr), dtype=int)\tvec_2 = np.reshape(vec_2, (m,1))\t\tout_1 = LTC.dot(vec_1) % q\tout_2 = LTC.dot(vec_2) % q\treturn out_1, out_2def mith(mask_enc,out1,out2):\tenc = []\tfor i in range(0,len(mask_enc)//2):\t\tprint(i,mask_enc[2*i:2*(i+1)])\t\t\ttmp = int(mask_enc[2*i:2*(i+1)],16)\t\tenc.append(tmp)\tenc_vector = np.array(enc)\tenc_vector = np.reshape(enc_vector, (n,1))\tans_vec = (enc_vector^out1^out2)%256\tans_vec = np.reshape(ans_vec, (n))\tans = [chr(i) for i in ans_vec]\tprint(\"\".join(ans))SALT = os.urandom(m // 4)salt = pad(SALT, m // 4)out1,out2 = make_chaffy_mask(salt, LTC, m, n)enc = send(SALT)mith(enc.decode(),out1,out2)# ASIS{Lattice_based_hash_collision_it_was_sooooooooooooooo_easY!}[crypto] Mariana [56 solve]chall#!/usr/bin/env python3from Crypto.Util.number import *import sys# from flag import flagdef die(*args):\tpr(*args)\tquit()def pr(*args):\ts = \" \".join(map(str, args))\tsys.stdout.write(s + \"\\n\")\tsys.stdout.flush()def sc():\treturn sys.stdin.buffer.readline()def main():\tborder = \"|\"\tpr(border*72)\tpr(border, \"Welcome to MARIANA cryptography battle, the mission is solving super\", border)\tpr(border, \"hard special DLP problem in real world, are you ready to fight? \", border)\tpr(border*72)\tNBIT = 32\tSTEP = 40\tpr(border, \"In each step solve the given equation and send the solution for x. \", border)\tc = 1\twhile c &lt;= STEP:\t\tnbit = NBIT * c\t\tp = getPrime(nbit)\t\tg = getRandomRange(3, p)\t\tpr(border, f'p = {p}')\t\tpr(border, f'g = {g}')\t\tpr(border, 'Send the solution x = ')\t\tans = sc()\t\ttry:\t\t\tx = int(ans)\t\texcept:\t\t\tdie(border, 'Given number is not integer!')\t\tif x &gt;= p:\t\t\tdie(border, \"Kidding me!? Your solution must be smaller than p :P\")\t\tif (pow(g, x, p) - x) % p == 0:\t\t\tif c == STEP:\t\t\t\tdie(border, f\"Congratz! the flag is: {flag}\")\t\t\telse:\t\t\t\tpr(border, \"Good job, try to solve the next level!\")\t\t\t\tc += 1\t\telse:\t\t\tdie(border, \"Try harder and smarter to find the solution!\")if __name__ == '__main__':\tmain()solveãªã«ã‚‚è€ƒãˆãšã«ã€æ¡ä»¶ã§$x &lt; p$ ãŒé€šã‚‹ã“ã¨ãŒç¢ºèªã§ãã‚‹ã®ã§ã€ $1-p$æŠ•ã’ã¦ãŠã—ã¾ã„ã§ã™ã€‚from pwn import *io = remote(\"65.21.255.31\" ,32066)io.recvuntil(b\"x. |\")print(io.recvline())ps = []gs = []anss = 1cnt = 1while cnt &lt; 40: # recv p = int(io.recvline(None).decode()[5:]) g = int(io.recvline(None).decode()[5:]) ps.append(p) gs.append(g) io.recvline() # calc ans = 1-p io.sendline(str(ans).encode()) result = io.recvline() print(\"[+] result... \",result) if b\"ASIS\" in result: exit()# ASIS{fiX3d_pOIn7s_f0r_d!5Cret3_l0g4riThmS!}[crypto] Mindseat [33 solve]chall#!/usr/bin/env python3from Crypto.Util.number import *from secret import params, flagdef keygen(nbit, k): # Pubkey function\t_p = 1\twhile True:\t\tp, q = [_p + (getRandomNBitInteger(nbit - k) &lt;&lt; k) for _ in '01']\t\tif isPrime(p) and isPrime(q):\t\t\twhile True:\t\t\t\ts = getRandomRange(2, p * q)\t\t\t\tif pow(s, (p - 1) // 2, p) * pow(s, (q - 1) // 2, q) == (p - 1) * (q - 1):\t\t\t\t\tpubkey = p * q, s\t\t\t\t\treturn pubkeydef encrypt(pubkey, m):\tn, s = pubkey\tr = getRandomRange(2, n)\treturn pow(s, m, n) * pow(r, 2 ** k, n) % nflag = flag.lstrip(b'ASIS{').rstrip(b'}')nbit, k = paramsPUBKEYS = [keygen(nbit, k) for _ in range(4)]flag = [bytes_to_long(flag[i*8:i*8 + 8]) for i in range(4)]ENCS = [encrypt(PUBKEYS[_], flag[_]) for _ in range(4)]print(f'PUBKEYS = {PUBKEYS}')print(f'ENCS = {ENCS}')solveä»Šå›ã®æ™‚é–“é£Ÿã£ãŸå…ƒå‡¶å›(ã¾ã˜ã§)ã•ã¦ãŠãã€ã“ã®å•é¡Œã¯2 ãƒ‘ãƒ¼ãƒˆã«åˆ†ã‹ã‚Œã¾ã™ $n$ã‹ã‚‰$p,q$ã®å¾©å…ƒ $enc = s^m * r^{2 ^ k} \\pmod n$ ã‹ã‚‰ $m$ ã®å¾©å…ƒpart 1æ‰‹å§‹ã‚ã«getRandomNBitIntegerã® $k$ ã®å€¤ã‚’çŸ¥ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€å˜ç´”ã« $p*q = (r_p*2^k+1)*(r_q*2^k+1) $ ã‚’è€ƒãˆã‚Œã°ã€$ n$ ã®ä¸‹ä½ãƒ“ãƒƒãƒˆã‚’è¦‹ã¦$0$ ãŒç¶šãé•·ã•ã‚’è€ƒãˆã‚Œã° $k$ ã®å€¤ã‚’æ±ºã‚æ‰“ã¡ã§ãã‚‹ã€‚ä»Šå›ã¯ $134$ ã ã£ãŸã€‚ãã‚Œã«ã‚ˆã‚Š $r_p,r_q$ ã®é•·ã•ã‚‚è¦‹ãˆã¦ãã‚‹ã€‚$n$ ãŒ$512$ãƒ“ãƒƒãƒˆã‚ˆã‚Š$p,q$ ã®ãã‚Œãã‚Œã®ä¹±æ•°éƒ¨åˆ†ã®é•·ã•ã¯ $256-k$ ãƒ“ãƒƒãƒˆã¨ãªã‚Šã€‚defundãƒ‘ã‚¤ã‚»ãƒ³ã®coppersmithã§å¾©å…ƒã§ãã‚‹ã€‚def dec_para(PUB,ENC): N,s = PUB k = 134 P.&lt;x, y&gt; = PolynomialRing(Zmod(N)) _p = 1 poly3 = (x*2^k + _p)*(y*2^k + _p) bounds = (2^(256-k), 2^(256-k)) roots = small_roots(poly3, bounds, m=2, d=2)[0] print(roots) p = roots[0]*2^k + _p q = roots[1]*2^k + _p assert isPrime(int(p)) assert isPrime(int(q)) assert p*q==Npart 2$enc = s^m * r^{2 ^ k} \\pmod n$ ã‚ˆã‚Š $r$ ãŒé‚ªé­”ãªã®ã§$enc^{\\frac{\\phi(n)}{2^k}} = s^{\\frac{m\\phi(n)}{2^k}} * r^{\\phi(n)} \\pmod n = s^{\\frac{m\\phi(n)}{2^k}} \\pmod n$ ã«ãªã‚Šã€dis_cretelogã§æ±‚ã‚ã¦ã—ã¾ã„ã€‚ä»Šå›ã¯ã€å¿µã®ãŸã‚ $p,q$åˆ†ã‘ã¦è¡Œã£ãŸã€‚def decrypt(p,q,s,c): n = p*q k =134 phi = (p-1)*(q-1) e = pow(2,k) e_ = int(p-1)//int(e) m = discrete_log(GF(p)(c)^e_,GF(p)(s)^e_, operation=\"*\") print(long_to_bytes(m)) return long_to_bytes(m)from Crypto.Util.number import *import itertoolsPUBKEYS = [(10342840547250370454282840290754052390564265157174829726645242904324433774727630591803186632486959590968595230902808369991240437077297674551123187830095873, 5179654005441544601140101875149402241567866059199512232495766031194848985776186595289740052214499657697650832860279375151687044465018028876445070588827777), (6015512135462554031390611730578383462516861987731833360559070749140159284050335604168414434218196369921956160353365713819898567416920672209509202941444097, 2116441415129068001049624780654272734931672052541246678702416144768611225693039503554945326959705314527114860312641379671935648337975482830939466425225421), (6396980904648302374999086102690071222661654639262566535518341836426544747072554109709902085144158785649143907600058913175220229111171441332366557866622977, 1760317994074087854211747561546045780795134924237097786412713825282874589650448491771874326890983429137451463523250670379970999252639812107914977960011738), (9158217300815233129401608406766983222991414185115152402477702381950519098200234724856258589693986849049556254969769863821366592458050807400542885348638721, 6564146847894132872802575925374338252984765675686108816080170162797938388434600448954826704720292576935713424103133182090390089661059813982670332877677256)]ENCS = [4595268033054096192076432659360373235610019564489694608733743330870893803828258295069937060360520598446948290913045781945314108935153236291467160667601985, 3390637292181370684803039833768819598968576813582112632809296088618666221278429695211004046274005776653775480723833818255766663573061866194380012311184611, 5197599582013327040903216369733466147938613487439777125659892779696104407398257678982801768761973934713675657188014051286238194316997970299887749668838196, 5093835186720390391696398671365109925058893544530286148616117890366909889206952477053316867658405460457795493886317792695055944930027477761411273933822112]def small_roots(f, bounds, m=1, d=None):\tif not d:\t\td = f.degree()\tR = f.base_ring()\tN = R.cardinality()\t\tf /= f.coefficients().pop(0)\tf = f.change_ring(ZZ)\tG = Sequence([], f.parent())\tfor i in range(m+1):\t\tbase = N^(m-i) * f^i\t\tfor shifts in itertools.product(range(d), repeat=f.nvariables()):\t\t\tg = base * prod(map(power, f.variables(), shifts))\t\t\tG.append(g)\tB, monomials = G.coefficient_matrix()\tmonomials = vector(monomials)\tfactors = [monomial(*bounds) for monomial in monomials]\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, factor)\tB = B.dense_matrix().LLL()\tB = B.change_ring(QQ)\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, 1/factor)\tH = Sequence([], f.parent().change_ring(QQ))\tfor h in filter(None, B*monomials):\t\tH.append(h)\t\tI = H.ideal()\t\tif I.dimension() == -1:\t\t\tH.pop()\t\telif I.dimension() == 0:\t\t\troots = []\t\t\tfor root in I.variety(ring=ZZ):\t\t\t\troot = tuple(R(root[var]) for var in f.variables())\t\t\t\troots.append(root)\t\t\treturn roots\treturn []def decrypt(p,q,s,c): n = p*q k =134 phi = (p-1)*(q-1) e = pow(2,k) e_ = int(p-1)//int(e) m = discrete_log(GF(p)(c)^e_,GF(p)(s)^e_, operation=\"*\") print(long_to_bytes(m)) return long_to_bytes(m)def dec_para(PUB,ENC): N,s = PUB k = 134 P.&lt;x, y&gt; = PolynomialRing(Zmod(N)) _p = 1 poly3 = (x*2^k + _p)*(y*2^k + _p) bounds = (2^(256-k), 2^(256-k)) roots = small_roots(poly3, bounds, m=2, d=2)[0] print(roots) p = roots[0]*2^k + _p q = roots[1]*2^k + _p assert isPrime(int(p)) assert isPrime(int(q)) assert p*q==N return decrypt(int(p),int(q),int(s),int(ENC)) flag = b\"\"for i in range(4): flag +=dec_para(PUBKEYS[i],ENCS[i]) print(b\"ASIS{\"+flag+b\"}\")# ASIS{N3w_CTF_nEW_Joye_Libert_CrYpt0_5}[crypto] Desired curveã€€[16 solve]chall#!/usr/bin/env sageimport sysfrom Crypto.Util.number import *from flag import flagdef die(*args):\tpr(*args)\tquit()def pr(*args):\ts = \" \".join(map(str, args))\tsys.stdout.write(s + \"\\n\")\tsys.stdout.flush()def sc():\treturn sys.stdin.buffer.readline()def main():\tborder = \"|\"\tpr(border*72)\tpr(border, \"Hi all, now it's time to solve a relatively simple challenge about \", border)\tpr(border, \"relatively elliptic curves! We will generate an elliptic curve with \", border)\tpr(border, \"your desired parameters, are you ready!? \", border)\tpr(border*72)\tnbit = 256\tq = getPrime(nbit)\tF = GF(q)\twhile True:\t\tpr(border, \"Send the `y' element of two points in your desired elliptic curve: \")\t\tans = sc()\t\ttry:\t\t\ty1, y2 = [int(_) % q for _ in ans.split(b',')]\t\texcept:\t\t\tdie(border, \"Your parameters are not valid! Bye!!\")\t\tA = (y1**2 - y2**2 - 1337**3 + 31337**3) * inverse(-30000, q) % q\t\tB = (y1**2 - 1337**3 - A * 1337) % q\t\tE = EllipticCurve(GF(q), [A, B])\t\tG = E.random_point()\t\tm = bytes_to_long(flag)\t\tassert m &lt; q\t\tC = m * G\t\tpr(border, f'The parameters and encrypted flag are:')\t\tpr(border, f'q = {q}')\t\tpr(border, f'G = ({G.xy()[0]}, {G.xy()[1]})')\t\tpr(border, f'm * G = ({C.xy()[0]}, {C.xy()[1]})')\t\tpr(border, f'Now find the flag :P')if __name__ == '__main__':\tmain()solveã‚„ã‚‹ã“ã¨ã¯ç°¡å˜ã§ã€ invalid curve attack ã§subgroupã®ã‚ªãƒ¼ãƒ€ãƒ¼ãŒå°ã•ã„ã‚‚ã®ã‚’è¦‹ã¤ã‘ã‚‹ã€‚ ãã‚Œã‚’ã€é›†ã‚ã¦CRTã§å¾©å…ƒã™ã‚‹ã€‚from pwn import *from timeout_decorator import timeoutfrom random import randintfrom Crypto.Util.number import *io = remote(\"65.21.255.31\" ,10101)io.recvuntil(b\"| Se\")def send(y1,y2): io.recvline() io.sendline((str(y1)+\",\"+str(y2)).encode()) io.recvline() q = int(io.recvline(None).decode()[5:]) G = io.recvline(None).decode()[2+4+1:].split(\",\") mG = io.recvline(None).decode()[2+8+1:].split(\",\") Gx = int(G[0]) Gy = int(G[1].replace(\")\",\"\")) mGx = int(mG[0]) mGy = int(mG[1].replace(\")\",\"\")) io.recvline() return q , (Gx,Gy) ,(mGx,mGy)# I adjusted to https://furutsuki.hatenablog.com/entry/2020/05/05/112207def search_para(P): @timeout(10, timeout_exception=Exception, use_signals=False) def factorize(n): return prime_factors(n) F = GF(P) while True: y1 = randint(2,P-1) y2 = randint(2,P-1) A = (y1**2 - y2**2 - 1337**3 + 31337**3) * pow(-30000,-1, q) % q B = (y1**2 - 1337**3 - A * 1337) % q EC = EllipticCurve(F, [A, B]) order = EC.order() try: factors = factorize(order) except Exception: continue suborder = 1 for f in factors: if f &lt; 10**10: suborder = f else: break g = EC.gen(0) * int(order // suborder) # print({ # \"generator\": g.xy(), # \"order\": suborder, # \"y1\": y1, # \"y2\":y2, # \"q\": q, # }, \",\") return y1,y2,subordery1,y2 = 1,1q, G, mG= send(y1,y2)A = (y1**2 - y2**2 - 1337**3 + 31337**3) * pow(-30000,-1, q) % qB = (y1**2 - 1337**3 - A * 1337) % qE = EllipticCurve(GF(q),[A,B])dlog = []odr = []phimation = 1while True: y1,y2,suborder = search_para(q) q, G, mG= send(y1,y2) A = (y1**2 - y2**2 - 1337**3 + 31337**3) * pow(-30000,-1, q) % q B = (y1**2 - 1337**3 - A * 1337) % q E = EllipticCurve(GF(q),[A,B]) G = E(G) mG = E(mG) phimation *= suborder print(\"[*] subord =\", suborder) print(\"[*] persentage =\", (100*int(phimation).bit_length())//int(E.order()).bit_length(),\"%\") print(\"[*] start dlog\") dlog.append(discrete_log(mG*(E.order()//suborder),G*(E.order()//suborder), operation=\"+\",ord=E.order())) odr.append(suborder) m = long_to_bytes(int(CRT(dlog, odr))) print(\"[+] find dlog ...\",m, end = \"\\n\\n\") if b\"ASIS\" in m: exit()# ASIS{(e$l6LH_JfsJ:~&lt;}1v&amp;}" }, { "title": "GDG Algiers CTF 2022 writeup", "url": "/posts/GDG_Algiers_CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-10-10 02:00:00 +0900", "snippet": "åˆã‚ã«SEKAICTFã§ç–²ã‚ŒãŸã®ã§æ¯æŠœãã«â€¦[crypto] The_Messagerchallfrom Crypto.Util.number import bytes_to_long, getStrongPrimefrom math import gcdfrom flag import FLAGfrom Crypto.Random import get_random_bytesdef encrypt(m): return pow(m,e,N)e = 65537p = getStrongPrime(512)q = getStrongPrime(512)# generate secure keysresult = 0while (result !=1): p = getStrongPrime(512) q = getStrongPrime(512) result = gcd(e,(p-1)*(q-1)) \tN = p * qprint(\"N = \" + str(N))print(\"e = \" + str(e))ct= []for car in FLAG:\tct.append(encrypt(car))print(\"ct = \"+str(ct))solve$p,q$ãŒ512bitã‹ã‚‰ãªã‚‹ç´ å› æ•°åˆ†è§£ã¯çµæ§‹ã ã‚‹ã„ã®ã§ã€é€†ã‹ã‚‰è€ƒãˆã‚‹ã€‚ãƒ•ãƒ©ã‚°ã®æ–‡å­—åˆ—ã«ãŠã‘ã‚‹ASCIIã®ç¯„å›²ãŒ$0x20-0x7f$ã¾ã§ã§ã‚ã‚‹ã“ã¨ã‚’åˆ©ç”¨ã—1æ–‡å­—ã¥ã¤å¾©å·ã—ã¦ãŠã—ã¾ã„ã€‚N = 98104793775314212094769435239703971612667878931942709323496314311667226421821897454047455384364608911477616865967419199078405667657976292973268348872702988831334377069809925141829484522654208638838107410232921531587371072553811548927714437673444716295120279177952417246053452081185183736591850104338774924467e = 65537ct = [snipped...]from Crypto.Util.number import bytes_to_long, getStrongPrimefrom math import gcdfrom Crypto.Random import get_random_bytesm = \"\"for c in ct: for i in range(0x20,0x7f): if c == pow(i,e,N): m+=chr(i) print(m)# CyberErudites{RSA_1S_S1MPL3}[crypto] The Matrixchallimport jsonfrom os import urandomfrom Crypto.Hash import SHA256from Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom sage.all import *from Crypto.Util.number import getPrimefrom random import randintp = getPrime(64)def read_matrix(file_name): data = open(file_name, 'r').read().strip() rows = [list(eval(row)) for row in data.splitlines()] return Matrix(GF(p), rows)def encrypt(plaintext,key): iv = urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) ciphertext = cipher.encrypt(pad(plaintext,16)) return iv,ciphertextG = read_matrix('matrix.txt')priv = randint(1,p-1)pub = G**privkey = SHA256.new(data=str(priv).encode()).digest()[:2**8]flag = b'CyberErudites{???????????????????????????????}'iv,encrypted_flag = encrypt(flag,key)with open('public_key.txt', 'wb') as f: for i in range(N): f.write((str(list(pub[i])).encode())+b'\\n')json.dump({ \"iv\": iv.hex(), \"ciphertext\": encrypted_flag.hex(), \"p\":str(p)}, open('encrypted_flag.txt', 'w'))solveæ­£æ–¹è¡Œåˆ—ã«ãŠã‘ã‚‹é›¢æ•£å¯¾æ•°å•é¡Œã‚’è§£ãã‚·ãƒ³ãƒ—ãƒ«ãªå•é¡Œã€‚ãã‚‚ãã‚‚ã¨ã—ã¦ã€é›¢æ•£å¯¾æ•°å•é¡Œã¯åŸºæœ¬çš„ã«è§£ãã®ã¯é›£é–¢ã ãŒã€ã‚ã‚‹æ¡ä»¶ä¸‹ã«ãŠã„ã¦å®¹æ˜“åŒ–ã™ã‚‹ã€‚ä»Šå›ã®å ´åˆãã‚Œã«å½“ã¦ã¯ã¾ã‚Šã€ã‚¸ãƒ§ãƒ«ãƒ€ãƒ³æ¨™æº–å½¢ã‚’ç”¨ã„ã¦ç°¡å˜ã«è¡Œã†ã€‚ã‚ã‚‹è¡Œåˆ—$G, P$ã‚’ç”¨ã„ã¦$ G = P^{-1}*G_j*P $ã¨ã„ã†ã‚¸ãƒ§ãƒ«ãƒ€ãƒ³æ¨™æº–å½¢ã‚’æ§‹æˆã™ã‚‹ã€‚ã“ã®ã¨ã$ A = G^{priv} $ã¯$ A = P^{-1}*G_j^{priv}*P $ã¨ãªã‚Šã€$G_j$ãŒä¸‰è§’è¡Œåˆ—(ä»Šå›ã®å ´åˆã¯å¯¾è§’è¡Œåˆ—)ã§ã‚ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨$A_{-1,-1} = G_{-1,-1}^{priv} \\pmod p$ã§ã‚ã‚‹ã“ã¨ã‚ˆã‚Šã€è¡Œåˆ—ã®é›¢æ•£å¯¾æ•°å•é¡Œã¯ç´ ä½“ä¸Šã®é›¢æ•£å¯¾æ•°å•é¡Œã«è½ã¡å®¹æ˜“ã«æ±‚ã‚ã‚‰ã‚Œã‚‹ã€‚import jsonfrom os import urandomfrom Crypto.Hash import SHA256from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom sage.all import *from Crypto.Util.number import getPrimefrom random import randintiv = bytes.fromhex(\"c534df3e87713beace67144f85aca107\")ciphertext = bytes.fromhex(\"c843230a54cc51d7b7ce2b47b0da5f8b98a04c3baad4bdae20f3fdcb5747f81c34a6962aef330f0d244116650c4305fd\")p = 12143520799543738643def read_matrix(file_name): data = open(file_name, 'r').read().strip() rows = [list(eval(row)) for row in data.splitlines()] return Matrix(GF(p), rows)def decrypt(ct,key,iv): cipher = AES.new(key, AES.MODE_CBC, iv) pt = unpad(cipher.decrypt(ct),16) return pt_G = read_matrix('matrix.txt')Gj, P = _G.jordan_form(transformation=True)_pub = read_matrix(\"public_key.txt\")G_jordan = P.inverse()*_G*Ppub_jordan = P.inverse()*_pub*Pprint(G_jordan)print(pub_jordan)print(discrete_log(pub_jordan[-1][-1],G_jordan[-1][-1]))priv = 7619698002081645976assert _G**priv == _pubkey = SHA256.new(data=str(priv).encode()).digest()[:2**8]print(decrypt(ciphertext,key,iv))# b'CyberErudites{Di4g0n4l1zabl3_M4tric3s_d4_b3st}'[crypto] Eddychallfrom pure25519.basic import (bytes_to_clamped_scalar,scalar_to_bytes, bytes_to_scalar, bytes_to_element, Base)import hashlib, binasciiimport osdef H(m): return hashlib.sha512(m).digest()def publickey(seed): # turn first half of SHA512(seed) into scalar, then into point assert len(seed) == 32 a = bytes_to_clamped_scalar(H(seed)[:32]) A = Base.scalarmult(a) return A.to_bytes()def Hint(m): h = H(m) return int(binascii.hexlify(h[::-1]), 16)def signature(m, sk, pk): assert len(sk) == 32 # seed assert len(pk) == 32 h = H(sk[:32]) a_bytes, inter = h[:32], h[32:] a = bytes_to_clamped_scalar(a_bytes) r = Hint(inter + m) R = Base.scalarmult(r) R_bytes = R.to_bytes() S = r + Hint(R_bytes + pk + m) * a e = Hint(R_bytes + pk + m) return R_bytes, S, edef checkvalid(s, m, pk): if len(s) != 64: raise Exception(\"signature length is wrong\") if len(pk) != 32: raise Exception(\"public-key length is wrong\") R = bytes_to_element(s[:32]) A = bytes_to_element(pk) S = bytes_to_scalar(s[32:]) h = Hint(s[:32] + pk + m) v1 = Base.scalarmult(S) v2 = R.add(A.scalarmult(h)) return v1 == v2def create_signing_key(): seed = os.urandom(32) return seeddef create_verifying_key(signing_key): return publickey(signing_key)#!/usr/bin/python3import sysfrom challenge import *from Crypto.Util.number import *with open(\"flag.txt\",\"r\") as f: flag = f.read()flag = flag.encode()sk = create_signing_key()pk = create_verifying_key(sk)R_flag,S_flag,e_flag = signature(flag,sk,pk)def start(): print(\"Welcom to my singing server !\") print(\"-\" * 10 + \"Menu\" + \"-\" * 10) print(\"1- Sign a message with a random private key \") print(\"2- Sign a message with your private key \") print(\"3- Verify the flag\") print(\"4- Quit\") print(\"-\" * 24) try: while True: c = input(\"&gt; \") if c == '1': msg =input(\"Enter your message : \").encode() pk = create_verifying_key(sk) R,S,e = signature(msg,sk,pk) out = {\"R\":R,\"S\": S,\"e\":e} print(out) elif c == '2': msg = input(\"Enter your message : \").encode() privk = int(input(\"Enter your private key : \")) privk = long_to_bytes(privk) pk = create_verifying_key(privk) R, S, e = signature(msg, sk, pk) out = {\"R\": R, \"S\": S, \"e\": e} print(out) elif c == '3': pk = int(input(\"Enter your public key : \")) pk = long_to_bytes(pk) if checkvalid(R_flag+scalar_to_bytes(S_flag),flag,pk): print(\"You are an admin, Here's your flag \", flag) else: print(\"Sorry , you can't get your flag !\") sys.exit() elif c == '4': print(\"Goodbye :)\") sys.exit() except Exception: print(\"System error.\") sys.exit()start()solveoracleå•é¡Œã§ã€flagã‚’å‡ºã™ãŸã‚ã«ã¯pkã‚’æ±‚ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚pkã‚’æ±‚ã‚ã‚‹ã«ã¯ã€skã‚’æ±‚ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚skã¯ãƒ©ãƒ³ãƒ€ãƒ ãªå€¤ã¨ã€ä¸€è¦‹æ±‚ã‚ã‚‹ã®ãŒä¸å¯èƒ½ã«æ€ãˆã‚‹ã€‚def publickey(seed): # turn first half of SHA512(seed) into scalar, then into point assert len(seed) == 32 a = bytes_to_clamped_scalar(H(seed)[:32]) A = Base.scalarmult(a) return A.to_bytes()def signature(m, sk, pk): assert len(sk) == 32 # seed assert len(pk) == 32 --------snipped--------publickeyé–¢æ•°ã¨ignatureé–¢æ•°ã§æ¯”è¼ƒã™ã‚‹ã€‚ publickeyé–¢æ•°ã®å¼•æ•°seedã«ã¯skã®å€¤ãŒå…¥ã‚‹ã“ã¨ã‚’è€ƒæ…®ã™ã‚Œã°signatureé–¢æ•°ã®aã¯pkã®å€¤ã«ãªã‚‹ã€‚ã‚ˆã£ã¦ã€æ¬¡ã¯aã‹ã‚‰pkã‚’æ±‚ã‚ã‚Œã°ã‚ˆã„ã“ã¨ã«ãªã‚‹ã€‚def signature(m, sk, pk): --------snipped-------- h = H(sk[:32]) a_bytes, inter = h[:32], h[32:] a = bytes_to_clamped_scalar(a_bytes) r = Hint(inter + m) R = Base.scalarmult(r) R_bytes = R.to_bytes() S = r + Hint(R_bytes + pk + m) * a e = Hint(R_bytes + pk + m) return R_bytes, S, esignatureé–¢æ•°ã®å¾ŒåŠã«ãŠã„ã¦S,eãŒæ—¢çŸ¥ã§ã‚ã‚‹ã“ã¨ã‚’ç”¨ã„ã‚Œã°aãŒæ±‚ã¾ã‚‹ã€‚bytes_to_clamped_scalaré–¢æ•°(å…ˆé ­2bitãŒ01,ä¸‹ä½3bitã¯000ã«ãªã‚‹ã‚ˆã†ã«ã™ã‚‹)ã‚’æˆ»ã™ã‚‚ã®ã‚’å®Ÿè£…ã™ã‚‹def bytes_to_clamped_scalar(s): # Ed25519 private keys clamp the scalar to ensure two things: # 1: integer value is in L/2 .. L, to avoid small-logarithm # non-wraparaound # 2: low-order 3 bits are zero, so a small-subgroup attack won't learn # any information # set the top two bits to 01, and the bottom three to 000 a_unclamped = bytes_to_scalar(s) AND_CLAMP = (1&lt;&lt;254) - 1 - 7 OR_CLAMP = (1&lt;&lt;254) a_clamped = (_unclamped &amp; AND_CLAMP) | OR_CLAMP return a_clampedä»¥ä¸Šã§pkã®å€™è£œãŒçµã‚Šè¾¼ã‚ãŸã®ã§ç¢ºèªã—ã¦flagã‚’å–ã£ã¦çµ‚ã‚ã‚Šã€‚é¢å€’ãªã®ã§ã€å€™è£œã®1ã¤ã‚’å…¥åŠ›ã—ã¦ã ã‚ãªã‚‰ç¹‹ãç›´ã—ãŸã€‚(bruteforceã§ãªã„ã®ã§ok)import sysfrom challenge import *from Crypto.Util.number import *from pwn import *m = \"CyberErudites{\"while True: io = remote(\"crypto.chal.ctf.gdgalgiers.com\" ,1000) # io = process([\"python3\",\"server.py\"]) print(io.recvuntil(b\"&gt; \").decode()) io.sendline(b\"1\") pk = io.recvuntil(b\": \").decode() io.sendline(b\"12\") # io.recvline().decode() tmp = io.recvline(None).decode().replace(\"}\",\"\").split(\": \") print(tmp) R = eval(tmp[1][:-5]) s = eval(tmp[2][:-5]) e = eval(tmp[3]) # print(R) # print(s) # print(e) a = s //e # print(bin(a)) # print(s//e) print(a) # rev_bytes_to_clamped_scalar(s): for i in range(2**3): for k in range(2**2): pk = int(bin(k)[2:] + bin(a)[2:]+bin(i)[2:],2) A = Base.scalarmult(a) A2 = bytes_to_long(A.to_bytes()) print(A2) print(io.recvuntil(b\"&gt; \").decode()) io.sendline(b\"3\") print(io.recvuntil(b\": \").decode()) io.sendline(str(A2).encode()) tmp = io.recvline().decode() print(tmp) if tmp.endswith(b\"}\") : print(tmp)# CyberErudites{ed25519_Uns4f3_L1b5}[crypto] Nitrochall#!/usr/bin/sagefrom sage.all import *from nitro import Nitrowith open(\"flag.txt\",\"r\") as f: flag = f.readline()assert len(flag)==32def str2bin(s): return ''.join(bin(ord(i))[2:].zfill(8) for i in s)def main(): print(\"********** NITRO ORCALE **********\") print(\" Welcome to the nitro oracle \") print(\"After getting inspired by some encryption services, i tried to built my own server\") print(\"My idea is based on using polynomials to make an affine encryption\") print(\"Keep in mind that i can only encrypt a specific byte each time\") print(\"You can send me the position of the byte and i send the encrypted byte with the used public key \") N, p, q, d = 8, 2, 29, 2 assert gcd(N, q) == 1 and gcd(p, q) == 1 and q &gt; (6 * d + 1) * p cipher = Nitro(N, p, q, d) print(\"------------------------------\") print(\"| MENU |\") print(\"| a) encrypt the ith byte |\") print(\"| b) exit |\") print(\"------------------------------\") while True: menu= input(\"choose an option \\n\") try: if menu == \"a\": i = int(input(\"enter the byte index: \")) assert i&lt;32 m = list(str2bin(flag[i])) e,h = cipher.encrypt(m) print(e) print(h) elif menu == \"b\": print(\" Good Bye !! \") exit() else: print(\"Error: invalid menu option.\") raise Exception except Exception as ex: print(\"\\nSomething went wrong......try again?\\n\")if __name__ == \"__main__\": main()from sage.all import *class Nitro: f_x = None g_x = None Fp_x = None Fq_x = None hx = None R = None Rq = None Rp = None def __init__(self, N, p, q, d): self.N = N self.p = p self.q = q self.d = d def random_poly(self, N, d1, d2): coef_list = [1] * d1 + [-1] * d2 + [0] * (N - d1 - d2) shuffle(coef_list) return coef_list def keygen(self): RR= ZZ['x'] Cyc = RR([-1]+[0]*(self.N - 1)+[1])#x^N-1 R = RR.quotient(Cyc) Rq = RR.change_ring(Integers(self.q)).quotient(Cyc) Rp = RR.change_ring(Integers(self.p)).quotient(Cyc) while True: try: f_x = R(self.random_poly(self.N, self.d + 1, self.d)) g_x = R(self.random_poly(self.N, self.d, self.d)) Fp_x = Rp(lift(1 / Rp(f_x))) Fq_x = Rq(lift(1 / Rq(f_x))) break except: continue assert Fp_x * f_x == 1 and Fq_x * f_x == 1 h_x = Rq(Fq_x * g_x) self.f_x, self.g_x, self.Fp_x, self.Fq_x, self.h_x = f_x, g_x, Fp_x, Fq_x, h_x self.R, self.Rq, self.Rp = R, Rq, Rp def encrypt(self, m: list): self.keygen() r_x = self.Rq(self.random_poly(self.N, self.d, self.d)) m_x = self.Rp(m) m_x = m_x.lift() m_x = self.Rq(m_x) e_x = self.Rq(self.p * self.h_x * r_x + m_x) return e_x.list(), self.h_x.list()solveå‰°ä½™ç’°ã®å•é¡Œã§ã™ã€‚ã¾ãã€ç´ æ•°2ã¤ä½¿ã£ã¦ã„ã‚‹ã®ã§NTRUã‹ã¨ã¯æ€ã„ã¾ã™ã€‚æš—å·åŒ–æ–¹é‡ã¨ã—ã¦ã¯ã€flagã‚’1æ–‡å­—ãšã¤ãƒã‚¤ãƒŠãƒªã«å¤‰æ›ã—ã¦$\\mod 2$ã®å¤šé …å¼ã«ã—ã¦ã€$p * h_x * r_x + m_x$ ã§è¡Œã£ã¦ã„ã¾ã™ã€‚ãã‚‚ãã‚‚ã¨ã—ã¦ã€å¤šé …å¼ã®æ¬¡æ•°$N$ã¯8ãªã®ã§ã€ASCII1æ–‡å­—ã‚’æš—å·åŒ–ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚Œã°$2^8$é€šã‚Šã€$r_x$ã¯ä¿‚æ•°ãŒ$-1,0,1$ã®ä¸‰ç¨®é¡ã‚ˆã‚Š$3^8$é€šã‚Šã§ã‚ã‚‹ã“ã¨ã‚’è€ƒãˆã‚Œã°å…¨æ¢ç´¢ã§ãã‚‹ç¯„å›²ã§ã‚ã‚Šã€å…¨æ¢ç´¢ã§çµ‚ã‚ã‚‰ã—ã¦ã—ã¾ã£ãŸâ€¦.from sage.all import *from nitro import Nitrofrom pwn import *from Crypto.Util.number import *import collectionsio = remote(\"crypto.chal.ctf.gdgalgiers.com\" ,1001)# io = process([\"python3\",\"nitro_server.py\"])N, p, q, d = 8, 2, 29, 2def str2bin(s): return ''.join(bin(ord(i))[2:].zfill(8) for i in s)def bin2str(s): try: s = [str(i) for i in s] return chr(int(\"\".join(s),2)) except: return Nonedef all_poly( N, d1, d2): coef_list_lists = [] for i in range(3**N): coef_list=[] for k in range(N): if i % 3 == 2: coef_list.append(-1) else: coef_list.append(i % 3) i = i // 3 coef_list_lists.append(coef_list) # print(coef_list_lists) return coef_list_listsdef catch(i): io.recvuntil(b\"choose an option\").decode() io.sendline(b\"a\") io.recvuntil(b\": \") io.sendline(str(i).encode()) e_x = eval( io.recvline(None).decode()) h_x = eval(io.recvline(None).decode()) return e_x,h_xRR= ZZ['x']Cyc = RR([-1]+[0]*(N - 1)+[1])#x^N-1R = RR.quotient(Cyc)Rq = RR.change_ring(Integers(q)).quotient(Cyc)Rp = RR.change_ring(Integers(p)).quotient(Cyc)flag = \"\"for i in range(32): mss = [ [] for _ in range(3)] for m in range(3): e_x,h_x = catch(i) for k,poly in enumerate(all_poly(N ,d ,d)): r_x = Rq(poly) e_x = Rq(e_x) h_x = Rq(h_x) # m_x = Rp(m) # m_x = m_x.lift() # m_x = Rq(m_x) mss[m].append(bin2str(Rq(-1*p * h_x * r_x + e_x).list())) print(collections.Counter(mss[0]+mss[1]+mss[2]).keys()[2])print(flag)# CyberErudites{_NTRU_LLL_4tt4ck_}ç­”ãˆçš„ã«ã¯LLLã§è§£ã‘ã‚‹ã‚‰ã—ã„ã€å¾Œã§ã‚„ã£ã¦ã¿ã¾ã™ã€‚[crypto] franklin-last-wordschallfrom Crypto.Util.number import bytes_to_long, getStrongPrimefrom math import gcdfrom flag import FLAGfrom Crypto.Random import get_random_bytesdef encrypt_message(m): return pow(m,e,N)def advanced_encrypt(a,m):\treturn encrypt_message(pow(a,3,N)+(m &lt;&lt; 24))e = 3p = getStrongPrime(512)q = getStrongPrime(512)# generate secure keysresult = 0while (result !=1): p = getStrongPrime(512) q = getStrongPrime(512) result = gcd(e,(p-1)*(q-1)) \tN = p * qprint(\"N = \" + str(N))print(\"e = \" + str(e))rand = bytes_to_long(get_random_bytes(64))ct = []ct.append(encrypt_message(rand &lt;&lt; 24))for car in FLAG:\tct.append(advanced_encrypt(car,rand))print(\"ct = \"+str(ct))solveThe_Messagerã®é›£åº¦é«˜ã‚?ã®å•é¡Œã¾ãã€åå‰ã®é€šã‚Šfranklin-reiter related message attackã¨ã¯æ€ã„ã¾ã™ã€‚ã§ã™ãŒã€ãªã‚“ã‹é¢å€’ãªã®ã§å¤šé …å¼gcdã§$ r$ å‡ºã—ã¦ã€å…¨æ¢ç´¢ã§çµ‚ã‚ã‚Šã§ã™ã€‚pgcdã®é–¢æ•°ã¯ã“ã“ã‹ã‚‰ãŠå€Ÿã‚Šã—ã¾ã—ãŸã€‚ã™ã‚“ã’â€•ä¾¿åˆ©N = 128704452311502431858930198880251272310127835853066867118127724648453996065794849896361864026440048456920428841973494939542251652347755395656512696329757941393301819624888067640984628166587498928291226622894829126692225620665358415985778838076183290137030890396001916620456369124216429276076622486278042629001e = 3ct = [21340757543584301785921441484183053451553315439245254915339588451884106542258661009436759738472587801036386643847752005362980150928908869053740830266273664899424683013780904331345502086236995074501779725358484854206059302399319323859279240268722523450455802058257892548941510959997370995292748578655762731064,----------snipped----------]from Crypto.Util.number import *e = 3pgcd = lambda g1, g2: g1.monic() if not g2 else pgcd(g2, g1%g2) P.&lt;r&gt; = PolynomialRing(Zmod(N))f1 = (bytes_to_long(b\"y\")^3 + r)^3 -ct[2]f2 = (bytes_to_long(b\"C\")^3 + r)^3 -ct[1]re_m2 = pgcd(f1,f2)rnd = N-re_m2[0]m = \"\"for c in ct[1:]: for k in range(0x20,0x7f): if c == pow(k^3+rnd,3,N): m =m+ chr(k)print(m)# CyberErudites{Fr4nkl1n_W3_n33d_an0th3R_S3450N_A54P}" }, { "title": "SEKAI CTF 2022 misc writeup", "url": "/posts/SEKAICTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, writeup", "date": "2022-10-04 01:00:00 +0900", "snippet": "xsxsxsxã¯ã˜ã‚ã«SEKAICTFãŒ10/1-10/3ã¾ã§ã®è¨ˆ48æ™‚é–“ã§é–‹å‚¬ã•ã‚Œã¾ã—ãŸã€‚ãƒœã‚«ãƒ­ãŒå¥½ããªã®ã‚‚ã‚ã£ã¦è‰²ã€…æœŸå¾…ã—ã¦ã¾ã—ãŸãŒã€UIã—ã‹ã‚Šã€å•é¡Œã—ã‹ã‚Šæƒ³åƒä»¥ä¸Šã§ã—ãŸã€‚ãã—ã¦Satoooonã•ã‚“ã¨åˆãƒãƒ¼ãƒ ã€ŒDouble Lariatã€ã§çµ„ã‚“ã§å‡ºã¾ã—ãŸãŒã€ã‚‚ã®ã™ã”ãæ¥½ã—ã‹ã£ãŸã—ã€é¢ç™½ã‹ã£ãŸã§ã™!!æ›´ã«çµæœã¯16ä½ã§ä¸Šã€…ã‚‚ã„ã„ã¨ã“ã‚ã§ã—ãŸ!!ã•ã¦å‰ç½®ãã¯ã“ã‚Œãã‚‰ã„ã«ã—ã¦ã€ä»Šå›Cryptoã®writeupã¯è¦ã‚‰ãªã„ã‹ãªã¨æ€ã†(é›£ã—ã„ã®ãŒè§£ã‘ãªã‹ã£ãŸorz)ã®ã§è§£ã‘ãŸmiscã ã‘ã§ã„ã„ã§ã™ã‹â€¦?ã©ã¡ã‚‰ã‹ã¨ã„ã†ã¨å•é¡Œã®å‡ã‚Šæ–¹ã«æ„Ÿæ¿€ã—ã¦ãŸã‚‚ã®ã§â€¦å•é¡Œãƒœã‚«ãƒ­å¥½ãã«ã¯ãŸã¾ã‚‰ãªã„å•é¡Œã‚»ãƒƒãƒˆã§ã—ãŸâ€¦!!Console Portå†…å®¹ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ç‰ˆã®Keep Talking and Nobody Explodesã§ã€ã“ã‚Œä½œã‚‹ã®å¤§å¤‰ã˜ã‚ƒãªã„???ã¨æ€ã„ã¤ã¤ä»•æ§˜æ›¸ã¨ã«ã‚‰ã‚ã£ã“ã—ã¦è§£ãã¾ã—ãŸã€‚ä½•ã‚‚å¤‰ãªéƒ¨åˆ†ã¯ãªã‹ã£ãŸã¯ãšãªã®ã§ã€ç‰¹ã«æ°—ã‚’ä»˜ã‘ã‚‹ã®ã¯é›†ä¸­åŠ›ã‚’åˆ‡ã‚‰ã•ãªã„ã“ã¨ã§ã—ãŸã­â€¦flag : SEKAI{SenkouToTomoniHibikuBakuon!}flagè¦‹ã¦è‰²ã€…ç´å¾—ã—ãŸã‚µã‚¤ãƒãƒ¼ã‚µãƒ³ãƒ€ãƒ¼ã‚µã‚¤ãƒ€ãƒ¼ã€€ã‚µã‚¤ãƒãƒ¼ã‚µãƒ³ãƒ€ãƒ¼ã‚µã‚¤ãƒ€ãƒ¼ã„ã„ã‚ˆã­ï½Susæ‹¡å¼µå­ãŒsusã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª¿ã¹ã‚‹ã¨éŸ³ã‚²ãƒ¼ã®æ‹¡å¼µå­ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚ã—ã‹ã‚‚ã€å†…å®¹ã¯è­œé¢ã‚‰ã—ãã©ã†èª­ã¿è¾¼ã¾ã›ã‚‹ã®ã‹ã†ãªã£ã¦ã„ãŸã‚‰ã€åå‰çš„ã«ãªã‚“ã‹ã“ã‚Œã˜ã‚ƒã‚“çš„ãªã‚‚ã®ã‚’è¦‹ã¤ã‘é£Ÿã‚ã›ãŸã‚‰ãƒ“ãƒ³ã‚´ã§ã—ãŸã€‚flag : SEKAI{SbtnFmnW2HnYbdDkryunTkrrtims}flagã‚‚éŸ³æ¥½ã®è¨˜å·?ã§å‡ã£ã¦ã¾ã—ãŸã­Vocaloid Heardleflagã®mp3ã¨ãã‚Œã‚’ä½œã£ãŸã§ã‚ã‚ã†pythonãƒ•ã‚¡ã‚¤ãƒ«ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚ã¨ã‚Šã‚ãˆãšflagã®mp3ã‚’èã„ã¦ã¿ã‚‹ã¨3ç§’ã”ã¨ã«éŸ³æ¥½ãŒåˆ‡ã‚Šæ›¿ã‚ã£ã¦ã¾ã—ãŸã€‚æ¬¡ã«pythonãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¦—ãã¨flagã®mp3ã¯650å€‹ã»ã©ã®æ›²ã®ãƒªã‚¹ãƒˆã‚’å–ã£ã¦ãã¦flagã®æ–‡å­—ã‹ã‚‰å¯¾å¿œã™ã‚‹æ›²ã‚’ã¤ãªã’ã¦è¿”ã™æ„Ÿã˜ã§ã—ãŸã€‚ãƒªã‚¹ãƒˆãŒå¤šã™ãã‚‹ã®ã§shazamãƒ‘ã‚¤ã‚»ãƒ³ã«ãŠé¡˜ã„ã™ã‚‹ã“ã¨ã«â€¦ã¾ãšã€flagã‚’ãã‚Œãã‚Œä¸€æ›²ã”ã¨ã«åˆ†å‰²ã—shazamã«æ›²ã®åˆ¤åˆ¥ã‚’ã—ã¦ã‚‚ã‚‰ã„å›ºæœ‰ã®IDã‚’è¿”å´ã—ã¦ã‚‚ã‚‰ã„ã¾ã—ãŸã€‚ãŸã ã€ã“ã‚Œã§ã‚‚ã€Œãƒ‹ã‚¢ã€ãƒ»ã€Œè‡ªå‚·ç„¡è‰²ã€ã¯åˆ¤åˆ¥ã—ã¦ãã‚Œãªã‹ã£ãŸã®ã§æ­Œè©ã‚’é ¼ã‚Šã«åå‰ã‚’å½“ã¦IDã‚’èª¿ã¹ã‚‹ã€‚ã“ã‚Œã§æº–å‚™ãŒæ•´ã£ãŸã®ã§shazamã«å…¨ã¦ã®æ›²ã‚’é£Ÿã‚ã›ã¦IDã®æ¯”è¼ƒã‚’è¡Œã†ã¨flagãŒç‰¹å®šã§ãã¾ã™ã€‚ã¡ãªã¿ã«ã€é€”ä¸­ãƒã‚°ãƒªæ•£ã‚‰ã‹ã—ã¦ãŸã®ã§ãƒªã‚½ãƒ¼ã‚¹ã«ã‚ã‚‹æ›²ã®ãƒªã‚¹ãƒˆã‚’ä½œã£ã¦ã¾ã—ãŸã€‚0,Tell Your World (feat. Hatsune Miku) - livetune1,ãƒ­ã‚­ - ã¿ãã¨P2,ROKI (feat. æ˜Ÿä¹ƒä¸€æ­Œ &amp; Hatsune Miku) - Leo/need3,Teo - Omoi4,Teo (feat. æ˜Ÿä¹ƒä¸€æ­Œ &amp; Hatsune Miku) - Leo/need5,ãƒ’ãƒãƒŠ -Reloaded- - DECO*276,HIBANA - Reloaded - (feat. æ˜Ÿä¹ƒä¸€æ­Œ &amp; Hatsune Miku) - Leo/need7,Timemachine (feat. Hatsune Miku) - Senroppyaku yonjuu meter P8,Time Machine (feat. æ˜Ÿä¹ƒä¸€æ­Œ, å¤©é¦¬å’²å¸Œ &amp; Hatsune Miku) - Leo/need9,Happy Synthesizer (feat. Megurine Luka&amp;GUMI) - EasyPop10,Happy Synthesizer (feat. èŠ±é‡Œã¿ã®ã‚Š, æ¡è°·é¥, æ¡ƒäº•æ„›è‰ &amp; æ—¥é‡æ£®é›«) - MORE MORE JUMP!11,Viva Happy (feat. Hatsune Miku) - Mitchie M12,Viva Happy (feat. Hatsune Miku) - Mitchie M13,Nostalogic (MEIKO-SAN mix) feat.MEIKO - yuukiss14,Nostalogic (feat. æ¡è°·é¥, æ—¥é‡æ£®é›« &amp; MEIKO) - MORE MORE JUMP!15,Drop Pop Candy (feat. Giga) - Reol16,drop pop candy (feat. å°è±†æ²¢ã“ã¯ã­, ç™½çŸ³æ, é¡éŸ³ãƒªãƒ³ &amp; å·¡éŸ³ãƒ«ã‚«) - Vivid BAD SQUAD17,Night Sky Patrol of Tomorrow (feat. æ˜Ÿä¹ƒä¸€æ­Œ) - Leo/need18,Charles - Balloon19,Charles (feat. æ±é›²çµµå &amp; æšå±±ç‘å¸Œ) - Nightcord at 25:0020,è„±æ³•ãƒ­ãƒƒã‚¯ - Neru21,Law-evading Rock (feat. å¤©é¦¬å¸, ç¥ä»£é¡ &amp; é¡éŸ³ãƒ¬ãƒ³) - ãƒ¯ãƒ³ãƒ€ãƒ¼ãƒ©ãƒ³ã‚ºÃ—ã‚·ãƒ§ã‚¦ã‚¿ã‚¤ãƒ 22,Inochi ni Kirawarete Iru. - Mafumafu23,Hated by Life (feat. å®µå´å¥ &amp; Hatsune Miku) - Nightcord at 25:0024,åŠ£ç­‰ä¸Šç­‰ feat. é¡éŸ³ãƒªãƒ³ãƒ»ãƒ¬ãƒ³ - Giga25,åŠ£ç­‰ä¸Šç­‰ feat. é¡éŸ³ãƒªãƒ³ãƒ»ãƒ¬ãƒ³ - Gigaã“ã‚Œæ›²åãŒé‡ãªã£ã¦ã‚‹ã¨ã“ã‚ã¯æ­Œã£ã¦ã„ã‚‹äººã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒé•ã†ã¿ãŸã„ã§ã—ãŸã­â€¦ã“ã‚Œç”¨æ„ã—ãŸã®ãˆããªã„????ä½œå•è€…ã«é ­ãŒä¸ŠãŒã‚Šã¾ã›ã‚“â€¦flag :SEKAI{v0CaloId&lt;3u}ã”ã‚ã‚“ãªã•ã„ã€flagã®æœ€å¾ŒãŒèª­ã‚ãªã‹ã£ãŸã§ã™â€¦vocaloid ceu??ã§ã™ã‹ã­â€¦èª­ã‚ã‚‹æ–¹ã“ã£ãã‚Šæ•™ãˆã¦ãã ã•ã„â€¦" }, { "title": "manger attackã«ã¤ã„ã¦", "url": "/posts/DUCTF-rsa-interval-oracle/", "categories": "ctf", "tags": "ctf, cryptography", "date": "2022-09-26 15:30:00 +0900", "snippet": "åˆã‚ã«DownUnderCTF ã§ rsa-interval-oracle ãŒå‡ºé¡Œã•ã‚ŒãŸã€‚ä¸»ãªè§£æ³•ã¯ä»¥ä¸‹ã«çºã‚ã‚‰ã‚Œã‚‹ã—ã€å…¬å¼è§£èª¬ã§ã‚‚åŒã˜ã‚ˆã†ãªã“ã¨ãŒæ›¸ã„ã¦ã‚ã‚‹ã€‚ rsa-interval-oracle-i â†’ã€€bitã”ã¨ã®å¾©å· or LSB oracle attack rsa-interval-oracle-ii â†’ã€€Manger attack or LSB oracle attack rsa-interval-oracle-iii â†’ã€€EHNP(HNP) or LSB oracle attack rsa-interval-oracle-iv â†’ã€€EHNP(HNP)ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰(å‚è€ƒ)rsa-interval-oracle-iv ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰#!/usr/bin/env python3import signal, timefrom os import urandom, pathfrom Crypto.Util.number import getPrime, bytes_to_longFLAG = open(path.join(path.dirname(__file__), 'flag.txt'), 'r').read().strip()N_BITS = 384TIMEOUT = 3 * 60MAX_INTERVALS = 4MAX_QUERIES = 4700def main(): p, q = getPrime(N_BITS//2), getPrime(N_BITS//2) N = p * q e = 0x10001 d = pow(e, -1, (p - 1) * (q - 1)) secret = bytes_to_long(urandom(N_BITS//9)) c = pow(secret, e, N) print(N) print(c) intervals = [(0, 2**(N_BITS - 11)), (0, 2**(N_BITS - 10)), (0, 2**(N_BITS - 9)), (0, 2**(N_BITS - 8))] queries_used = 0 while True: print('1. Add interval\\n2. Request oracle\\n3. Get flag') choice = int(input('&gt; ')) if choice == 1: if len(intervals) &gt;= MAX_INTERVALS: print('No more intervals allowed!') continue lower = int(input(f'Lower bound: ')) upper = int(input(f'Upper bound: ')) intervals.insert(0, (lower, upper)) elif choice == 2: if queries_used &gt; 0: print('No more queries allowed!') continue queries = input('queries: ') queries = [int(c.strip()) for c in queries.split(',')] queries_used += len(queries) if queries_used &gt; MAX_QUERIES: print('No more queries allowed!') continue results = [] for c in queries: m = pow(c, d, N) for i, (lower, upper) in enumerate(intervals): in_interval = lower &lt; m &lt; upper if in_interval: results.append(i) break else: results.append(-1) print(','.join(map(str, results)), flush=True) elif choice == 3: secret_guess = int(input('Enter secret: ')) if secret == secret_guess: print(FLAG) else: print('Incorrect secret :(') exit() else: print('Invalid choice')if __name__ == '__main__': signal.alarm(TIMEOUT) main()å•é¡Œç‚¹å•é¡Œã¨ãªã‚‹ã®ã¯ choice == 1 ã®æŒ‡å®šæ•°ã¨ choice == 2 ã®å¿œç­”æ™‚é–“ã§ã‚ã‚‹ã€‚ å•é¡Œ é›£ç‚¹ i ãªã— ii ã‚¯ã‚¨ãƒªãŒ1ã¤ iii å¿œç­”æ™‚é–“ãŒé•·ã„ãƒ» ã‚¯ã‚¨ãƒªãŒ4ã¤ iv ã‚¯ã‚¨ãƒªãŒ4ã¤æŒ‡å®š ,1å›ã§å…¨ã¦é€ä¿¡ å…¬å¼è§£èª¬ã§iii,ivã¯è©³ã—ãè§£èª¬ã•ã‚Œã¦ã„ã‚‹ã®ã§ã“ã“ã§ã¯ã€ii ã® manger attack ã«ã¤ã„ã¦è»½ãè§£èª¬ã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚ ç¾æ™‚ç‚¹ã§ã®ç§ãŒç†è§£ã—ãŸã‚‚ã®ã‚’æ›¸ãç¶´ã£ã¦ã„ã‚‹ãŸã‚ã€ä¸€éƒ¨èª¤è§£ã—ã¦ã„ã‚‹å¯èƒ½æ€§ã‚‚ã‚ã‚Šã¾ã™ã€‚ãã®å ´åˆã€æŒ‡æ‘˜ã—ã¦ãã ã•ã‚‹ã¨ã‚ã‚ŠãŒãŸã„ã§ã™ã€‚manger attack ã¨ã¯ii ã®æ”»æ’ƒã«ã‚ã‚‹ Mangerâ€™s attack ã¨ã¯Manger ã•ã‚“ãŒ2001å¹´ã«å‡ºã—ãŸè«–æ–‡ã«èµ·å› ã—ã¦ Manger attack ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€OAEPã¨ã„ã†ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã«å¯¾ã™ã‚‹æ”»æ’ƒã«ç”¨ã„ã‚‰ã‚Œã‚‹ãã†ã§ã™ãŒã€ã“ã“ã§ã¯å†…å®¹ã‚’ãƒ¡ã‚¤ãƒ³ã§ã™ã‚‹ãŸã‚çœç•¥ã—ã¾ã™ã€‚æ”»æ’ƒæ‰‹æ³•ã®è¦ç´„STEP1è§£ã®ç¯„å›²ã‚’å¤§ã¾ã‹ã«çµã‚‹ã€‚(2åˆ†æ¢ç´¢)2æšç›®STEP2mã®å­˜åœ¨ç¯„å›²ã‚’ $[iN,iN+2B)$ ã«ç§»å‹•ãƒ»æ‹¡å¤§orç¸®å°ã™ã‚‹ã€‚STEP3oracleã§åˆ¤å®šã—äºŒåˆ†æ¢ç´¢ã™ã‚‹ã€‚äºŒåˆ†æ¢ç´¢å¾Œã¯ç¯„å›²ã®å ´æ‰€ã§ã‚ã‚‹ $[iN,iN+2B)$ ã‚’æº€ãŸã•ãªã„ã€‚ã‚ˆã£ã¦3.3ã§æ±‚ã‚ã‚‹$f_{tmp}$ã§æœ€å°å€¤ã¨æœ€å¤§å€¤ã®å·®ã‚’$2B$ã«ã™ã‚‹ã‚ˆã†ã«ç¯„å›²ã®ç¸®å°ºã‚’æ‹¡å¤§ã™ã‚‹ã€‚æ¬¡ã«ã€$f_3$ã«ãŠã„ã¦å¹³è¡Œç§»å‹•ã‚’è¡Œã„æœ€å°å€¤ã‚’ $iN$ ã®ã¨ã“ã‚ã¾ã§ã«ã™ã‚‹ã€‚çµæœã¨ã—ã¦ã€oracleã®$B$ä»¥ä¸Šã‹ä»¥ä¸‹ã‹ã®åˆ¤å®šã‚’ã†ã¾ãç”¨ã„ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã“ã‚Œã‚’ç¹°ã‚Šè¿”ã—ã€min ã¨ max ã®å€¤ãŒåŒã˜ã«ãªã‚Œã°çµ‚äº†ã— min ãŒç­”ãˆã®$m$ã¨ãªã‚‹ã“ã“ã§ã€rsa-interval-oracle ã®å€¤è¨­å®šã¯ $N = 2^{348}$ ã‚ˆã‚Šmanger attack ã‚’ä½¿ç”¨ã™ã‚‹éš›ã® $B$ ã®å€¤ã¯$B = 2^{( \\lceil \\log_{256} N \\rceil-1)}=376$ã¨ãªã‚‹ã€‚ã‚ˆã£ã¦iiã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ãŠã„ã¦ã€ã‚¯ã‚¨ãƒªã«376ã‚’æŠ•ã’ã¦ã‚„ã‚Œã° manger attack ãŒæˆç«‹ã§ã flag ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚èª¤å­—ãƒ»è„±å­—ãƒ»è¨‚æ­£ç­‰ã‚ã‚Šã¾ã—ãŸã‚‰ã€twitterã§ãŠçŸ¥ã‚‰ã›ãã ã•ã„â€¦" }, { "title": "2022-09-12-cakectf2022å‚åŠ è¨˜", "url": "/posts/cakectf2022/", "categories": "ctf", "tags": "ctf", "date": "2022-09-12 01:00:00 +0900", "snippet": "åˆã‚ã«2022å¹´9æœˆ3æ—¥(åœŸ)ã‹ã‚‰2022å¹´9æœˆ4æ—¥(æ—¥)ã¾ã§é–‹å‚¬ã•ã‚ŒãŸcakectfã«ã€Œkanonã€ã§å‚åŠ ã—ã¾ã—ã¦ã€é †ä½ã¯154ã§ã—ãŸã€‚(cryptoã—ã‹è§£ã„ã¦ãªã„ã‹ã‚‰ã‚ã‚Œãªã‚“ã§ã™ã‘ã©ã‚‚â€¦)ã¨ã„ã„ã¤ã¤å»å¹´ã¯ã€å…¨ãä½•ã‚‚è§£ã‘ãªã‹ã£ãŸã“ã¨ã‚’è€ƒãˆã‚‹ã¨æˆé•·ã—ã¦ã‚‹ãªãƒ¼ã¨ã„ã†æ°—åˆ†ã§ã—ãŸã€‚ç«¶æŠ€ä¸­ã¶ã£ã¡ã‚ƒã‘ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—å–ã£ã¦ãªã„ã®ã§ã†ã‚‹è¦šãˆã§æ›¸ã„ã¦ã¾ã™(fileã®ä¿å­˜æ™‚é–“è¦‹ã¦æ›¸ã„ã¦ã¾ã™)â€¦ä½™ã‚Šã‚ã¦ã«å‡ºæ¥ã¾ã›ã‚“ç«¶æŠ€é–‹å§‹(14:00)ã¨ã‚Šã‚ãˆãšã€å®¶ã«ã‚ã£ãŸãƒãƒ¼ã‚ºã‚±ãƒ¼ã‚­é£Ÿã¹ãªãŒã‚‰1 wavã®å•é¡Œ(frozen cake,brand new crypto)ã‚’ç¢ºèªã€‚frozen cake (14:20??)frozen cakeã‚’ã¿ã¦ã¨ã‚Šã‚ãˆãšã€ãƒ•ã‚§ãƒ«ãƒãƒ¼ã®å°å®šç†ã§æ›¸ãå‡ºã—ã¦ã¿ã‚‹ã‹ã§ã€å¼ã‚’æ›¸ãå‡ºã—ãŸã‚‰ãªã‚“ã‹ã†ã¾ãã„ã£ã¦flagã‚’getâ€¦!serverã«æå‡ºã—ãŸã‚‰ã€ã‚¨ãƒ©ãƒ¼?åã„ãŸã®ã§discordã§ç¢ºèªã™ã‚‹ã¨ä¿®æ­£ã™ã‚‹ã®ã§å¾…ã£ã¦ã¦ã­ã¨ã®ã“ã¨ãªã®ã§ã€brand new crypto ã‚’å–ã‚Šçµ„ã‚€ã“ã¨ã«â€¦brand new crypto (14:50??)åˆè¦‹ã½ã„æš—å·æ–¹å¼?ã ã£ãŸã®ã§ã€ä¸€åº¦å¼ã«æ›¸ãå‡ºã—ã¦è€ƒãˆã¦ã¿ã‚‹ã€‚æœ€åˆã¯ã€ä½•ã‹ã†ã¾ãæ¶ˆãˆã‚‹ã®ã‹ãªã¨æ€ã£ã¦ã„ãŸã‘ã©ã€ä¹±æ•°$r$ã§ã†ã¾ãã„ã‹ãªã„â€¦ã¨æ€ã£ã¦ã„ãŸã‚‰ã€å¼å¤‰å½¢ã—ã¦ $m$ ã®ã¹ãä¹—ãŒè¡¨ã›ã‚‹ã“ã¨ãŒã§ããŸã®ã§ 1 æ–‡å­—ãšã¤å¾©å·ã—ã¦ flag ã‚’ get å‡ºæ¥ã¾ã—ãŸã€‚å››ç•ªç›®ã«è§£ã‘ãŸã®ã§ã€Œã†ãŠãƒ¼ã€ã£ã¦ãƒ†ãƒ³ã‚·ãƒ§ãƒ³çˆ†ä¸ŠãŒã‚Š(3ä½ã«å…¥ã‚ŒãŸã“ã¨ä¸€åº¦ã‚‚ãªã„ã‚“ã§ã™ã‘ã©ã€ãªã‚“ã§ãã‚“ãªã¯ã‚„ã„ã‚“ã™ã‹â€¦)ã“ã“ã‹ã‚‰16æ™‚ã¾ã§youtubeã¿ã¦æ™‚é–“ã¤ã¶ã—â€¦(ä»–ã®ã‚¸ãƒ£ãƒ³ãƒ«ã¯åŸºç¤çŸ¥è­˜ãŒãªã•éãã¦ã¡ã‚‰ã£ã¨è¦‹ãŸã ã‘ã§å…¨ãåˆ†ã‹ã£ã¦ã¾ã›ã‚“â€¦)rock door (16:00)lunaticã®å•é¡ŒãŒè§£æ”¾ã•ã‚Œã€ rock door ã‚’è¦‹ã‚‹ã¨ã€DSAãƒ»hashã®çµ„ã¿åˆã‚ã›ã§ä¸€ç¬æˆ¸æƒ‘ã„ã¾ã—ãŸãŒã€ã¨ã‚Šã‚ãˆãšã‚³ãƒ¼ãƒ‰ã¨ã«ã‚‰ã‚ã£ã“ã—ãªãŒã‚‰å®Ÿè¡Œã—ã¦å†…å®¹ã®æŠŠæ¡ã™ã‚‹ã¨ s ã—ã‹è¿”ã•ãªã„dsaã§åˆã‚ã¦è¦‹ã¾ã—ãŸãŒã€ã¨ã‚Šã‚ãˆãšç«‹å¼ã™ã‚‹ã¨hashå–ã£ã¦ã‚‹ã®ã§bitãŒå°ã•ã„ãªãƒ¼ã¨æ€ã„ã¤ã¤ LLL ã‚’è¡Œã†ã®ãªã‚‰ $s = k^{-1}*(z + xr) mod q$ ã‚’ $sk = z + xr + Aq $ $s,q$ ã¯æ—¢çŸ¥ã¨è€ƒãˆã¦$x r$ã®å‡¦ç†ã‚’ã©ã†ã™ã‚Œã°ã„ã„ã®ã‹ã‚ã‹ã‚‰ãšæ’ƒæ²ˆã—ã¾ã—ãŸã€‚æ•—å› ã¯ $x r$ ã‚’åˆ†é›¢ã—ã¦ã—ã¾ã£ãŸã“ã¨ã§2å¤‰æ•°ã«ãªã£ã¦ã—ã¾ã„ï¼¼(^o^)ï¼ï½µï¾œï¾€ã“ã®å•é¡Œã«ç´„2æ™‚é–“30åˆ†ã‹ã‘ã¦è§£ã‘ãªã‹ã£ãŸã®ã¨ã€ã“ã®å¾Œã«ç”¨äº‹ãŒã‚ã£ãŸã®ã§ã“ã“ã§cakectfã¯æ–­å¿µã—ã¾ã—ãŸã€‚ã¾ã¨ã‚å¤šåˆ†ã€å®ŸåŠ›çš„ã« rock door ã¯è§£ã„ã¦ãŠããŸã‹ã£ãŸå•é¡Œã§ã—ãŸã­â€¦ã‚ã¨ã€write up ã¯ä»–ã®æ–¹ã‚’å‚ç…§ã•ã‚ŒãŸæ–¹ãŒã„ã„ã¨æ€ã„ã¾ã™ã€‚(æ™‚é–“ã‚‚ãŸã£ã¦ã‚‹ã—ã€ã‚¯ã‚ªãƒªãƒ†ã‚£ãŒä½ã„ã—ã§â€¦)ãªã‚“ã ã‹ã‚“ã ã€è‡ªåˆ†ã®æˆé•·ã‚’æ„Ÿã˜ãªãŒã‚‰ä¸Šã«ã¯ä¸ŠãŒã„ã‚‹ã“ã¨ã‚’æ”¹ã‚ã¦å®Ÿæ„Ÿã—ã¾ã—ãŸã®ã§ã€ã¨ã¦ã‚‚æ¥½ã—ã‚ã¾ã—ãŸã—ã€æ‚”ã—ã„æ€ã„ã‚’ã—ã¾ã—ãŸã€‚ãã‚“ãªã“ã‚“ãªã‚‚ã‚ã‚ŠãªãŒã‚‰ã€cakectf 2022 ã‚’é–‹å‚¬ã—ã¦ãã ã•ã£ãŸæ–¹ã€…ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚" }, { "title": "TFC CTF 2022 writeup", "url": "/posts/TFCCTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-07-31 19:00:00 +0900", "snippet": "æ¯æŠœãã«â€¦cryptoctfãŒé‡ã™ããŸâ€¦ã¦ã‹ã€ãã‚ãã‚first bloodã‚’ã¨ã‚ŠãŸã„ã™ã­â€¦EXCLUSIVE_ORACLE [75 solve]ç¹‹ã„ã§é©å½“ãªå€¤ã‚’å…¥ã‚Œã¾ãã£ã¦ã¿ã‚‹ã¨ã€è¿”ã‚Šå€¤ãŒ80æ–‡å­—ä»¥ä¸Šå¢—ãˆãªããªã‚‹ã€‚ã‚ˆã£ã¦ã€flagã¯åŠåˆ†ã®40æ–‡å­—ã¨æ¨æ¸¬ã§ãã€å…¥åŠ›å€¤ãŒ40æ–‡å­—ã§ã€flagãŒ40æ–‡å­—ã§å…±é€šéµæš—å·çš„ã«ä½•ãŒã§ãã‚‹ã‹ã¨ã„ã†ã¨xorã‹ãªãã¨â€¦keyã‚’å¾©å…ƒã—ã€flagã‚‚å¾©å…ƒã™ã‚‹ã¨ãƒ•ãƒ©ã‚°ãŒå–ã‚Œã‚‹ã„ã‚„ã“ã®å•é¡Œè¾›ããªã„????ãˆã€ãã†ã§ã‚‚ãªã„ã€ã€ãã†ã§ã™ã‹ã€‚ã€‚ã€‚solvefrom pwn import *from Crypto.Util.number import *io = remote( \"01.linux.challenges.ctf.thefewchosen.com\" ,54784)io.recvuntil(b\"&gt; \")io.sendline(b\"1\"*40)ret = eval(io.recvline(None).decode())key = bytes_to_long(ret[:40])^bytes_to_long(b\"1\"*40)print(long_to_bytes(bytes_to_long(ret[40:])^key))#TFCCTF{wh4t's_th3_w0rld_w1th0u7_3n1gm4?}TRAIN_TO_PADDINGTON [132 solves]challimport osBLOCK_SIZE = 16FLAG = b'|||REDACTED|||'def pad_pt(pt): amount_padding = 16 if (16 - len(pt) % 16) == 0 else 16 - len(pt) % 16 return pt + (b'\\x3f' * amount_padding)pt = pad_pt(FLAG)key = os.urandom(BLOCK_SIZE)ct = b''j = 0for i in range(len(pt)): ct += (key[j] ^ pt[i]).to_bytes(1, 'big') j += 1 j %= 16with open('output.txt', 'w') as f: f.write(ct.hex())solveã¾ã‚æ™®é€šã®xorã®å•é¡Œã§ã€å…ˆé ­ã¨å¾Œã‚ã§ãã‚Œãã‚Œ TFCCTF{ ã¨\\x3f*16 ã§xorå–ã£ã¦å‡ºã¦ããŸå€¤ãŒè¢«ã£ã¦ã„ã‚Œã°ç°¡å˜ã«å¾©å…ƒã§ãã‚‹ã‹ã‚‰è¢«ã‚ŠãŒã„ã„ãªãã¨ã‹æ€ã£ã¦ã„ãŸã‚‰æ™®é€šã«è¢«ã£ã¦ãŸã®ã§ç°¡å˜ã«keyãŒæ‰‹ã«å…¥ã£ãŸã€‚ã“ã®keyã‚’ä½¿ã£ã¦å¾©å…ƒã—ã¦ãŠã—ã¾ã„!from Crypto.Util.number import *from Crypto.Util.strxor import strxorct = bytes.fromhex(\"b4b55c3ee34fac488ebeda573ab1f974bf9b2b0ee865e45a92d2f14b7bdabb6ed4872e4dd974e803d9b2ba1c77baf725\")BLOCK_SIZE = 16cts = []for i in range(len(ct)//16): cts.append(ct[i*16:(i+1)*16])flag = b\"TFCCTF{\"len = len(flag)key = strxor(cts[0][:len], flag)key += strxor(cts[2], b\"\\x3f\"*16)[7:]flag = b\"\"for i in range(3): flag += strxor(cts[i], key)print(flag)# TFCCTF{th3_tr41n_h4s_l3ft_th3_st4t10n}ADMIN PANELchallimport osimport randomfrom Crypto.Cipher import AESKEY = os.urandom(16)PASSWORD = os.urandom(16)FLAG = os.getenv('FLAG')menu = \"\"\"========================1. Access Flag2. Change Password========================\"\"\"def xor(byte, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([byte ^ bytes_second[i]]) return ddef decrypt(ciphertext): iv = ciphertext[:16] ct = ciphertext[16:] cipher = AES.new(KEY, AES.MODE_ECB) pt = b'' state = iv for i in range(len(ct)): b = cipher.encrypt(state)[0] c = b ^ ct[i] pt += bytes([c]) print(b,c,pt) state = state[1:] + bytes([ct[i]]) return ptif __name__ == \"__main__\": while True: print(menu) option = int(input(\"&gt; \")) if option == 1: password = bytes.fromhex(input(\"Password &gt; \")) if password == PASSWORD: print(FLAG) exit(0) else: print(\"Wrong password!\") continue elif option == 2: token = input(\"Token &gt; \") if len(token) != 64: print(\"Wrong length!\") continue hex_token = bytes.fromhex(token) # r_byte = random.randbytes(1) r_byte = os.urandom(1) print(f\"XORing with: {r_byte.hex()}\") xorred = xor(r_byte[0], hex_token) PASSWORD = decrypt(xorred)solveåˆæ‰‹é©å½“ã«æ‰‹å…ƒã§2*64ä»£å…¥ã—ãŸã‚‰åˆã‚ã®ãƒã‚¤ãƒˆä»¥å¤–å…¨ã¦ã®ãƒã‚¤ãƒˆåˆ—ãŒåŒã˜ã‚‚ã®ãŒå‡ºã¦ããŸâ€¦ä½•ã‚‚è€ƒãˆãšã«Access Flagã§åˆã‚ã®å€¤ã®ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹ã§çµ‚ã‚ã‚Šã€‚ã¯ã„ã€ã¡ã‚ƒã‚“ã¨ã‚„ã‚Šã¾ã™ã€‚decrypté–¢æ•°ã«ãŠã„ã¦1å›ç›®ã®AESã§ã®å¹³æ–‡ã«ã‚ãŸã‚‹ã‚‚ã®ã¯ciphertext[:16]ã§ã€2å›ç›®ã®AESã§ã®å¹³æ–‡ã«ã‚ãŸã‚‹ã‚‚ã®ã¯ciphertext[1:17]ã¨iå›ç›®ã®å¹³æ–‡ã¯ciphertext[i-1:15+i]ã¨ãªã‚‹ã€‚ä»Šå›ã¯ã“ã‚Œã®å€¤ã‚’ä¸€å®šã«ã™ã‚‹ã¨\\(c\\)ã®å€¤ã‚‚ä¸€å®šã«ãªã‚Šã™ã”ãƒ¼ãã†ã‚Œã—ã„(PASSWORDã®æ–‡å­—åˆ—ãŒä¸€å®šã®æ–‡å­—ç¨®ãŒåˆ¶é™ã§ãã‚‹)from pwn import *from Crypto.Util.number import *from tqdm import tqdm# io = process(\"./main.py\")io = remote(\"01.linux.challenges.ctf.thefewchosen.com\", 54928)io.recvuntil(b\"&gt; \")io.sendline(b\"2\")io.recvuntil(b\"&gt; \")io.sendline(b\"2\"*64)for i in tqdm(range(256)): io.recvuntil(b\"&gt; \") io.sendline(b\"1\") # print(io.recvuntil(b\"&gt; \")) # print((long_to_bytes(1)*16).hex()) io.sendline((long_to_bytes(i)*16).hex().encode()) tmp = io.recvline() if b\"{\" in tmp: print(tmp) exit()# TFCCTF{l0g0n_z3r0_w1th_3xtr4_st3ps!}ADMIN PANEL BUT HARDERã€€[78 solves]challimport osimport randomfrom Crypto.Cipher import AESKEY = os.urandom(16)PASSWORD = os.urandom(16)FLAG = os.getenv('FLAG')menu = \"\"\"========================1. Access Flag2. Change Password========================\"\"\"def xor(bytes_first, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([bytes_first[i] ^ bytes_second[i]]) return ddef decrypt(ciphertext): iv = ciphertext[:16] ct = ciphertext[16:] cipher = AES.new(KEY, AES.MODE_ECB) pt = b'' state = iv for i in range(len(ct)): b = cipher.encrypt(state)[0] c = b ^ ct[i] pt += bytes([c]) state = state[1:] + bytes([ct[i]]) return ptif __name__ == \"__main__\": while True: print(menu) option = int(input(\"&gt; \")) if option == 1: password = bytes.fromhex(input(\"Password &gt; \")) if password == PASSWORD: print(FLAG) exit(0) else: print(\"Wrong password!\") continue elif option == 2: token = input(\"Token &gt; \") if len(token) != 64: print(\"Wrong length!\") continue hex_token = bytes.fromhex(token) r_bytes = random.randbytes(32) print(f\"XORing with: {r_bytes.hex()}\") xorred = xor(r_bytes, hex_token) PASSWORD = decrypt(xorred)solveADMIN PANELã‹ã‚‰å¤‰åŒ–ã—ãŸéƒ¨åˆ†ã¯Change Passwordã®ä¹±æ•°ã®éƒ¨åˆ†ãŒå¢—åŠ ã—ãŸã€‚ã“ã‚Œã§ã¯ä¸€å®šå€¤ã«å®šã‚ã‚‹ã®ãŒæ¥µã‚ã¦ã—ã‚“ã©ã„ã€‚ã€‚ãªã®ã§ã€Change Passwordã§ä¹±æ•°ã®å€¤ãŒè¿”ã£ã¦ãã‚‹ã“ã¨ã‚’åˆ©ç”¨ã—ã¦ä¹±æ•°äºˆæ¸¬ã‚’è¡Œã†!å¸°ã£ã¦ãã‚‹ä¹±æ•°ã¯32bytesã‚ˆã‚Šç´„80å›ç¨‹åº¦é›†ã‚ã‚Œã°ä¹±æ•°äºˆæ¸¬ãŒå¯èƒ½ã¨ãªã‚‹ã€‚ã‚ã¨ã¯ADMIN PANELã¨åŒã˜import randomfrom mt19937predictor import MT19937Predictorfrom pwn import *from Crypto.Util.number import *from tqdm import tqdm# io = process(\"./main.py\")io = remote(\"01.linux.challenges.ctf.thefewchosen.com\", 55172)def xor(bytes_first, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([bytes_first[i] ^ bytes_second[i]]) return dpredictor = MT19937Predictor()for _ in tqdm(range(120)): io.recvuntil(b\"&gt; \") io.sendline(b\"2\") io.recvuntil(b\"&gt; \") io.sendline(b\"2\"*64) x = bytes.fromhex(io.recvline(None).decode().split(\": \")[1]) # print(x) predictor.setrandbits(int.from_bytes(x, byteorder='little'), 8*32)next_rnd = predictor.getrandbits(8*32).to_bytes(32, 'little')io.recvuntil(b\"&gt; \")io.sendline(b\"2\")io.recvuntil(b\"&gt; \")msg = xor(b\"2\"*64 ,next_rnd)io.sendline(msg.hex().encode())ret = bytes.fromhex(io.recvline(None).decode().split(\": \")[1])# print(ret,next_rnd, long_to_bytes(tst))assert ret== next_rndprint(\"[+] YES!!!!! find seed \")# part2 for i in tqdm(range(256)): io.recvuntil(b\"&gt; \") io.sendline(b\"1\") # print(io.recvuntil(b\"&gt; \")) # print((long_to_bytes(1)*16).hex()) io.sendline((long_to_bytes(i)*16).hex().encode()) tmp = io.recvline() if b\"{\" in tmp: print(tmp) exit()# TFCCTF{n0_th3_fl4g_1s_n0t_th3_0ld_0n3_plus-Th3-w0rd_h4rd3r!}ADMIN PANEL BUT HARDER FIXEDã€€[50 solves ãƒ»56 solves]challimport osimport randomfrom Crypto.Cipher import AESKEY = os.urandom(16)PASSWORD = os.urandom(16)FLAG = os.getenv('FLAG')menu = \"\"\"========================1. Access Flag2. Change Password========================\"\"\"def xor(bytes_first, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([bytes_first[i] ^ bytes_second[i]]) return ddef decrypt(ciphertext): iv = ciphertext[:16] ct = ciphertext[16:] cipher = AES.new(KEY, AES.MODE_ECB) pt = b'' state = iv for i in range(len(ct)): b = cipher.encrypt(state)[0] c = b ^ ct[i] pt += bytes([c]) state = state[1:] + bytes([ct[i]]) return ptif __name__ == \"__main__\": while True: print(menu) option = int(input(\"&gt; \")) if option == 1: password = bytes.fromhex(input(\"Password &gt; \")) if password == PASSWORD: print(FLAG) exit(0) else: print(\"Wrong password!\") continue elif option == 2: token = input(\"Token &gt; \").strip() if len(token) != 64: print(\"Wrong length!\") continue hex_token = bytes.fromhex(token) r_bytes = random.randbytes(32) print(f\"XORing with: {r_bytes.hex()}\") xorred = xor(r_bytes, hex_token) PASSWORD = decrypt(xorred)solveéæƒ³å®šè§£ãŒã‚ã£ãŸã¿ãŸã„ã ã‘ã©ADMIN PANEL BUT HARDERã§ä½œã£ãŸè§£æ³•ã«ã¯å½±éŸ¿ãªã‹ã£ãŸã®ã§ã€ãã®ã¾ã¾letâ€™s go!!import randomfrom mt19937predictor import MT19937Predictorfrom pwn import *from Crypto.Util.number import *from tqdm import tqdm# io = process(\"./main.py\")io = remote(\"01.linux.challenges.ctf.thefewchosen.com\", 55225)def xor(bytes_first, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([bytes_first[i] ^ bytes_second[i]]) return dpredictor = MT19937Predictor()for _ in tqdm(range(120)): io.recvuntil(b\"&gt; \") io.sendline(b\"2\") io.recvuntil(b\"&gt; \") io.sendline(b\"2\"*64) x = bytes.fromhex(io.recvline(None).decode().split(\": \")[1]) # print(x) predictor.setrandbits(int.from_bytes(x, byteorder='little'), 8*32)next_rnd = predictor.getrandbits(8*32).to_bytes(32, 'little')io.recvuntil(b\"&gt; \")io.sendline(b\"2\")io.recvuntil(b\"&gt; \")msg = xor(b\"2\"*64 ,next_rnd)io.sendline(msg.hex().encode())ret = bytes.fromhex(io.recvline(None).decode().split(\": \")[1])# print(ret,next_rnd, long_to_bytes(tst))assert ret== next_rndprint(\"[+] YES!!!!! find seed \")# part2 for i in tqdm(range(256)): io.recvuntil(b\"&gt; \") io.sendline(b\"1\") # print(io.recvuntil(b\"&gt; \")) # print((long_to_bytes(1)*16).hex()) io.sendline((long_to_bytes(i)*16).hex().encode()) tmp = io.recvline() if b\"{\" in tmp: print(tmp) exit()# TFCCTF{4pp4r3ntly_sp4ces_br34ks_th3_0ld_0ne}" }, { "title": "Access Denied CTF 2022 writeup", "url": "/posts/Access-Denied-CTF-2022-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-06-12 19:30:00 +0900", "snippet": "æœ€è¿‘å‹‰å¼·ã—ãŸresultantã§è§£ã‘ãŸã®ã§ã‚ˆã‹ã£ãŸãªãâ€¦ã‚ã¨ã€ã¾ã˜ã§ãã‚ãã‚ctfã®ãƒãƒ¼ãƒ ã¯ã„ã‚ŠãŸã„ã‚ˆâ€¦æ°—ã‚’å–ã‚Šç›´ã—ã¦ã€æ­£è§£ãŒå°‘ãªã„2å•ã‚ã’ã¾ã™â€¦(ä¹±æ•°äºˆæ¸¬ã¯è§£ã‘ãªã‹ã£ãŸorz)[crypto] MITM-2 (17 solve)challalicefrom AES import encrypt, decrypt, paddingfrom binascii import hexlify, unhexlifyfrom hashlib import md5import osflag = b\"XXXXXX\"msg = b\"here_is_my_code!\"keys = [ b'XXXXXXXXXXXXXXXX', b'XXXXXXXXXXXXXXXX' ]g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977p = 174807157365465092731323561678,522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843private_key = 0 # Alice Private Keydef main():\tpublic_key = pow(g, private_key, p)\tprint(\"&gt; Here is my public key: {}\".format(public_key))\tkey = int(input(\"&gt; Your public key: \"))\tif(key == 0 or key == 1 or key == p - 1):\t\tprint(\"&gt; Ohhh...... Weak Keys\")\t\texit(0)\taes_key = md5(unhexlify(hex(pow(key, private_key, p))[2:])).digest()\tkeys.append(aes_key)\tencrypted_msg = encrypt(msg, keys, b\"A\"*16, b\"B\"*16)\tencrypted_flag = encrypt(flag[:32], keys, b\"A\"*16, b\"B\"*16)\tprint(\"&gt; Your output: {} {}\".format(hexlify(encrypted_msg), hexlify(encrypted_flag)))if __name__ == '__main__':\tmain()bobfrom AES import encrypt, decrypt, paddingfrom binascii import hexlify, unhexlifyfrom hashlib import md5import os# Alice and Bob keys are generated by [md5(os.urandom(3)).digest() for _ in rand]flag = b\"XXXXXX\" # flagkeys = [ b'XXXXXXXXXXXXXXXX', b'XXXXXXXXXXXXXXXX' ]msg = b\"thank_you_here_is_remaining_part\"g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977p = 174807157365465092731323561678522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843private_key = 0 # Bob private Keydef main():\tpublic_key = pow(g, private_key, p)\tprint(\"&gt; Here is my public key: {}\".format(public_key))\tkey = int(input(\"&gt; Your public key: \"))\t\tif(key == 0 or key == 1 or key == p - 1):\t\tprint(\"&gt; Ohhh...... Weak Keys\")\t\texit(0)\taes_key = md5(unhexlify(hex(pow(key, private_key, p))[2:])).digest()\tkeys.append(aes_key)\t\tcode = input(\"&gt; Give me the code(encrypted hex): \")\tdecrypted_code = decrypt(unhexlify(code), keys, b\"A\"*16, b\"B\"*16)\tif(decrypted_code[:32] == flag[:32]):\t\tencrypted_msg = encrypt(msg, keys, b\"A\"*16, b\"B\"*16)\t\tencrypted_flag = encrypt(flag[32:], keys, b\"A\"*16, b\"B\"*16)\t\tprint(\"&gt; Your output: {} {}\".format(hexlify(encrypted_msg), hexlify(encrypted_flag)))\telse:\t\tprint(\"&gt; You have given the wrong code\")if __name__ == '__main__':\tmain()AESfrom Crypto.Cipher import AESfrom binascii import hexlify, unhexlifyfrom hashlib import md5import osimport signaldef get_ciphers(keys, iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_ECB), AES.new(keys[1], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[2], mode=AES.MODE_CBC, iv=iv2) ]def padding(m): return m + os.urandom(16 - (len(m) % 16))def encrypt(m, keys, iv1, iv2): m = padding(m) ciphers = get_ciphers(keys, iv1, iv2) c = m for cipher in ciphers: c = cipher.encrypt(c) return cdef decrypt(c, keys, iv1, iv2): assert len(c) % 16 == 0 ciphers = get_ciphers(keys, iv1, iv2) m = c for cipher in ciphers[::-1]: m = cipher.decrypt(m) return msolveã“ã®å•é¡Œã¯DHéµå…±æœ‰ã®man-in-the-middleã¨AESã®meet-in-the-middleã‚’ã‹ã‘åˆã‚ã›ãŸå•é¡Œã€‚DHéµå…±æœ‰ã®partã¯ã“ã¡ã‚‰ã®å…±æœ‰éµãŒ\\(p-1,1,0\\)ã®å ´åˆä»¥å¤–ã«é€šã‚‹ã®ã§\\(-1\\)ã§é€šéã•ã›ã¦è§£æ±ºã€‚AESã®partã¯éµãŒos.urandom(3)ã§æ±ºã¾ã‚‹ã®ã§\\(256^3\\)ã®ã†ã¡ã®ã©ã‚Œã‹ä¸€ã¤ãªã®ã§meet-in-the-middleã§éµæ¨å®šã‚’è¡Œã†éµãŒã‚ã‹ã‚Œã°AES.pyã‚’ç”¨ã„ã¦flagå‡ºã—ã¦çµ‚ã‚ã‚Šfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom binascii import hexlify, unhexlifyfrom hashlib import md5from tqdm import tqdmfrom pwn import *import os from AES import encrypt, decrypt, paddingp = 174807157365465092731323561678522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843a_pub = 119411071723122444381767470125626227123727573250251216315907714124627930184475306091652961747380924296747933021923661790680670240155231816516457033069067832914869305822175715488571133446537348467810750635631617119618614773943953032009463487011337635599632404459399646451549811120239365019103442516813610951801g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977# Alice and Bob keys are generated by [md5(os.urandom(3)).digest() for _ in rand]def conection_alice(io): io.recvuntil(b\"ey: \") a_pub = int(io.recvline(None).decode()) io.recvuntil(b\"key: \") io.sendline(str(-1).encode()) io.recvuntil(b\"Your output: \") a = io.recvline(None).decode().split(\" \") encrypted_msg = bytes.fromhex( eval(a[0]).decode()) encrypted_flag =bytes.fromhex(eval(a[1]).decode()) io.close() print(\"[+] encrypted_msg\",encrypted_msg) print(\"[+] encrypted_flag\",encrypted_flag) return encrypted_msg,encrypted_flagdef conection_bob(io,enc): io.recvuntil(b\"ey: \") a_pub = int(io.recvline(None).decode()) io.recvuntil(b\"key: \") io.sendline(str(-1).encode()) io.recvuntil(b\"hex): \") io.sendline(enc.hex().encode()) io.recvuntil(b\"Your output: \") a = io.recvline(None).decode().split(\" \") encrypted_msg = bytes.fromhex( eval(a[0]).decode()) encrypted_flag =bytes.fromhex(eval(a[1]).decode()) io.close() print(\"[+] encrypted_msg\",encrypted_msg) print(\"[+] encrypted_flag\",encrypted_flag) return encrypted_msg,encrypted_flagdef MITM(encrypted_msg): aes_key =md5(unhexlify(hex(pow(-1, 1, p))[2:])).digest() # decrypt AES3 cipher3 = AES.new(aes_key, mode=AES.MODE_CBC, iv=b\"B\"*16) encrypted_msg = cipher3.decrypt(encrypted_msg) # ecrypt AES1 AES1 = [] for key in tqdm(range(0,256^3)): chipher = AES.new(md5(long_to_bytes(key)).digest(), mode=AES.MODE_ECB) AES1.append(chipher.encrypt(a_msg)) # decrypt AES2 AES2 =[] for key in tqdm(range(0,256^3)): chipher2 = AES.new(md5(long_to_bytes(key)).digest(), mode=AES.MODE_CBC, iv=b\"A\"*16) AES2.append(chipher2.decrypt(encrypted_msg)) AES3 = AES1+AES2 same = [k for k, v in collections.Counter(AES3).items() if v &gt; 1] if same!=None: print(\"[+] find meessage\") key1 = AES1.index(same[0]) key2 = AES2.index(same[0]) print(\"[+] find key1\",key1) print(\"[+] find key2\",key2) return key1 ,key2#----------------alice----------------------------io = remote(\"34.123.4.102\" ,4000)encrypted_msg,encrypted_flag = conection_alice(io)a_msg = b\"here_is_my_code!\"key1,key2 = MITM(encrypted_msg[:16])# key1 = 8148705# key2 = 14049457keys = [md5(long_to_bytes(key1)).digest(),md5(long_to_bytes(key2)).digest(),md5(unhexlify(hex(pow(-1, 1, p))[2:])).digest()]flag1 = decrypt(encrypted_flag, keys, b\"A\"*16, b\"B\"*16)[:-16]print(\"[+] flag &gt;\",flag1)#----------------bob----------------------------io = remote(\"34.123.4.102\" ,8000)encrypted_msg,encrypted_flag = conection_bob(io,encrypted_flag)print(\"[+] msg &gt;\",decrypt(encrypted_msg, keys, b\"A\"*16, b\"B\"*16))flag2 = decrypt(encrypted_flag, keys, b\"A\"*16, b\"B\"*16)[:-16]print(\"[+] flag &gt;\",flag2)print(\"[+] flag &gt;\",flag1+flag2)# accessdenied{m4n_1n_th3_m1ddl3_4nd_m33t_1n_th3_m1ddl3!_931a52e4}[crypto] ECC (19 solve)challimport tinyec.ec as ecimport tinyec.registry as regfrom hashlib import sha256from random import randintclass RNG: def __init__(self, seed): self.state = seed def next(self): self.state = self.state + 1 return self.statedef hashInt(msg): h = sha256(msg).digest() return int.from_bytes(h, 'big')def sign(msg): m = hashInt(msg) k = rand.next() R = k * G r = R.x s = pow(k, -1, n) * (m + r * d) % n return (r, s) def verify(msg, sig): r, s = sig m = hashInt(msg) sinv = pow(s, -1, n) u1 = m * sinv % n u2 = r * sinv % n R_ = u1 * G + u2 * Q r_ = R_.x return r_ == rC = reg.get_curve(\"secp256r1\")G = C.gn = C.field.nd = int(open(\"flag.txt\", \"rb\").read().hex(), 16)Q = d * Grand = RNG(randint(2, n-1))# Let's sign some msgsm1 = b\"crypto means cryptography\"m2 = b\"may the curve be with you\"m3 = b\"the annoying fruit equation\"sig1 = sign(m1)sig2 = sign(m2)sig3 = sign(m3)assert verify(m1, sig1)assert verify(m2, sig2)assert verify(m3, sig3)open(\"out.txt\", \"w\").write(f\"{sig1 = }\\n{sig2 = }\\n{sig3 = }\")solvesignã®å¼ãŒ\\(s_i={k_i}^{-1}(H(m_i)+r_{i}d) \\ \\ mod \\ \\ n\\)ã§ã‚ã‚ŠæœªçŸ¥ã®å¤‰æ•°ã¯\\(k_i,d\\)ã¨ãªã‚‹ã€‚ã“ã“ã§ã€RNGã®æ€§è³ªã§\\(k_{i+1}=k_i + 1\\)ã¨ãªã‚‹ã“ã¨ã‹ã‚‰ã€æœªçŸ¥ã®å¤‰æ•°\\(k_0,d\\)ã®2å¤‰æ•°ã¨ãªã‚‹ã€‚ãªã®ã§ã€resultantã‚’è¨ˆç®—ã—ã¦dã‚’æ±‚ã‚ã‚Œã°flagãŒæ‰‹ã«å…¥ã‚‹å¾Œã€å½“ãŸã‚Šå‰ã®ã‚ˆã†ã«ã‚°ãƒ¬ãƒ–ãƒŠãƒ¼åŸºåº•ã§ã‚‚è§£ã‘ãŸâ€¦æœ¬å½“ã«ã‚°ãƒ¬ãƒ–ãƒŠãƒ¼åŸºåº•ã®è§£ã‘ã‚‹æ¡ä»¶è€ƒãˆãªã„ã¨â€¦import tinyec.ec as ecimport tinyec.registry as regfrom hashlib import sha256from random import randintfrom Crypto.Util.number import *def hashInt(msg): h = sha256(msg).digest() return int.from_bytes(h, 'big')m0 = hashInt(b\"crypto means cryptography\")m1 = hashInt(b\"may the curve be with you\")m2 = hashInt(b\"the annoying fruit equation\")r,s = [0,0,0],[0,0,0]r[0],s[0] = (104643007282746168593080909181608136842069989473568245529813036758771329973363, 64857484327908680037110311008974831697501603147734264713321850573005484948766)r[1],s[1] = (103100238141753471646305398545577342208947972057548356113817050903685018825164, 68180337315087533969740301361624519816597436690234900639676209985924490588183)r[2],s[2] = (102982255637408147467745136566528008388200085481044044672245245459397287601125, 90628876174756318095385459486067833878236505125282311602737298420398366610196)C = reg.get_curve(\"secp256r1\")G = C.gn = C.field.nP.&lt;k, d&gt; = PolynomialRing(GF(n))def resultant(f1, f2, var): return Matrix(f1.sylvester_matrix(f2, var)).determinant()poly1 = m0 + r[0]*d - s[0]*kpoly2 = m1 + r[1]*d - s[1]*(k+1)poly12 = resultant(poly1, poly2, k)print(long_to_bytes(poly12.univariate_polynomial().roots()[0][0]))# b'accessdenied{ECDSA_w34k_RNG}'" }, { "title": "seccon beginners 2022 writeup", "url": "/posts/seccon-beginners-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-06-05 14:00:00 +0900", "snippet": "ã•ã™ãŒã«å»å¹´ã‚ˆã‚Šã¯æˆé•·ã—ãŸã‹ãªãã¨æ€ã„ã¾ã™â€¦[crypto] CoughingFox (404 solve)challfrom random import shuffleflag = b\"ctf4b{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}\"cipher = []for i in range(len(flag)): f = flag[i] c = (f + i)**2 + i cipher.append(c)shuffle(cipher)print(\"cipher =\", cipher)solveå¤šé …å¼ã§è¨ˆç®—ã—ãŸå¾Œã«\\(shuffle\\)ã§é…åˆ—ã®ä¸­èº«ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«å…¥ã‚Œæ›¿ãˆã¦ã„ã‚‹ã“ã“ã§ã€é©åˆ‡ãª\\(i\\)ä»¥å¤–ã¯rootã‚’å–ã‚‹éš›ã«è™šæ•°ã«ãªã‚‹ã“ã¨ã‚’åˆ©ç”¨ã—ã¦ç·å½“ãŸã‚Šã§æ±‚ã‚ã‚‹from Crypto.Util.number import *from sage.all import *import gmpy2 cipher = [12147, 20481, 7073, 10408, 26615, 19066, 19363, 10852, 11705, 17445, 3028, 10640, 10623, 13243, 5789, 17436, 12348, 10818, 15891, 2818, 13690, 11671, 6410, 16649, 15905, 22240, 7096, 9801, 6090, 9624, 16660, 18531, 22533, 24381, 14909, 17705, 16389, 21346, 19626, 29977, 23452, 14895, 17452, 17733, 22235, 24687, 15649, 21941, 11472]# print(gmpy2.iroot(12147,2))for i in range(len(cipher)): for k in range(len(cipher)): if gmpy2.iroot(cipher[k]-i,2)[1]==True: print(chr(gmpy2.iroot(cipher[k]-i,2)[0]-i),end=\"\") # ctf4b{Hey,Fox?YouCanNotTearThatHouseDown,CanYou?}[crypto] PrimeParty (57 solve)challfrom Crypto.Util.number import *from secret import flagfrom functools import reducefrom operator import mulbits = 256flag = bytes_to_long(flag.encode())assert flag.bit_length() == 455GUESTS = []def invite(p): global GUESTS if isPrime(p): print(\"[*] We have been waiting for you!!! This way, please.\") GUESTS.append(p) else: print(\"[*] I'm sorry... If you are not a Prime Number, you will not be allowed to join the party.\") print(\"-*-*-*-*-*-*-*-*-*-*-*-*-\")invite(getPrime(bits))invite(getPrime(bits))invite(getPrime(bits))invite(getPrime(bits))for i in range(3): print(\"[*] Do you want to invite more guests?\") num = int(input(\" &gt; \")) invite(num)n = reduce(mul, GUESTS)e = 65537cipher = pow(flag, e, n)print(\"n =\", n)print(\"e =\", e)print(\"cipher =\", cipher)solveã‚µãƒ¼ãƒå´ã§256bitã®ç´ æ•°4ã¤ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§3ã¤ã®ç´ æ•°ã‚’ç”¨ã„ã¦RSAæš—å·ã‚’è¡Œã† ãŸã ã€3ã¤ã®ç´ æ•°ã®é¸ã³æ–¹ã«ã‚ˆã£ã¦ã¯4ã¤ã®ç´ æ•°ã‚’ä½¿ã‚ãªãã¦ã‚‚å¾©å·ã§ãã‚‹å ´åˆãŒã‚ã‚Šã€ä»Šå›ã®å ´åˆ3ã¤ã®ç´ æ•°ã®åˆè¨ˆbitãŒ455bitã‚’å°‘ã—è¶…ãˆã‚‹ã‚ˆã†ã«è¨­å®šã™ã‚‹ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã ã‘ã®ç´ æ•°ã§å¾©å·ã§ãã‚‹from traceback import print_tbfrom Crypto.Util.number import *from pwn import *from sage.all import *from tqdm import tqdmbit = 160p = []for i in range(3): a = getPrime(bit) p.append(a) print(\"[+] prime &gt;\",a)io = remote( \"primeparty.quals.beginners.seccon.jp\" ,1336) io.recvuntil(b\" &gt; \")io.sendline(str(p[0]).encode())io.recvuntil(b\" &gt; \")io.sendline(str(p[1]).encode())io.recvuntil(b\" &gt; \")io.sendline(str(p[2]).encode())io.recvuntil(b\"n = \")n = int(io.recvline(None).decode())io.recvuntil(b\"e = \")e = int(io.recvline(None).decode())io.recvuntil(b\"cipher = \")ct = int(io.recvline(None).decode())inv =(p[0]-1)*(p[1]-1)*(p[2]-1)print(\"[+] inverse \",n//inv) d = pow(e,-1,inv)ct = ct%(p[0]*p[1]*p[2])print(long_to_bytes(pow(ct,d,p[0]*p[1]*p[2])))# ctf4b{HopefullyWeCanFindSomeCommonGroundWithEachOther!!!}[crypto] Command (85 solve)chall#! /usr/bin/env python3from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Util.number import isPrimefrom secret import FLAG, keyimport osdef main(): while True: print('----- Menu -----') print('1. Encrypt command') print('2. Execute encrypted command') print('3. Exit') select = int(input('&gt; ')) if select == 1: encrypt() elif select == 2: execute() elif select == 3: break else: pass print()def encrypt(): print('Available commands: fizzbuzz, primes, getflag') cmd = input('&gt; ').encode() if cmd not in [b'fizzbuzz', b'primes', b'getflag']: print('unknown command') return if b'getflag' in cmd: print('this command is for admin') return iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) enc = cipher.encrypt(pad(cmd, 16)) print(f'Encrypted command: {(iv+enc).hex()}')def execute(): inp = bytes.fromhex(input('Encrypted command&gt; ')) iv, enc = inp[:16], inp[16:] cipher = AES.new(key, AES.MODE_CBC, iv) try: cmd = unpad(cipher.decrypt(enc), 16) if cmd == b'fizzbuzz': fizzbuzz() elif cmd == b'primes': primes() elif cmd == b'getflag': getflag() except ValueError: print(\"pass\") passdef fizzbuzz(): for i in range(1, 101): if i % 15 == 0: print('FizzBuzz') elif i % 3 == 0: print('Fizz') elif i % 5 == 0: print('Buzz') else: print(i)def primes(): for i in range(1, 101): if isPrime(i): print(i)def getflag(): print(FLAG)if __name__ == '__main__': main()AESã®CBCãƒ¢ãƒ¼ãƒ‰ã‚’åˆ©ç”¨ã—ã¦getflagã®æš—å·åŒ–ã—ãŸã‚‚ã®ã‚’é€ã‚‹ã‚ˆã†ã«ã—ãŸã„AESã®CBCã®ç‰¹å¾´ã¨ã—ã¦åˆã‚ã®1ãƒ–ãƒ­ãƒƒã‚¯ã¯å¾©å·ã®æœ€å¾Œã«ivã¨XORå–ã£ã¦å¹³æ–‡ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¦ã„ã‚‹ã“ã‚Œã‚’é€†æ‰‹ã«ã¨ã£ã¦ä»»æ„ã®ivã‚’é€ã‚‹ã“ã¨ã§å¾©å·çµæœã«getflagã‚’å‡ºã™ã‚ˆã†ã«ã™ã‚Œã°ã„ã„solvefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Util.number import *from pwn import *io = remote(\"command.quals.beginners.seccon.jp\", 5555)io.recvuntil(b\"&gt; \")io.sendline(b\"1\")io.recvuntil(b\"&gt; \")io.sendline(b\"fizzbuzz\")io.recvuntil(b\"Encrypted command: \")tmp = io.recvline(None)iv,ct = int(tmp[:32],16),tmp[32:].decode()print(tmp)print(\"iv,ct\",iv,ct)mf = bytes_to_long(pad(b\"fizzbuzz\", 16))mg = bytes_to_long(pad(b\"getflag\", 16))new_iv = long_to_bytes(mf^iv^mg)print(new_iv)new_iv = new_iv.hex()print(new_iv)io.recvuntil(b\"&gt; \")io.sendline(b\"2\")io.recvuntil(b\"Encrypted command&gt; \") print(new_iv,ct)io.sendline((new_iv+ct).encode())io.interactive()# ctf4b{b1tfl1pfl4ppers}[crypto] omni-RSA (13 solve)challfrom Crypto.Util.number import *# from flag import flagp, q, r = getPrime(512), getPrime(256), getPrime(256)n = p * q * rphi = (p - 1) * (q - 1) * (r - 1)e = 2003d = inverse(e, phi)flag = bytes_to_long(flag.encode())cipher = pow(flag, e, n)s = d % ((q - 1)*(r - 1)) &amp; (2**470 - 1)print(\"rq =\", r % q)print(\"e =\", e)print(\"n =\", n)print(\"s =\", s)print(\"cipher =\", cipher)solveæ™®æ®µã®RSAã«ä»˜éšã—ã¦\\(d\\)ã®ä¸‹ä½469bitã¨\\(r\\)ã‚’\\(q\\)ã§å‰²ã£ãŸã‚ã¾ã‚ŠãŒä¸ãˆã‚‰ã‚Œã¦ã„ã‚‹æ–¹é‡ã¨ã—ã¦ã€\\(d_{qr}\\)ã¯\\(d\\)ã‚’\\((q-1)(r-1)\\)ã§å‰²ã£ãŸã‚ã¾ã‚Šã€\\(0 \\leq k \\leq e\\)ã¨ã™ã‚‹ã¨\\(d_{qr} = d_0 * 2^{470} + s - k*(q-1)*(r-1)\\)ã¨ã„ã†å¼ãŒæˆç«‹ã™ã‚‹ã“ã“ã§ã€\\(q\\)ã®å¤§ãã•ã¯256bitã§ã‚ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨ \\(d_{qr} \\equiv s - k*(q-1)*(r-1) mod(2^{256})\\)ã§ã‚‚æˆç«‹ã—ã€\\(r\\)ã‚’\\(q\\)ã§å‰²ã£ãŸã‚ã¾ã‚Šã«ç½®ãæ›ãˆã‚‹ã¨\\(d_{qr} \\equiv s - k*(q-1)*(q+rq-1) mod(2^{256})\\) ã“ã‚Œã‚’æº€ãŸã™\\(q\\)ã®ã©ã‚Œã‹ãŒä»Šå›ã®å•é¡Œã§ä½¿ã‚ã‚ŒãŸç´ æ•°\\(q\\)ã¨ãªã‚‹from Crypto.Util.number import *from tqdm import tqdmrq = 7062868051777431792068714233088346458853439302461253671126410604645566438638e = 2003n = 140735937315721299582012271948983606040515856203095488910447576031270423278798287969947290908107499639255710908946669335985101959587493331281108201956459032271521083896344745259700651329459617119839995200673938478129274453144336015573208490094867570399501781784015670585043084941769317893797657324242253119873s = 1227151974351032983332456714998776453509045403806082930374928568863822330849014696701894272422348965090027592677317646472514367175350102138331cipher = 82412668756220041769979914934789463246015810009718254908303314153112258034728623481105815482207815918342082933427247924956647810307951148199551543392938344763435508464036683592604350121356524208096280681304955556292679275244357522750630140768411103240567076573094418811001539712472534616918635076601402584666def find(d0, kbits, e, n): X = var('X') for k in tqdm(range(e+1, 1, -1)): results = solve_mod([k*(X-1)*(X+rq-1)+1 ==e*d0 ], 2^kbits) for x in results: if int(n)%int(x[0])==0: print(\"[+] find q --------\") print(\"q\",x[0]) print(\"------------\") return x[0]if __name__ == '__main__': # d0 = d &amp; (2^kbits-1) # print (\"lower %d bits (of %d bits) is given\" % (kbits, nbits)) # p = find_p(s, int(s).bit_length(), e, n) q = find(s,256, e, n) q = 108719400953000878740030929903618126158486070837750092259928673760881189657243 r = rq+q p = n//(r*q) assert n == p*q*r print (\"[+] good primes !!\") print (long_to_bytes(pow(cipher,inverse_mod(e, (p-1)*(q-1)*(r-1)),n))) # ctf4b{GoodWork!!!YouAreTrulyOmniscientAndOmnipotent!!!} " }, { "title": "Hero CTF v4 2022 writeup", "url": "/posts/HeroCTF-v4-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-05-29 23:00:00 +0900", "snippet": "æ¯æŠœãã«ãŸã ã€cryptoãŒå°‘ãªãã¦æ®‹å¿µâ€¦[crypto] Poly321chall#!/usr/bin/env python3FLAG = \"****************************\"enc = []for c in FLAG: v = ord(c) enc.append( v + pow(v, 2) + pow(v, 3) )print(enc)\"\"\"$ python3 encrypt.py[378504, 1040603, 1494654, 1380063, 1876119, 1574468, 1135784, 1168755, 1534215, 866495, 1168755, 1534215, 866495, 1657074, 1040603, 1494654, 1786323, 866495, 1699439, 1040603, 922179, 1236599, 866495, 1040603, 1343210, 980199, 1494654, 1786323, 1417584, 1574468, 1168755, 1380063, 1343210, 866495, 188499, 127550, 178808, 135303, 151739, 127550, 112944, 178808, 1968875]\"\"\"ãŸã ã®å¤šé …å¼ã ã‹ã‚‰sageã«è§£ã‹ã›ã¦çµ‚ã‚ã‚Šsolvefrom Crypto.Util.number import *from sage.all import *cts = [378504, 1040603, 1494654, 1380063, 1876119, 1574468, 1135784, 1168755, 1534215, 866495, 1168755, 1534215, 866495, 1657074, 1040603, 1494654, 1786323, 866495, 1699439, 1040603, 922179, 1236599, 866495, 1040603, 1343210, 980199, 1494654, 1786323, 1417584, 1574468, 1168755, 1380063, 1343210, 866495, 188499, 127550, 178808, 135303, 151739, 127550, 112944, 178808, 1968875]for ct in cts: var(\"v\") f = v + v**2+v**3-ct print(chr(int(str(solve(f,v)[2]).replace(\"v == \",\"\"))),end=\"\")# Hero{this_is_very_weak_encryption_92835208}[crypto] The oracleâ€™s apprenticechall#!/usr/bin/env python3from Crypto.Util.number import getStrongPrime, bytes_to_longimport randomFLAG = open('flag.txt','rb').read()encrypt = lambda m: pow(m, e, n)decrypt = lambda c: pow(c, d, n)e = random.randrange(3, 65537, 2)p = getStrongPrime(1024, e=e)q = getStrongPrime(1024, e=e)n = p * qÏ† = (p-1) * (q-1)d = pow(e, -1, Ï†)c = encrypt(bytes_to_long(FLAG))#print(f\"{n=}\")#print(f\"{e=}\")print(f\"{c=}\")for _ in range(3): t = int(input(\"c=\")) print(decrypt(t)) if c != t else Noneä½“ã®æº–åŒå‹ã®æ€§è³ªã‚’åˆ©ç”¨ã™ã‚‹\\((a*b)^e=a^e*b^e\\)ã“ã“ã§ã€1å›ç›®ã«é€ä¿¡ã™ã‚‹ã‚‚ã®ã‚’\\(c1\\),1å›ç›®ã«å—ä¿¡ã™ã‚‹ã‚‚ã®ã‚’\\(t1\\)ã¨ç½®ã \\(n\\)ã®å¾©å…ƒ \\(c1=-1 \\ mod \\ (n) â‡’ t1=n-1 \\ mod \\ (n)\\) \\(2^d\\)ã‚’æ±‚ã‚ã‚‹ \\(c2=2\\ mod\\ (n) â‡’ t2=2^d \\ mod \\ (n)\\)ã€€ \\((2*ct)^d\\)ã‚’æ±‚ã‚ã‚‹ \\(c3=2*ct \\ mod \\ (n) â‡’ t3=(2*ct)^d \\ mod \\ (n)\\)æœ€å¾Œã«\\(m = t3*t2^{-1} \\ mod \\ (n)\\)ã§å¾©å…ƒã§ãã‚‹solvefrom pwn import *from Crypto.Util.number import *io = remote(\"crypto.heroctf.fr\",9000)c = int(io.recvline(None).decode().replace(\"c=\",\"\"))io.recvuntil(b\"c=\")io.sendline(b\"-1\")n = int(io.recvline(None).decode())+1io.recvuntil(b\"c=\")io.sendline(b\"2\")d2 = int(io.recvline(None).decode())io.recvuntil(b\"c=\")io.sendline(str(2*c).encode())c2 = int(io.recvline(None).decode())print(long_to_bytes((c2*pow(d2,-1,n))%n))# Hero{m4ybe_le4ving_the_1nt3rn_run_th3_plac3_wasnt_a_g00d_id3a}" }, { "title": "cyberapocarypse 2022 writeup", "url": "/posts/cyberapocarypse-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-05-23 12:33:00 +0900", "snippet": "å»å¹´åˆã‚ã¦å‚åŠ ã—ãŸå¤§ä¼šãŒã“ã®å¤§ä¼šã§1å•ã—ã‹è§£ã‘ãªã‹ã£ãŸã€‚ã§ã‚‚ã€ä»Šå¹´ã¯crypto 7/10è§£ã‘ãŸã‚“ã§å‰²ã¨æº€è¶³ã—ã¦ã¾ã™..[crypto] Android-In-The-Middle [505 solve]challfrom Crypto.Cipher import AESfrom Crypto.Util.number import long_to_bytesimport hashlibimport randomimport socketserverimport signalFLAG = \"HTB{--REDACTED--}\"DEBUG_MSG = \"DEBUG MSG - \"p = 0x509efab16c5e2772fa00fc180766b6e62c09bdbd65637793c70b6094f6a7bb8189172685d2bddf87564fe2a6bc596ce28867fd7bbc300fd241b8e3348df6a0b076a0b438824517e0a87c38946fa69511f4201505fca11bc08f257e7a4bb009b4f16b34b3c15ec63c55a9dac306f4daa6f4e8b31ae700eba47766d0d907e2b9633a957f19398151111a879563cbe719ddb4a4078dd4ba42ebbf15203d75a4ed3dcd126cb86937222d2ee8bddc973df44435f3f9335f062b7b68c3da300e88bf1013847af1203402a3147b6f7ddab422d29d56fc7dcb8ad7297b04ccc52f7bc5fdd90bf9e36d01902e0e16aa4c387294c1605c6859b40dad12ae28fdfd3250a2e9g = 2class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): passdef sendMessage(s, msg): s.send(msg.encode())def recieveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip()def decrypt(encrypted, shared_secret): key = hashlib.md5(long_to_bytes(shared_secret)).digest() cipher = AES.new(key, AES.MODE_ECB) message = cipher.decrypt(encrypted) return messagedef main(s): sendMessage(s, DEBUG_MSG + \"Generating The Global DH Parameters\\n\") sendMessage(s, DEBUG_MSG + f\"g = {g}, p = {p}\\n\") sendMessage(s, DEBUG_MSG + \"Calculation Complete\\n\\n\") sendMessage(s, DEBUG_MSG + \"Generating The Public Key of CPU...\\n\") c = random.randrange(2, p - 1) C = pow(g, c, p) sendMessage(s, DEBUG_MSG + \"Calculation Complete\\n\") sendMessage(s, DEBUG_MSG + \"Public Key is: ???\\n\\n\") M = recieveMessage(s, \"Enter The Public Key of The Memory: \") try: M = int(M) except: sendMessage(s, DEBUG_MSG + \"Unexpected Error Occured\\n\") exit() sendMessage(s, \"\\n\" + DEBUG_MSG + \"The CPU Calculates The Shared Secret\\n\") shared_secret = pow(M, c, p) sendMessage(s, DEBUG_MSG + \"Calculation Complete\\n\\n\") encrypted_sequence = recieveMessage( s, \"Enter The Encrypted Initialization Sequence: \") try: encrypted_sequence = bytes.fromhex(encrypted_sequence) assert len(encrypted_sequence) % 16 == 0 except: sendMessage(s, DEBUG_MSG + \"Unexpected Error Occured\\n\") exit() sequence = decrypt(encrypted_sequence, shared_secret) if sequence == b\"Initialization Sequence - Code 0\": sendMessage(s, \"\\n\" + DEBUG_MSG + \"Reseting The Protocol With The New Shared Key\\n\") sendMessage(s, DEBUG_MSG + f\"{FLAG}\") else: exit()if __name__ == '__main__': socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), Handler) server.serve_forever()solveå…¸å‹çš„ãªAESæš—å·ã¨ã€DHã®å€¤ã‚’ä¸€æ„ã«å®šã‚ã‚ˆã†å•é¡Œfrom Crypto.Util.number import *from Crypto.Cipher import AESimport hashlibp = 0x509efab16c5e2772fa00fc180766b6e62c09bdbd65637793c70b6094f6a7bb8189172685d2bddf87564fe2a6bc596ce28867fd7bbc300fd241b8e3348df6a0b076a0b438824517e0a87c38946fa69511f4201505fca11bc08f257e7a4bb009b4f16b34b3c15ec63c55a9dac306f4daa6f4e8b31ae700eba47766d0d907e2b9633a957f19398151111a879563cbe719ddb4a4078dd4ba42ebbf15203d75a4ed3dcd126cb86937222d2ee8bddc973df44435f3f9335f062b7b68c3da300e88bf1013847af1203402a3147b6f7ddab422d29d56fc7dcb8ad7297b04ccc52f7bc5fdd90bf9e36d01902e0e16aa4c387294c1605c6859b40dad12ae28fdfd3250a2e9g = 2m = b\"Initialization Sequence - Code 0\"print(isPrime(p))def encrypt(message, shared_secret): key = hashlib.md5(long_to_bytes(shared_secret)).digest() cipher = AES.new(key, AES.MODE_ECB) encrypted = cipher.encrypt(message) return encryptedprint(encrypt(m, 1).hex())# HTB{7h15_p2070c0l_15_pr0tec73d_8y_D@nb3er_c0pyr1gh7_1aws}[crypto] Jenny From The Block [312 solve]challfrom hashlib import sha256from Crypto.Util.Padding import pad, unpadimport signalimport subprocessimport socketserverimport osallowed_commands = [b'whoami', b'ls', b'cat secret.txt', b'pwd']BLOCK_SIZE = 32def encrypt_block(block, secret): enc_block = b'' for i in range(BLOCK_SIZE): val = (block[i]+secret[i]) % 256 enc_block += bytes([val]) return enc_blockdef encrypt(msg, password): h = sha256(password).digest() print(\"firse_pass\",h) if len(msg) % BLOCK_SIZE != 0: msg = pad(msg, BLOCK_SIZE) blocks = [msg[i:i+BLOCK_SIZE] for i in range(0, len(msg), BLOCK_SIZE)] ct = b'' for block in blocks: enc_block = encrypt_block(block, h) h = sha256(enc_block + block).digest() ct += enc_block print(\"ct\",ct) return ct.hex()def run_command(cmd): if cmd in allowed_commands: try: resp = subprocess.run( cmd.decode().split(' '), capture_output=True) output = resp.stdout return output except: return b'Something went wrong!\\n' else: return b'Invalid command!\\n'def challenge(req): req.sendall(b'This is Jenny! I am the heart and soul of this spaceship.\\n' + b'Welcome to the debug terminal. For security purposes I will encrypt any responses.') while True: req.sendall(b'\\n&gt; ') command = req.recv(4096).strip() output = run_command(command) response = b'Command executed: ' + command + b'\\n' + output password = os.urandom(32) ct = encrypt(response, password) print(\"ct.hex\",ct) req.sendall(ct.encode())class incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(30) req = self.request challenge(req)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): passdef main(): socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever()if __name__ == \"__main__\": main()solveâ€œCommand executed: cat secret.txtâ€ãŒä¸åº¦32æ–‡å­—ãªã®ã§éµãŒå¾©å…ƒã§ãã‚‹ã“ã‚Œã‚’ç¹°ã‚Šè¿”ã—ã¦å¹³æ–‡ç‰¹å®šfrom hashlib import sha256from Crypto.Util.Padding import pad, unpadfrom pwn import *from Crypto.Util.number import *BLOCK_SIZE = 32io = remote(\"159.65.49.107\",31207)# io = remote(\"localhost\",1337)def decrypt_block_i(block,plain): return (block-plain) % 256def search_password(ct,plain): secret = b\"\" for i in range(BLOCK_SIZE): k = decrypt_block_i(ct[i],plain[i]) secret+=bytes([k]) print(secret) return secret def encrypt_block(block, secret): enc_block = b'' for i in range(BLOCK_SIZE): val = (block[i]-secret[i]) % 256 enc_block += bytes([val]) return enc_blockdef encrypt(msg, password): # h = sha256(password).digest() h = password if len(msg) % BLOCK_SIZE != 0: msg = pad(msg, BLOCK_SIZE) blocks = [msg[i:i+BLOCK_SIZE] for i in range(0, len(msg), BLOCK_SIZE)] ct = b'' # for block in blocks: for i in range(len(blocks)): dec_block = encrypt_block(blocks[i], h) h = sha256(blocks[i] + dec_block ).digest() ct += dec_block return ct def connection(io): io.recvuntil(\"&gt; \") command = b'cat secret.txt' io.sendline(command) ct = bytes.fromhex(io.recvline(None).decode()) response = b'Command executed: ' + command + b'\\n' + b'Invalid command!\\n' print(\"ct\",ct) print(\"ct[:32]\",ct[:32]) password = search_password(ct[:32],response[:32]) print(encrypt(ct,password)) connection(io)io.close()[crypto] The Three-Eyed Oracle [264 solve]challfrom tarfile import BLOCKSIZEfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport randomimport signalimport subprocessimport socketserverimport os# FLAG = b''FLAG = b'HTB{--REDACTED--}'# prefix = random.randbytes(12)# key = random.randbytes(16)prefix = os.urandom(12)key = os.urandom(16)print(prefix)BLOCKSIZE = 16def encrypt(key, msg): msg = bytes.fromhex(msg) crypto = AES.new(key, AES.MODE_ECB) padded = pad(prefix + msg + FLAG, 16) # print(\"padded\",padded) print(\"padded\",[padded[i*BLOCKSIZE:(i+1)*BLOCKSIZE] for i in range(len(padded)//BLOCKSIZE)]) print(\"enc\",[crypto.encrypt(padded)[i*BLOCKSIZE:(i+1)*BLOCKSIZE] for i in range(len(crypto.encrypt(padded))//BLOCKSIZE)]) return crypto.encrypt(padded).hex()def challenge(req): req.sendall(b'Welcome to Klaus\\'s crypto lab.\\n' + b'It seems like there is a prefix appended to the real firmware\\n' + b'Can you somehow extract the firmware and fix the chip?\\n') while True: req.sendall(b'&gt; ') # try: msg = req.recv(4096).decode() print(\"msg decode \",msg) ct = encrypt(key, msg) # except: # req.sendall(b'An error occurred! Please try again!') req.sendall(ct.encode() + b'\\n')class incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(1500) req = self.request challenge(req)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): passdef main(): socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever()if __name__ == \"__main__\": main()AES ECBã®plaintext recovery attackè©³ã—ãã¯ggã£ã¦ã‚‚ã‚‰ã£ã¦solvefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *from tqdm import tqdmimport randomfrom pwn import *io = remote(\"134.209.29.182\",30681)# io = remote(\"localhost\",1337)BLOCKSIZE = 16PTSIZE = 32def send_m(m): io.recvuntil(b\"&gt; \") # print(\"send_m\",(b\"1\"*4+m).hex().encode()) io.sendline((b\"a\"*4+m).hex().encode()) re = bytes.fromhex(io.recvline(None).decode()) return [re[i*BLOCKSIZE:(i+1)*BLOCKSIZE] for i in range(len(re)//BLOCKSIZE)]def plaintxt_recavary(): PTSIZE = 9 print(\"PTSIZE\",PTSIZE) # list m = b\"\" for i in range(1,PTSIZE): target = send_m(b\"0\"*(BLOCKSIZE-i))[1] for k in tqdm(range(70,0x100)): a = b\"0\"*(BLOCKSIZE-i)+m+bytes([k]) tmp = send_m(a)[1] if tmp== target: m =m + bytes([k]) break return mprint(plaintxt_recavary())[crypto] How The Columns Have Turned [239 solve]challimport oswith open('super_secret_messages.txt', 'r') as f: SUPER_SECRET_MESSAGES = [msg.strip() for msg in f.readlines()]def deriveKey(key): derived_key = [] for i, char in enumerate(key): previous_letters = key[:i] new_number = 1 for j, previous_char in enumerate(previous_letters): if previous_char &gt; char: derived_key[j] += 1 else: new_number += 1 derived_key.append(new_number) return derived_keydef transpose(array): return [row for row in map(list, zip(*array))]def flatten(array): return \"\".join([i for sub in array for i in sub])def twistedColumnarEncrypt(pt, key): derived_key = deriveKey(key) print(derived_key) width = len(key) blocks = [pt[i:i + width] for i in range(0, len(pt), width)] print(blocks) blocks = transpose(blocks) print(\"blocks\",blocks) print(derived_key.index(2)) for i in range(width): print(derived_key.index(i + 1),blocks[derived_key.index(i + 1)]) ct = [blocks[derived_key.index(i + 1)][::-1] for i in range(width)] print(ct) ct = flatten(ct) print(ct) return ctclass PRNG: def __init__(self, seed): self.p = 0x2ea250216d705 self.a = self.p # self.b = int.from_bytes(os.urandom(16), 'big') self.b = 729513912306026 self.rn = seed def next(self): self.rn = ((self.a * self.rn) + self.b) % self.p return self.rndef main(): seed = int.from_bytes(os.urandom(16), 'big') rng = PRNG(seed) cts = \"\" for message in SUPER_SECRET_MESSAGES: key = str(rng.next()) ct = twistedColumnarEncrypt(message, key) cts += ct + \"\\n\" with open('encrypted_messages.txt', 'w') as f: f.write(cts) dialog = \"Miyuki says:\\n\" dialog += \"Klaus it's your time to sign!\\n\" dialog += \"All we have is the last key of this wierd encryption scheme.\\n\" dialog += \"Please do your magic, we need to gather more information if we want to defeat Draeger.\\n\" dialog += f\"The key is: {str(key)}\\n\" with open('dialog.txt', 'w') as f: f.write(dialog)if __name__ == '__main__': main()solvePNRGã‹ã¨æ€ã„ãã‚„\\(a=p\\)ã‚ˆã‚Šnexté–¢æ•°ã®å‡ºåŠ›å€¤ã¯\\(b\\)å›ºå®šã«ãªã‚Šé–¢ä¿‚ãªããªã‚‹ã‚ã¨ã¯ãƒ–ãƒ­ãƒƒã‚¯æš—å·ã‚’å…ƒã«æˆ»ã—ã¦ã„ãã ã‘key = 729513912306026import osclass PRNG: def __init__(self, seed): self.p = 0x2ea250216d705 self.a = self.p self.b = 729513912306026 self.rn = seed def next(self): self.rn = ((self.a * self.rn) + self.b) % self.p return self.rndef deriveKey(key): derived_key = [] # print(\"key\",key) for i, char in enumerate(key): # print(\" i, char\", i, char) previous_letters = key[:i] new_number = 1 for j, previous_char in enumerate(previous_letters): # print(\"i,j, previous_char \",i,j, previous_char ) if previous_char &gt; char: derived_key[j] += 1 else: new_number += 1 # print(\"new_number\",new_number) # print(\"derived_key\",derived_key) derived_key.append(new_number) return derived_keydef transpose(array): return [row for row in map(list, zip(*array))]def flatten(array): return \"\".join([i for sub in array for i in sub])def twistedColumnarEncrypt(pt, key): derived_key = deriveKey(key) print(derived_key) width = len(key) blocks = [pt[i:i + width] for i in range(0, len(pt), width)] print(blocks) blocks = transpose(blocks) print(blocks) print(derived_key.index(1)) print(blocks[derived_key.index(1)][::-1]) ct = [blocks[derived_key.index(i + 1)][::-1] for i in range(width)] print(ct) ct = flatten(ct) print(ct) return cttwistedColumnarEncrypt(\"123456789012345543210987654321\", str(key))[crypto] MOVs Like Jagger [107 solve]challfrom ecdsa import ellipticcurve as eccfrom random import randinta = -35b = 98p = 434252269029337012720086440207Gx = 16378704336066569231287640165Gy = 377857010369614774097663166640ec_order = 434252269029337012720086440208E = ecc.CurveFp(p, a, b)G = ecc.Point(E, Gx, Gy, ec_order)def generateKeyPair(): private = randint(1, 2**64) public = G * private return(public, private)def calculatePointsInSpace(): Q, nQ = generateKeyPair() P, nP = generateKeyPair() return [Q, nQ, P, nP]def checkCoordinates(data: dict) -&gt; list: if data['destination_x'] == \"\" or data['destination_y'] == \"\": raise ValueError('Empty coordinates...') try: destination_x = int(data['destination_x'], 16) destination_y = int(data['destination_y'], 16) except: raise ValueError('Coordinates are not in the right format (hex)') return (destination_x, destination_y)def checkDestinationPoint(data: dict, P: ecc.Point, nQ: int, E: ecc.CurveFp) -&gt; list: # destination_x, destination_y = checkCoordinates(data) destination_x, destination_y = data destination_point = ecc.Point(E, destination_x, destination_y, ec_order) secret_point = P * nQ print(\"secret_point = P * nQ\",secret_point , P , nQ) same_x = destination_point.x() == secret_point.x() same_y = destination_point.y() == secret_point.y() if (same_x and same_y): return True else: return Falseif \"__main__\"==__name__: Q, nQ, P, nP = calculatePointsInSpace() print(Q, nQ, P, nP ) checkDestinationPoint([Gx, Gy],P,nQ,E)solveå…¸å‹çš„ãªECCã®å•é¡Œã€‚ãŸã ã€\\(p\\)ãŒç´ æ•°ã§ãªã„ã®ã§å› æ•°åˆ†è§£ã‚’æ–½ã™ã¨ã„ã„æ„Ÿã˜ã«ã°ã‚‰ã‘ãŸã®ã§Pohligâ€“Hellman algorithmã§è§£ã„ã¦ã„ãfrom sage.all import *#ç´ æ•°ã¯å°ã•ã‘ã‚Œã°å°ã•ã„ã»ã†ãŒã„ã„ãŒå¤§ãã„ã‚‚ã®ã‚‚å ´åˆã«ã‚ˆã£ã¦ã¯å¿…è¦#[s]P1 = P2# fac = Ep.order())def Pohlig_Hellman(P1,P2,fac): primes = [] for i in range(len(fac)-1): primes.append(fac[i][0]**fac[i][1]) #primes =[ 7 , 11 , 17 , 191 , 317 , 331 , 5221385621 , 5397618469 , 210071842937040101 , 637807437018177170959577732683] dlogs = [] for fac in primes[:]: t = int(P1.order()) // int(fac) dlog = (t*P1).discrete_log(t*P2) #discrete_log(t*sGq, t*Gq, operation=\"+\") dlogs += [dlog] print(\"factor: \"+str(fac)+\", Discrete Log: \"+str(dlog)) #calculates discrete logarithm for each prime order return crt(dlogs, primes[:])a = -35b = 98p = 434252269029337012720086440207Gx = 16378704336066569231287640165Gy = 377857010369614774097663166640ec_order = 434252269029337012720086440208E = EllipticCurve(GF(p),[a,b]){\"departed_x\":\"0x3b41ebf4c4afc44b98bc8542\",\"departed_y\":\"0xd8d92015d026528a7dbc3309\",\"present_x\":\"0x2f8756f6476af7a24952eb8e3\",\"present_y\":\"0x1a61b777121c1d25bfd6c2f48\"}G = E(Gx,Gy)Q = E(0x3b41ebf4c4afc44b98bc8542,0xd8d92015d026528a7dbc3309)P = E(0x2f8756f6476af7a24952eb8e3,0x1a61b777121c1d25bfd6c2f48)nP = Pohlig_Hellman(G,P,factor(ec_order))print(nP,(360301137196997).bit_length())for i in range(360301137196997): if ((ec_order//360301137196997)*i+nP)*G==P: print(i) breaknP = (ec_order//360301137196997)*i+nPnQ = Pohlig_Hellman(G,Q,factor(ec_order))print(nQ,(360301137196997).bit_length())for i in range(360301137196997): if ((ec_order//360301137196997)*i+nQ)*G==Q: print(i) breaknQ=(ec_order//360301137196997)*i+nQprint(nP*(nQ*G))print()[crypto] Find Marherâ€™s Secret [70 solve]challimport randomimport signalimport subprocessimport socketserverimport jsonimport osfrom Crypto.Cipher import ARC4, AESimport osimport hashlibfrom secret import FLAG, KEYdef encrypt(key, iv, pt): return ARC4.new(iv + key).encrypt(pt).hex()def challenge(req): key = bytes.fromhex(KEY) assert(len(key) == 27) req.sendall(b'Connected to the cyborg\\'s debugging interface\\n') while True: req.sendall( b'\\nOptions:\\n1. Encrypt your text.\\n2. Claim the key.\\n&gt; ') try: response = json.loads(req.recv(4096).decode()) if response['option'] == 'encrypt': iv = bytes.fromhex(response['iv']) pt = bytes.fromhex(response['pt']) ct = encrypt(key, iv, pt) payload = {'response': 'success', 'pt': response['pt'], 'ct': ct} payload = json.dumps(payload) req.sendall(payload.encode()) elif response['option'] == 'claim': answer = bytes.fromhex(response['key']) if hashlib.sha256(answer).hexdigest() == hashlib.sha256(key).hexdigest(): payload = {'response': 'success', 'flag': FLAG} payload = json.dumps(payload) req.sendall(payload.encode()) else: payload = {'response': 'fail', 'message': 'Better luck next time.'} payload = json.dumps(payload) req.sendall(payload.encode()) else: payload = {'response': 'error', 'message': 'Invalid option!'} payload = json.dumps(payload) req.sendall(payload.encode()) except Exception as e: payload = json.dumps( {'response': 'error', 'message': 'An error occured!'}) req.sendall(payload.encode()) returnclass incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(6000) req = self.request challenge(req)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): passdef main(): socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever()if __name__ == \"__main__\": main()solveRC4ã‹ã¤ã‚ªãƒ©ã‚¯ãƒ«ãŒç„¡åˆ¶é™ã«ä½¿ãˆã‚‹ã®ã§Fluhrer-Mantin-Shamir attackã§çµ‚ã‚ã‚Šfrom Crypto.Cipher import ARC4, AESfrom pwn import *import jsonfrom collections import Counterfrom tqdm import tqdmio = remote(\"157.245.33.77\",32157)io.recvuntil(b\"&gt; \")def encrypt_oracle(iv,pt): # def _encrypt(self, iv, key, p): # return ARC4.new(iv + key).encrypt(p) payload = {'option': 'encrypt', 'iv': iv.hex(), 'pt': pt.hex()} # print(payload) payload = json.dumps(payload) io.sendline(payload.encode()) a = io.recvline(None).decode() # print(a) response = json.loads(a) # print(response['pt']) # print(response['ct']) io.recvuntil(b\"&gt; \") return bytes.fromhex(response['ct']) def possible_key_bit(key, c): s = [i for i in range(256)] j = 0 for i in range(len(key)): j = (j + s[i] + key[i]) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp return (c[0] - j - s[len(key)]) % 256def attack(encrypt_oracle, key_len): \"\"\" Recovers the hidden part of an RC4 key using the Fluhrer-Mantin-Shamir attack. :param encrypt_oracle: the padding oracle, returns the encryption of a plaintext under a hidden key concatenated with the iv :param key_len: the length of the hidden part of the key :return: the hidden part of the key \"\"\" key = bytearray([3, 255, 0]) for a in range(key_len): key[0] = a + 3 possible = Counter() for x in tqdm(range(256)): key[2] = x # iv ,pt c = encrypt_oracle(key[:3], b\"\\x00\") possible[possible_key_bit(key, c)] += 1 key.append(possible.most_common(1)[0][0]) print(key) return key[3:]# print(attack(encrypt_oracle,27))key = b'\\x1f\\xec\\x07\\x87\\xbd\\x1aR\\xad\\xe6:7\\x9a &lt;+\\xe9+\\x98\\x1e\\xb1\\x17\\xda\\xc4\\x03N\\xcc\\xe0'# def _encrypt(self, iv, key, p):# return ARC4.new(iv + key).encrypt(p)payload = {'option': 'claim', 'key': key.hex()}# print(payload)payload = json.dumps(payload)io.sendline(payload.encode())a = io.recvline(None).decode()print(a)response = json.loads(a)print(response['flag'])# print(response['ct'])io.recvuntil(b\"&gt; \")[crypto] Down the Rabinhole [74 solve]challfrom Crypto.Util.number import getPrime, isPrime, bytes_to_longfrom Crypto.Util.Padding import padimport osFLAG = b\"HTB{--REDACTED--}\"def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, qdef encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 64)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2)def main(): coefficient = getPrime(128) out = \"\" message = FLAG[0:len(FLAG)//2] n1, c1, c2 = encrypt(message, coefficient) out += f\"{n1}\\n{c1}\\n{c2}\\n\" message = FLAG[len(FLAG)//2:] n2, c3, c4 = encrypt(message, coefficient) out += f\"{n2}\\n{c3}\\n{c4}\" with open(\"out.txt\", \"w\") as f: f.write(out)if __name__ == '__main__': main()solve\\(n1=(3*coff*a_{1}+2)(3*coff*b_{1}+2)\\),\\(n2=(3*coff*a_2+2)(3*coff*b_2+2)\\)ã€€ã‚ˆã‚Š\\(coff = gcd(n1-4,n2-4)\\)ã‚ˆã£ã¦\\(coff\\)ãŒç‰¹å®šã§ããŸã®ã§mod \\(n\\) ä¸Šã®äºŒæ¬¡å¤šé …å¼ã‚’è§£ã‘ã°ç­”ãˆãŒå‡ºã‚‹from tqdm import tqdmfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *n1 = 59695566410375916085091065597867624599396247120105936423853186912270957035981683790353782357813780840261434564512137529316306287245132306537487688075992115491809442873176686026221661043777720872604111654524551850568278941757944240802222861051514726510684250078771979880364039814240006038057748087210740783689350438039317498789505078530402846140787188830971536805605748267334628057592989c1 = 206131769237721955001530863959688756686125485413899261197125641745745636359058664398433013356663394210624150086689905532c2 = 14350341133918883930676906390648724486852266960811870561648194176794020698141189777337348951219934072588842789694987397861496993878758159916334335632468891342228755755695273096621152247970509517996580512069034691932835017774636881861331636331496873041705094768329156701838193429109420730982051593645140188946n2 = 56438641309774959123579452414864548345708278641778632906871133633348990457713200426806112132039095059800662176837023585166134224681069774331148738554157081531312104961252755406614635488382297434171375724135403083446853715913787796744272218693049072693460001363598351151832646947233969595478647666992523249343972394051106514947235445828889363124242280013397047951812688863313932909903047c3 = 429546912004731012886527767254149694574730322956287028161761007271362927652041138366004560890773167255588200792979452452c4 = 29903904396126887576044949247400308530425862142675118500848365445245957090320752747039056821346410855821626622960719507094119542088455732058232895757115241568569663893434035594991241152575495936972994239671806350060725033375704703416762794475486000391074743029264587481673930383986479738961452214727157980946## coff partprint(gcd(n1-4,n2-4),int(gcd(n1-4,n2-4)).bit_length())for i in range(1,1&lt;&lt;(int(gcd(n1-4,n2-4)).bit_length()-128)): if gcd(n1-4,n2-4)%i==0: print(i)coff = 263063435253385937926984981365320113271assert isPrime(coff)# c1 = x(x+coff) mod n# c2 = (x*1&lt;&lt;k+l)*(x*1&lt;&lt;k+l+coff) mod nm_t = []def search(k,N,C1,C2): l = bytes_to_long(pad(b\"1\"*(64-k), 64)[-1*k:]) # print(pad(b\"1\"*(64-k), 64)) # print(pad(b\"1\"*(64-k), 64)[-1*k:]) # print(long_to_bytes(bytes_to_long(b\"1\"*(64-k))&lt;&lt;(8*k))) # print(l) # exit() padding = 1&lt;&lt;(8*k) #c1 C1 = C1 C1_coff = coff # #c2 C2 = (C2-l*(l+coff))*pow(padding,-2,N) C2_coff = (2*l+coff)*pow(padding,-1,N) #C2-C1 = (C2_coff-C1_coff)*m m = ((C2-C1)*pow(C2_coff-C1_coff,-1,N))%N # print(long_to_bytes(m)) return long_to_bytes(m) for i in range(2,64): if b'HTB{' in search(i,n1,c1,c2): print(search(i,n1,c1,c2))for i in range(2,64): if search(i,n2,c3,c4).endswith(b\"}\"): print(search(i,n2,c3,c4))# 'HTB{gcd_+_2_*_R@6in_.|5_thi5_@_cro55over_epi5ode?}" } ]
