[ { "title": "ACSC 2023 crypto jenga", "url": "/posts/jenga/", "categories": "writeup", "tags": "writeup", "date": "2024-04-02 00:00:00 +0900", "snippet": "Jengaこの問題はAESをベースにした問題で変更点は2点あります。 ShiftRowsがhoriという関数に、MixColumnsがvertという関数に対応しています。（内容の差異は後で） 更に奇数ラウンドではhoriのみ使われ、逆に偶数ラウンドではvertが使われます。AESの攻撃って基本的にいろいろありますが、代表的なものとして、線形解読法(linear cryptanalysis)や差分解読法(different cryptanalysis)、SboxをAffineとしてlinearととらえるものがありますよね。この問題では、AESで解析でよく用いられているsquare attackというものを用いて攻撃を行います。注意としてこの問題では3×3の行列やアルゴリズムが異なるものを扱っている都合、AESとは一部攻撃方法が異なる部分があります。各関数についてhoriAESで言うとShiftRowsにあたる部分で、数式では$HORI$として、逆関数を$HORI_INV$としておきます。horiは水平に3回行いますが簡略化のため1行のみ記載しています。\\(HORI(x) = (4\\*x_0+2\\*x_1+x_2,x_0+4\\*x_1+2\\*x_2,2\\*x_0+x_1+4\\*x_2)\\)​さらに、\\(HORI(x\\oplus y) = (4\\*(x_0\\oplus y_0)+2\\*(x_1\\oplus y_1)+(x_2\\oplus y_2),(x_0\\oplus y_0)+4\\*(x_1\\oplus y_1)+2\\*(x_2\\oplus y_2),2\\*(x_0\\oplus y_0)+(x_1\\oplus y_1)+4\\*(x_2\\oplus y_2) =\\\\((4\\*x_0+2\\*x_1+x_2)\\oplus (4\\*y_0+2\\*y_1+y_2),(x_0+4\\*x_1+2\\*x_2) \\oplus (y_0+4\\*y_1+2\\*y_2),(2\\*x_0+x_1+4\\*x_2)\\oplus(2\\*y_0+y_1+4\\*y_2))=\\\\HORI(x)\\oplus HORI(y)\\)という分配則も成り立ちます。vertAESで言うとMixColumnsにあたる部分で、数式では$VERT$とし、逆関数を$VERT_INV$としておきます。今回の関数において、vertは垂直に3回行いますが計算内容はhoriと同じため省略します。また分配則も成立します。xorAESで言うとAddRoundKeyにあたる部分で、数式では$i$ roundのxorを$XOR_i$とし、逆関数を$XOR_i_INV$としておきます。sboxAESで言うとSubBytesにあたる部分で、数式では$sbox$、逆関数を$sbox_INV$とします。Square attack1byteだけ変えた入力を繰り返し行い出力の関係性を見ることで鍵を求めてみようというものです。round 11roundだけ見ていきます。入力として、緑の部分だけ変えて、後は固定の値を与えるとします。具体的には[bytes([i])+b\"\\x00\"*8 for i in range(256)]みたいな感じです。結果として、下の図のように変化させた部分が緑の部分へ影響を及ぼしていることがわかります。ただ、このうち6つ分の値は影響を受けないため固定なため白にしています。ここでわかっている部分や計算可能な部分を青で塗りつぶします。horiとsboxは逆関数が存在することで結果的には全ての状態の値がわかります。ということはxorの値もわかるので1roundは簡単に鍵が求まるということになります。式で表せばこんな感じになります。\\[SBOX(XOR_1(HORI(input)))=output \\Leftrightarrow XOR_1(HORI(input)) = SBOX\\\\_INV(output)\\]Round 2次に2roundを見ていきます。入力は1 roundと同様に緑の部分だけ変えて、後は固定の値を与えた結果、以下のようなものを得られます。同様にわかっている部分を青で埋めていきます。というわけで、1roundと比較してすべての状態がわかるわけではないとことになっています。ただ、仮に1round目のsboxのカギを決め打ちで決定できるて、更に白の部分の値も具体的にわかると仮定した場合、2round目のsbox直前の全ての値がわかるので、vertもすべての値を計算することができます。結果的に、1roundと同じよう計算していけば2Rのカギもわかりそうですね。ただ問題は仮定の部分で、 1round目の鍵空間は$2^{8×3}$​あるので、ちょっと計算が重いかも 白の部分の値の固定をどうするのか…一番の問題は白の部分の値の固定をどうするのかという部分こんな時は2つの入力を使って解決します。便宜上、入力を$input_1,input_2$​とします。この時すべての状態で$input_1,input_2$​のXORを取ります。すると、白部分が\\x00になることがわかります。何がうれしいのかというと、sbox後も0になることです。これで、vert部分が計算できるということになります。Round 3影響が2回被る部分を赤で示しています。ここまでくるとちょっときついですね…少し、工夫をすると1round削減できます。具体的には今まで入力として与えていたものはinput=\\x01+\\x00*8みたいなものでした。これに$HORI(input)^{-1}$としたものを与えると1round目のhoriにて1つの値にのみ影響を与えることができます。これにより1round目のsbox直後の値が1つのみにとどまるので2Roundと同じ攻撃が起こなうことができます。Round 4今回はRound 3で行ったテクニックは用いず考察していきます。Round2では白の部分を1つの入力用いて固定していました。これを拡張する方向性で考えていきます。具体的には2Rのsbox直後まではinputの緑によって制御されるということ。それ以降は緑が重複するため制御は厳しそうです。なので、これらをうまく制御して計算途中はわからないが計算結果をわかればよいという方向性で2Rのsbox直後まで求めていきます。具体的には以下の式を考えます。\\(\\oplus_{0\\leq i \\leq 255} SBOX(XOR_2(VERT(SBOX(XOR_1(HORI(input_i))))))\\)とはいっても長いので1つずつ見ていきます。 1Rのinputの時の緑(左上のみ) $\\oplus_{0\\leq i \\leq 255} input_i = 0$になります 1Rのhori直後の緑(上段のみで左からインデックスを$0\\leq j \\leq 2$​とします)分配則と1.より$\\oplus_{0\\leq i \\leq 255} HORI(input) = 0$​​になります。 2.と1RのKEYを偶数回XORすることになるので$\\oplus_{0\\leq i \\leq 255} XOR_1(input) = 0$になります。 3.において緑の場所に出現している値は256個あるため、$\\oplus_{0\\leq i \\leq 255} SBOX(input) = 0$になります。 同様の議論を省略しますが、3Rのxor直後まで行うことができ、またそれまですべての入力に対してxorを取った値は0になる部分を青で示します。逆に、output側から逆算できる部分を水色で示すと、以下になります。式として以下の形になります。\\[\\oplus_{0\\leq i \\leq 255} SBOX\\\\_INV(VERT\\\\_INV(XOR_4\\\\_INV(SBOX\\\\_INV(output_i)))) = 0\\]一度、$SBOX\\_INV(VERT\\_INV(XOR_4\\_INV(SBOX\\_INV(output_i))))$に関して考えてみます。$SBOX\\_INV(output_i))$は確実に値がわかるので$SBOX\\_INV(output_i))=output’$としておきます。\\[\\begin{eqnarray*}SBOX\\_INV(VERT\\_INV(XOR_4\\_INV(output'))) &amp;=SBOX\\_INV(VERT\\_INV(output' \\oplus KEY_4))\\\\&amp;= SBOX\\_INV(VERT\\_INV(output') \\oplus VERT\\_INV(KEY_4))\\end{eqnarray*}\\]$VERT\\_INV(output’)$は計算可能だが、$VERT_INV(KEY_4)$は計算できないためこれの計算結果を$KEY_4’$と置くと$\\oplus_{0\\leq i \\leq 255}　SBOX\\_INV(VERT\\_INV(output’) \\oplus KEY_4’)$となり$SBOX\\_INV$はそれぞれの値に対して演算を行うことを考慮すれば、$KEY_4’$のそれぞれの値をブルートフォースで求めればよいことになる。その求めた結果から$KEY_4$を復元することができる。ただいくつかの候補があるためどの鍵があっているのか最終的にテストする必要がある。Round 5round5は以下のようになるがround2,4のテクニックを組み合わせることで解決できる。このようになり、解決可能になります。やったね最終的なスクリプトは以下のようになります。from Jenga import *from ptrlib import *import refrom itertools import productimport functoolsdef hori_inv_ret(b): for i in range(0, 9, 3): x, y, z = b[i:i+3] b[i:i+3] = ( gf_mul(x, 0x9e) ^ gf_mul(y, 0x4f), gf_mul(y, 0x9e) ^ gf_mul(z, 0x4f), gf_mul(z, 0x9e) ^ gf_mul(x, 0x4f), ) return bdef vert_inv_ret(b): for i in range(3): x, y, z = b[i], b[i + 3], b[i + 6] b[i], b[i + 3], b[i + 6] = ( gf_mul(x, 0x9e) ^ gf_mul(y, 0x4f), gf_mul(y, 0x9e) ^ gf_mul(z, 0x4f), gf_mul(z, 0x9e) ^ gf_mul(x, 0x4f), ) return bdef hori(b): for i in range(0, 9, 3): x, y, z = b[i:i+3] b[i:i+3] = ( gf_mul(x, 4) ^ gf_mul(y, 2) ^ z, gf_mul(y, 4) ^ gf_mul(z, 2) ^ x, gf_mul(z, 4) ^ gf_mul(x, 2) ^ y, ) return b def sbox_inv(b): for i in range(9): b[i] = SBOX_inv[b[i]] return bdef recover_key(last_key): last_key = last_key[::-1] for i in range(36): last_key.append(SBOX_inv[last_key[i]]^last_key[i+1]) return last_key[::-1][:9]# preparepts = [bytes(hori_inv_ret(list(bytes([i])+b\"\\x00\"*8))).hex() for i in range(256)]regex = re.compile(\"[0-9a-f]{18}\")last_key = [[] for i in range(9)]io = remote(\"nc jenga.chal.2024.ctf.acsc.asia 39425\")# io = process([\"python3\",\"task.py\"])io.sendline(\"\\n\".join(pts))print(\"SENDED\")ret = regex.findall(io.recvuntil(b\"pt? \").decode())TEST = ret[0] AIM = ret[-1]known_part = [hori_inv_ret(sbox_inv(vert_inv_ret(list(bytes.fromhex(ct))))) for ct in ret[:-1]]print(\"RECVED\")last_key = []for index in range(9): ret = [] for i in range(256): if functools.reduce(lambda x, y: x ^ y, [SBOX_inv[ct[index]^i] for ct in known_part])==0: ret.append(i) last_key.append(ret)# recover_last keyfor cand in product(*last_key): test_key = recover_key(hori(list(cand))) if Jenga(test_key).encrypt(b\"\\x00\"*9).hex() == TEST: a = Jenga(test_key).decrypt(bytes.fromhex(AIM)).hex() print(a) io.sendline(a) io.sh() print(\"found\") break# ACSC{b40a78c51c581b7478e910df9ede1f50c036eb60a1fcd9b4146c5f92c6fdd348}" }, { "title": "最新版のsagemathとpythonのインストール", "url": "/posts/install_sagemath/", "categories": "writeup", "tags": "tech", "date": "2024-01-22 00:00:00 +0900", "snippet": "Sagemath SageMathは数学の幅広い処理を扱うソフトウェアである。扱う処理は計算機代数、組み合わせ、数値計算など多岐に及ぶ。工学的応用に加え基礎科学の研究も対応している。よくCTFでつかうやつ状況2024年3月22日現在、Sagemathの最新版は10.3, pythonはpython3.12.2が安定バージョンでの最新みたいです。しかし、Ubuntuではsudo apt install sagemathでインストールすると9.5がインストールされるはずです。これはちょっとバージョンが古いので最新のSagemath10.3×python3.12.2で環境作っていきます。(私はpython3.12.0でやってしまったんですが、まぁ大丈夫かと…)構築必要なライブラリ一式をinstallしていきます。注意として、python3をinstallする前に行ってください(一部のライブラリがsagemathのビルドで必須となりもう一度インストールする羽目になるので…)sudo apt updatesudo apt install bc binutils bzip2 ca-certificates cliquer cmake curl ecl eclib-tools fflas-ffpack flintqs g++ gengetopt gfan gfortran git glpk-utils gmp-ecm lcalc libatomic-ops-dev libboost-dev libbraiding-dev libbrial-dev libbrial-groebner-dev libbz2-dev libcdd-dev libcdd-tools libcliquer-dev libcurl4-openssl-dev libec-dev libecm-dev libffi-dev libflint-arb-dev libflint-dev libfreetype6-dev libgc-dev libgd-dev libgf2x-dev libgiac-dev libgivaro-dev libglpk-dev libgmp-dev libgsl-dev libhomfly-dev libiml-dev liblfunction-dev liblrcalc-dev liblzma-dev libm4rie-dev libmpc-dev libmpfi-dev libmpfr-dev libncurses5-dev libntl-dev libopenblas-dev libpari-dev libpcre3-dev libplanarity-dev libppl-dev libprimesieve-dev libpython3-dev libqhull-dev libreadline-dev librw-dev libsingular4-dev libsqlite3-dev libssl-dev libsuitesparse-dev libsymmetrica2-dev libz-dev libzmq3-dev libzn-poly-dev m4 make nauty openssl palp pari-doc pari-elldata pari-galdata pari-galpol pari-gp2c pari-seadata patch perl pkg-config planarity ppl-dev python3-distutils python3-venv r-base-dev r-cran-lattice singular sqlite3 sympow tachyon tar tox xcas xz-utils tcl-dev tk-dev次に、python3.12のインストールしていきます。Python-3.12.XXX.tgzのXXXはインストールするものに名前を変えてくださいmkdir ./python &amp;&amp; cd ./pythonwget https://www.python.org/ftp/python/3.12.0/Python-3.12.XXX.tgztar -xvf Python-3.12.XXX.tgzcd Python-3.12.XXX./configure --enable-optimizationssudo make installこれでpythonのインストールは終わりsagemathのインストールを行っていきます。sudo apt install autoconf automake libtool pkg-configwget https://ftp.riken.jp/sagemath/src/sage-10.3.tar.gztar xf sage-10.3.tar.gzcd sagegit checkout develop./configure --with-python=python3.12MAKE=\"make -j8\" makesudo ln -sf $(pwd)/sage /usr/local/binこれでSagemath10.3のインストールが終わります。最後にsageのコマンドを確認すれば問題なく起動していることがわかるはずです。" }, { "title": "MAPNACTF 2024", "url": "/posts/MAPNACTF/", "categories": "writeup", "tags": "writeup", "date": "2024-01-22 00:00:00 +0900", "snippet": "MAPNACTFI participated in this CTF with team BunkyoWersterns. Our team got 1st place.I solved 5 crypto challs [Shibs, GLNQ, Be Fast, What next?, What next Ⅱ?] and I got 3 first blood, 1 second blood, 1 third blood.I felt interesting for all crypto chall, so I appreciate for organizer to hold this CTF event thx a lot!!Shibs [crypto 10 solves]chall#!/usr/bin/env python3from Crypto.Util.number import *from flag import flagdef shift(s, B):\tassert s &lt; len(B)\treturn B[s:] + B[:s]def gen_key(nbit):\twhile True:\t\tp = getPrime(nbit)\t\tB = bin(p)[2:]\t\tfor s in range(1, nbit):\t\t\tq = int(shift(s, B), 2)\t\t\tif isPrime(q):\t\t\t\tn = p * q\t\t\t\treturn n, p, snbit = 1024n, p, _ = gen_key(nbit)q = n // pdna = p &amp; qm = bytes_to_long(flag)c = pow(m, 65537, n)print(f'n = {n}')print(f'dna = {dna}')print(f'enc = {c}')solveI’m so lazy this time, so I camp up with an idea which is “MAYBE WE CAN SOLVE USEING Z3”so i created test data, concretely value of shift is 1. z3 solved this data in 5 min.if we use single thread, take time is 85 hours. but if we can use 128 thread and high power pc, estimate is 24 minutes. OK, LETS TRY.finally I got first blood. and the flag says b'MAPNA{Br4nch_&amp;_prun3_Or_4Nother_ApprOacH???}'. WE FOUND ANOTHER APPROACH ITS USE Z3.from z3 import *from subprocess import check_outputfrom multiprocessing import Pool, cpu_countfrom tqdm import tqdmn = 20316898932195904153277570911129808751568815578115203862825426326247688399447840960418077345063791379522152467572219078649052797300815169624324245983590614914067269781160218800744443132820786495383622657350005442865119235171347222481549171383138463856866590153226706585323109487068718209302113471433380661465050751463957327192775767168671487596946840993911799696944069759277414133632444513772210700794949276020219498655982617016744321984479076362225276288530893635176013522707993482886351558163399233902562390621254309853983712254751850630385079750216639722676398376824903099579116864460998259826947136455660974737633dna = 112981924875557500958025001180130494828271302148393893025039250618449754880107262891213034570290994460680732065864408219699255537220809236513831561599199136870056419874815435027857448315805793914961273026882116413167515833581245087132919209478091324962372324771986076010340277554904109601589334046901209670673enc = 3045339581292945711130813005351003100918522557110757541588006962379795819964889960982006172396478992403763951169397699477604011489683403206194674478676115307579754281253958928474112104087602753563505848223560038859380782692201785087834133116953880301903767021262497807797262966215767967235011554145888668721199447563741572273525508047234141844260401652933196055533764562153454963082569500478073362290691632890264262315099050876574517869170470080069161301450816555901477760392115210762498464643598219802952797283932722013302922244300834587051779128033516492433437534261890143822056118794447406885925957834712258842422nbit = 1024dna_ = bin(dna)[2:].zfill(nbit)p = BitVec(\"p\",nbit)q = BitVec(\"q\",nbit)def solver(i): s = Solver() s.add(q == RotateLeft(p, i)) s.add(n == p*q) s.add(p&amp;q == dna_) print(i, s.check()) if s.check() == sat: print(s.model()) _i = [i for i in range(1,nbit)]with Pool(cpu_count()) as pool: for results in tqdm(pool.imap_unordered(solver, _i), total=len(_i)): pass q = 118627270647424424141514783307481285886258073029116821903046590278901771054287488093459396876753105609837026655906589077937738668295841155401318912730133481985678923364535216697903225159999957216575823849034786092435988869550296395479754426578068176634670446795305597283053006032071267819138579464710410086097p = 171266681103878322117424575175361468379674209043813157946561665043786388947203228350875263109216690282197981858022233522587435146007011089350418152369819924630928608372164838867715907687708478655112024432448453837808032774893387899232268630799449237496392996637407630619155994281854191089804529710230573475089phi = (q-1)*(p-1)e = 0x10001d = pow(e,-1,phi)from Crypto.Util.number import *print(long_to_bytes(pow(enc,d,n)))exit()b'MAPNA{Br4nch_&amp;_prun3_Or_4Nother_ApprOacH???}'GLNQ [crypto 13 solve]chall#!/usr/bin/env sagefrom Crypto.Util.number import *from flag import flagF, k = GF(2**8), 14while True:\tG = random_matrix(F, k)\tif G.is_invertible():\t\tbreakflag = flag.lstrip(b'MAPNA{').rstrip(b'}')m = bytes_to_long(flag)H = G ** mprint(f'G = {G}')print(f'H = {H}')solvethis matrix has b-smooth order.so, we can calc discrete log for pohlig-hellman algorithm.finally I got second blood.from Crypto.Util.number import *F, k = GF(2**8), 14z8 = F.gens()[0]G = ---[sinpped]---H = ---[sinpped]---G = Matrix(F,G)H = Matrix(F,H)r = 79229371458530696292133175295def babystep_giantstep(g, y, p): m = int((p-1)**0.5 + 0.5) table = {} gr = 1 for r in range(m): table[str(gr)] = r gr = gr * g gm = g^(-m) ygqm = y for q in range(m): if str(ygqm) in table: return q * m + table[str(ygqm)] ygqm = ygqm * gm return Nonedef Pohlig_Hellman_DLP(P,sP,order): primes = [] for i,k in factor(order): primes.append(i^k) dlogs = [] for fac in primes: t = int(order) // int(fac) dlog = babystep_giantstep(P^t, sP^t, fac) assert (P^t)^dlog == sP^t dlogs += [dlog] print(\"factor: \"+str(fac)+\", Discrete Log: \"+str(dlog)) return crt(dlogs, primes )flag = int(Pohlig_Hellman_DLP(G,H,r))assert G^flag == Hprint(flag)# MAPNA{6424379811053277573417442136}Be Fast🏃 [crypto 34 solve]chall#!/usr/bin/env python3from random import *from binascii import *from Crypto.Cipher import DESfrom signal import *import sys, osfrom flag import flagdef die(*args):\tpr(*args)\tquit()def pr(*args):\ts = \" \".join(map(str, args))\tsys.stdout.write(s + \"\\n\")\tsys.stdout.flush()def sc():\treturn sys.stdin.buffer.readline()def shift(msg, l):\tassert l &lt; len(msg)\treturn msg[l:] + msg[:l]def pad(text):\tif len(text) % 8 != 0:\t\ttext += (b'\\xff' * (8 - len(text) % 8))\treturn textdef encrypt(msg, key):\tmsg = pad(msg)\tassert len(msg) % 8 == 0\tassert len(key) == 8\tdes = DES.new(key, DES.MODE_ECB)\tenc = des.encrypt(msg)\treturn encdef main():\tborder = \"+\"\tpr(border*72)\tpr(border, \".:: Hi all, you should be fast, I mean super fact!! ::.\", border)\tpr(border, \"You should send twenty 8-byte keys to encrypt the secret message and\", border)\tpr(border, \"just decrypt the ciphertext to get the flag, Are you ready to start?\", border)\tpr(border*72)\tsecret_msg = b'TOP_SECRET:' + os.urandom(40)\t\tcnt, STEP, KEYS = 0, 14, []\tmd = 1\twhile True:\t\tpr(border, \"please send your key as hex: \")\t\t# alarm(md + 1)\t\tans = sc().decode().strip()\t\t# alarm(0)\t\ttry:\t\t\tkey = unhexlify(ans)\t\t\tif len(key) == 8 and key not in KEYS:\t\t\t\tKEYS += [key]\t\t\t\tcnt += 1\t\t\telse:\t\t\t\tdie(border, 'Kidding me!? Bye!!')\t\texcept:\t\t\tdie(border, 'Your key is not valid! Bye!!')\t\tif len(KEYS) == STEP:\t\t\tHKEY = KEYS[:7]\t\t\tshuffle(HKEY)\t\t\tNKEY = KEYS[-7:]\t\t\tshuffle(NKEY)\t\t\tfor h in HKEY: NKEY = [key, shift(key, 1)] + NKEY\t\t\tenc = encrypt(secret_msg, NKEY[0])\t\t\tfor key in NKEY[1:]:\t\t\t\tenc = encrypt(enc, key)\t\t\tpr(border, f'enc = {hexlify(enc)}')\t\t\tpr(border, f'Can you guess the secret message? ')\t\t\talarm(md + 1)\t\t\tmsg = sc().strip()\t\t\talarm(0)\t\t\tif msg == hexlify(secret_msg):\t\t\t\tdie(border, f'Congrats, you deserve the flag: {flag}')\t\t\telse:\t\t\t\tdie(border, f'Sorry, your input is incorrect! Bye!!')if __name__ == '__main__':\tmain()solvewe can send 8keys, and server makes kyes = [key, shift(key, i) for i in range(7)] + NKEY.so I send keys = [long_to_bytes(i)*8 for i in range(8)], kyes = [key, key for i in range(7)] + shuffle(kyes[-7:]).we can calc all because key patterns are 7!I got first blood!!from pwn import *from Crypto.Util.number import *from Crypto.Cipher import DESfrom itertools import permutationsdef pad(text):\tif len(text) % 8 != 0:\t\ttext += (b'\\xff' * (8 - len(text) % 8))\treturn textdef encrypt(msg, key):\tmsg = pad(msg)\tdes = DES.new(key, DES.MODE_ECB)\tenc = des.encrypt(msg)\treturn encdef decrypt(msg, key):\tdes = DES.new(key, DES.MODE_ECB)\tenc = des.decrypt(msg)\treturn enc_key = []keys_all = []for i in range(7): _key.append(long_to_bytes(i)*8)secret_msg = b'TOP_SECR'cands = []for i in permutations(_key): msg = secret_msg keys = [] for _ in range(14): msg = encrypt(msg, b\"\\x00\"*8) keys.append(b\"\\x00\"*8) print(i) for _i in i: msg = encrypt(msg, _i) keys.append(_i) cands.append(msg.hex()) keys_all.append(keys)key = \"\"for i in range(13,-1,-1): key += (long_to_bytes(i)*8).hex()+\"\\n\"io = remote(\"3.75.180.117\",37773)io.send(key)io.recvuntil(b\"enc = \")a = io.recvline().decode()enc = eval(a)enc = bytes.fromhex(enc.decode())for i in keys_all[cands.index(enc[:8].hex())][::-1]: enc = decrypt(enc,i)io.sendline(enc[:-5].hex().encode())io.interactive()# MAPNA{DES_h4s_A_f3W_5pec1f!c_kEys_7eRm3d_we4K_k3Ys_And_Sem1-wE4k_KeY5!}What next? [crypto 326 solve]chall#!/usr/bin/env python3from random import *from Crypto.Util.number import *from flag import flagdef encrypt(msg, KEY):\tm = bytes_to_long(msg)\tc = KEY ^ m\treturn cn = 80TMP = [getrandbits(256) * _ ** 2 for _ in range(n)]KEY = sum([getrandbits(256 &gt;&gt; _) for _ in range(8)]) enc = encrypt(flag, KEY)print(f'TMP = {TMP}')print(f'KEY = {KEY}')print(f'enc = {enc}')solveFirst, I don’t know provide KEY, so I thought that we need to recover MT’s state lol.I got third blood.import randomfrom extend_mt19937_predictor import ExtendMT19937Predictorfrom random import *from Crypto.Util.number import *predictor = ExtendMT19937Predictor()TMP = [0, 60532113298156934035006892408508955361282411773999112364347341111075018147927, 389708033651020865401865717693397865196213972164600460902422823183461779915980, 405918065202512971659130608346843374237984902589139232574420604120059844720341, 1221288278415504784467034784431436409217396366988324269872668238978249045586368, 227272449199630828507165833400505281743840056074337728659380026370174597983400, 3253503829229933909142928710502222745989372185283055446591180092486412602783216, 5285988746830110954075248573612981420829816533804399404046882938020472042330356, 1595336926944568705525401229738700126737605961193041889427425025694023495226176, 7954983836536199412561303342870946300319308569704526681942922892057412417369996, 9131160911707622814886835054526857850430982962993746463098999466544684215014000, 7533615981375704965377803926757920571133747559444638616597692539324665788824241, 9066823514420452679519089047747738557989264923523328666138044339979172532091952, 11067455968068371535244972547693443476921719558645991175617294899803940399861323, 14537042287558789972327728985738890609505033466725608088977070967810362118279248, 4572250646126446008858673089127752592787335839144590539404665629413086318239650, 6294362797378922374391238457327978545276595686984712745478781562202157935775488, 22747367842710135893711619452307079245750111941624369856170309106764880998100552, 6004893915710283480070189414407284168050988366555745204074130859740178577433240, 14420752900418475271133573248938786225809597358248108049760284685159047602036537, 43733009974069364671572839996339051940609184658654624940598489171524524051944400, 35346194693613025068395009821809884943769752588359988505793537720962714260019869, 42204169462513802238599356946318680734527685184414356760365290489529820960713072, 34277378263896547381266820799512178423239236243790865361707633583497481357796407, 65716310119362366398237218525711748744052085839683547702975404773566674635748352, 46557817276176359993118228055060795747091243514590105677103910660112788974583750, 77490786359937960192983922284789298329689351038928181926278354279011358030727124, 80111990003818834469282875276984278230143118837645016537448310618261479083651342, 20554557048628019672240583641369145446540900712224309311213526066135949044952288, 62735818615066536453205944582471026825278180907531123883210362947117955616343781, 86042719783890082289653687251665836736491344225760521302063306208331002685576500, 25965698487671814117818570753889366721907386924362900403011501627358460499758383, 29616377817002001833630895361629451907964508596441826676791174072122929285049344, 15021399892362753107059884462124333866295538287397369553705410328403621774185468, 38002604304046319679742306015002655608233191413179528560874731009946042988120788, 93295366307461634335632781504982997626366942447637302439067556300965151557831725, 13540230203788528048897000123546822994874145971630139618336417120723676174022384, 154432198666672358575141914680506005090971687803151597762263520020713308780579072, 72136447292935153078321891268785033320056922245403740454889157780753773717242568, 25501852421215926138677841658578129717118066368151623403551273037829983575243468, 126735578787059666358271681647457626985119387894943043206239792071598867033556800, 135202944925842633454294137881609034393280829104975826296437659832444402212706990, 195878634803984461306574869979621981219794907747012161075921193902109987239350696, 70016262426074427215170249788098050659024805306136436354383469618536112786361350, 35956258331474238072248600117735641962702369830606009799455005594969570110652976, 22225110718496125427125444008161845696087660990666988086936919846739655848747525, 27548874118316168690466237353230253832267098824834641381166573208182433313572936, 217350749041695488338708373584952864553819378993764330831653495907756867001916100, 257655749972831097290040240403045642767794308639832322802465135822003512301701120, 170931799252374463455850569878339599585582089254513276315581340035784063404547904, 260648666226967018693658250893274370482164362954223893135614467834502818278817500, 69425639907308137984060966310312800675576800616943121851698019398372874074587564, 38272797691322675978111710027833013466477209475584360707344650868692232767605712, 159989233909295381868776328891896676159494718709642790902586750185703386017519100, 239424076217975267533547688379482794244638593887104216992730670874367591889686424, 235805166260230600224517436738096467578276265139558424271706458619605152151155650, 312887850933221623827051251636459958804378796969233372438708909260471396708839360, 226254410804533566347737443581029620895018482953889083109343308899334155214465084, 75663356945666060728297569858199894519238029780108571803169998187745851675033696, 379521198853533961681034095706543224338730654829393858931702778389925326037905581, 146969137746310211928872994682693200202368153046275429574482720738790962130698000, 294260825765970965744028560390675570627618373545459966200549616640279283196332026, 319516693693602451939925738770832547195167488538421484010981799971938667101170272, 235996689233669489969452603688581556879686306558426802897567227857894956933720385, 129860515531400644974201481565448922647210002409167735625695108262182647544782848, 434775250558913676954052533315009488640533958618010407554959841056206485055286800, 22149580084411886515787074680813749427656731151235741580693077660337965563693340, 250909616829332329061530688103059354065323867429954924090541815760594873142372389, 190341994069073757182537956898692121864681766192223013320579410693514741018663328, 498585070302128781878557564834342148816012866139626477296471773760922822044892275, 263835635996152386059834449296099627577713122650362830498873071118489986876211700, 225673582284037816919955555063840997388361787112308169031986640074367056949780747, 361331112554037421979550439774599874333938415297694314983681794489970792139813248, 254546085100670719262378937737022676839283545191763458089424319101240909887973785, 253610597769560898884657084492335380622121458721155827380866680741694312733007816, 457274233985553849774588573500169926255994068617887370590713102886816853234873125, 449778455880514807591245873496025212715825137347886177910517238904962733456694256, 401484248501670039446475341305100595322092268787582033086127175618422362454931911, 22016053572627515851711195096973390151818785168234961407013202935121714403513020, 199223592692197859565380631569896354958045929491349287395617253114895842147327801]KEY = 23226475334448992634882677537728533150528705952262010830460862502359965393545enc = 2290064970177041546889165766737348623235283630135906565145883208626788551598431732TMP = [ t//((i+1)**2) for i, t in enumerate(TMP[1:])]print(TMP)for T in TMP: predictor.setrandbits(T, 256) KEY = sum([predictor.predict_getrandbits(256 &gt;&gt; _) for _ in range(8)]) def encrypt(msg, KEY):\tm = msg\tc = KEY ^ m\treturn cprint(long_to_bytes(encrypt(enc,KEY)))b'MAPNA{R_U_MT19937_PRNG_Predictor?}'What next II? [crypto 69 solve]chall#!/usr/bin/env python3from random import *from Crypto.Util.number import *from flag import flagdef encrypt(msg, KEY):\tm = bytes_to_long(msg)\tc = KEY ^ m\treturn cn = 80TMP = [getrandbits(256) * _ ** 2 for _ in range(n)]KEY = sum([getrandbits(256 &gt;&gt; _) ** 2 for _ in range(8)]) enc = encrypt(flag, KEY)print(f'TMP = {TMP}')print(f'enc = {enc}')solveok, version 2 don’t provide a Key, but unluckily I solved this type in previous chall.so, i copied my sol lol.I got first blood in 2 minutes lmfao.import randomfrom extend_mt19937_predictor import ExtendMT19937Predictorfrom random import *from Crypto.Util.number import *predictor = ExtendMT19937Predictor()TMP = [0, 22330693840234311255135949029444484409546667648719176405826663892267656641027, 127168478027482847709328807841325386271927515479937061237117195618823278578116, 182258311374053859620888699680212168010665323374548870180038645090147843867373, 1120044041165490856498692287111236626472260308631093314161690677868431277653536, 1983473421395194676263973602935227753154638099492341714205203280778040675593450, 1574768551732085861078069762534699936995654652684634077104498873387111232412816, 4988773041677976257517254491234335651753610239922582254283447205154548743632904, 869738033317159039287197189670964123964466628318970710545560734535418094431872, 716771557072892076589368879721160406613516964478389692662921907034616035095047, 2841054733362182186252458286741823726277405165099408732758691872324732479956600, 6200268989316199565071790593244237980113705529543497656127585449937778556282311, 10670728743047162087774896911955052588177734200772863764402582886370432879158720, 7713906922622752752151916696524419287963819641354815269293605765422900017233866, 13689077681405838115291939958594572280593102467042881661528817316126253635857444, 23677404931618939684375357302211056316481456538100460743428412550112769975941300, 22334702277647520331031971258896634990832479997228972554803329027443498276011264, 24695994670269108821474844143270568317378271123560130717104045624895774803117988, 10726839246587772223823222881528936091917884797218227418638385365176143122217812, 1312747277711228023681888222399668996816715931126782050057534166588569071642948, 14829434912751138825019062212374862054511849430113519894438429231649766515851600, 4917180643387964007287001238070594020985844865025196727991425387470641537875518, 50772176246766546694026388399540445347088279634906123947563600159509306535585300, 20680598744337311676861190641592800456437920078216405214477640693225317242487078, 57560623230262776939750106414721715686651269149245752162663251361023294801081600, 63941301709699592129851769466238327968731332723117779339939586823464299930335000, 30248094445348087425063737332624900285689080519537666953907462011122884602991780, 9774708715683840095021685805936771586028623975773332766526807054152590972465402, 61228751294246951869891671407294469506401133460669313068369993608651062307301536, 41981261972157910420555352577742115252749734931422260886610665615142932761250238, 92332289648534120255700799585162857690611895814212622902006472593032842219422300, 102090694836612045964656351247645673041342905792690679450732518780700786595757872, 8465306744686231379969736050689382339949995071265316552433666241539252681451520, 114072153081233359084524715014825650254537286682603109151986752844288607088786066, 39946361462751138749261511325777846481011288953117931061771127396007551287911208, 51243479474799144289518571031495536096625532453885999576052634625243425716758700, 132356504405092579871543186323238530972479261975470487510352508943760068475015440, 109077835346013498228568867183016137777644328620298812835459712256002833220195417, 52635267919343130972014005273289555808336337947193348140410148289978267235415648, 9568343438735227407132147420705807168258684366618511035784505242511446472528193, 136103745592722122037143341370556407561964415802887285393102934361453911394982400, 15501324115571167305412632833471884183641743683875758176471163573103721210677697, 124579054262159655532164017523017564697199759561416452868759873217906475930663652, 69331433672201876294056448428159828327113921951663941374636039203754564050923557, 134825790087045765574290263555594553874136924161813224135475519279020442040026864, 127098236196925756090074171499128508507461799729629969599917408442298996799214250, 120716315173788627251671396349879537684221828425501013413665864262612928100844788, 246230945837378885729579613348413794121875158206606559652651668292953179058653508, 182436930868427241575608788617950343128628563937798409868187047670441481734494464, 2216307326510769061988701188806623458793041637834505792592287312459658319545700, 217778196427604121810125555838576095983026719310491477185297193068203986197977500, 200042153662024093707446037685450040433674498805614787040971237961725493946807124, 55096521527758008435839474651130444687406648424301616531387151625485823586357376, 315911207494925949742212443025101639383551363855632617410391325922132118052280432, 160608721274889447938606989650810386105243008009388938737103600719751998405695052, 80485718020426913778898398898436382386718914865993732581279132006386834763843750, 175256027423949464821148437330609889703365513530429385704635213979205690543187968, 312494592697141143680238564093947039458907138790072672218576868913190841311490441, 12551558878313236197845748627693664902436846005140074555532691630477757920400492, 368163678666609325358026149200535116090648801749210267074911311082497122727619418, 132244486142872991925346591101049195464960273281071718729683433268064480383763200, 187524820546739515326467479985404725103464284941528452333038247179114024353648176, 283320427018968981710753682470612392210145925235229015984823155988278867852342424, 273076274412276025537791810337835157311632197268182698230310819989050497776963263, 327014096802403962955714851262399814244813548393488285833127238998882721132883968, 206832690482752439833856322955815020186765387390104398292271480795930880106073325, 104167288428075991079921385804154376915444422785935287020330329091692992364020356, 468442878028756757484855000070722747267796721762231179211069666438706434848755245, 13006681553773847728990900149289800641720551387610802780788594468812438984199760, 199716185379958028413200192962692404940513822154864483463050473557869065589649168, 412558417168152436059170177108518481504104909389966119467224740980715361039084900, 379013360598848524426838307544021120793535763669172279637583374247930017257612752, 79510803625960975136293110699095743477640774841480691165531320726532279504009152, 119246467719878286004186703543298639812649580965124121805161153548472942538790653, 44235048729597559877492812430806736314711896199059487848598597142896457753232432, 453319033816285234767354843915966019736243075972507643199351036007057824008570000, 300975897791737470999557383409844137620736489995632513055593286593028252152372832, 488688724028459389993054497130088474659149461722402520817247390457263798063265080, 98311703485802819685121101139900586756957739352203591545958914778011243453808576, 503894794312461918204750180188338003935699664049776370432270755067603639622480931]enc = 1954128229670403595826293823451515985816812578139791173172421160740653397416251058891670696398940725266238000104900728729829302299509397650740333416176077TMP = [ t//((i+1)**2) for i, t in enumerate(TMP[1:])]print(TMP)for T in TMP: predictor.setrandbits(T, 256) KEY = sum([predictor.predict_getrandbits(256 &gt;&gt; _)** 2 for _ in range(8)]) def encrypt(msg, KEY):\tm = msg\tc = KEY ^ m\treturn cprint(long_to_bytes(encrypt(enc,KEY)))b'MAPNA{4Re_y0U_MT19937_PRNG_pr3d!cT0r_R3ven9E_4057950503c1e3992}'" }, { "title": "UofTCTF 2024", "url": "/posts/UofTCTF/", "categories": "writeup", "tags": "writeup", "date": "2024-01-14 00:00:00 +0900", "snippet": "UofTCTF 2024Export Grade Cipher [crypto 10 solve]challimport astimport threadingfrom exportcipher import *try: from flag import FLAGexcept: FLAG = \"test{FLAG}\"MAX_COUNT = 100TIMEOUT = 120 # secondsdef input_bytes(display_msg): m = input(display_msg) try: m = ast.literal_eval(m) except: # might not be valid str or bytes literal but could still be valid input, so just encode it pass if isinstance(m, str): m = m.encode() assert isinstance(m, bytes) return mdef timeout_handler(): print(\"Time is up, you can throw out your work as the key changed.\") exit()if __name__ == \"__main__\": print(\"Initializing Export Grade Cipher...\") key = int.from_bytes(os.urandom(5),\"little\") cipher = ExportGradeCipher(key) print(\"You may choose up to {} plaintext messages to encrypt.\".format(MAX_COUNT)) print(\"Recover the 40-bit key to get the flag.\") print(\"You have {} seconds.\".format(TIMEOUT)) # enough time to crack a 40 bit key with the compute resources of a government threading.Timer(TIMEOUT, timeout_handler).start() i = 0 while i &lt; MAX_COUNT: pt = input_bytes(\"[MSG {}] plaintext: \".format(i)) if not pt: break if len(pt) &gt; 512: # don't allow excessively long messages print(\"Message Too Long!\") continue nonce = os.urandom(256) cipher.init_with_nonce(nonce) ct = cipher.encrypt(pt) print(\"[MSG {}] nonce: {}\".format(i, nonce)) print(\"[MSG {}] ciphertext: {}\".format(i, ct)) # sanity check decryption cipher.init_with_nonce(nonce) assert pt == cipher.decrypt(ct) i += 1 recovered_key = ast.literal_eval(input(\"Recovered Key: \")) assert isinstance(recovered_key, int) if recovered_key == key: print(\"That is the key! Here is the flag: {}\".format(FLAG)) else: print(\"Wrong!\")import osclass LFSR: def __init__(self, seed, taps, size): assert seed != 0 assert (seed &gt;&gt; size) == 0 assert len(taps) &gt; 0 and (size - 1) in taps self.state = seed self.taps = taps self.mask = (1 &lt;&lt; size) - 1 def _shift(self): feedback = 0 for tap in self.taps: feedback ^= (self.state &gt;&gt; tap) &amp; 1 self.state = ((self.state &lt;&lt; 1) | feedback) &amp; self.mask def next_byte(self): val = self.state &amp; 0xFF for _ in range(8): self._shift() return valclass ExportGradeCipher: def __init__(self, key): # 40 bit key assert (key &gt;&gt; 40) == 0 self.key = key self.initialized = False def init_with_nonce(self, nonce): # 256 byte nonce, nonce size isnt export controlled so hopefully this will compensate for the short key size assert len(nonce) == 256 self.lfsr17 = LFSR((self.key &amp; 0xFFFF) | (1 &lt;&lt; 16), [2, 9, 10, 11, 14, 16], 17) self.lfsr32 = LFSR(((self.key &gt;&gt; 16) | 0xAB &lt;&lt; 24) &amp; 0xFFFFFFFF, [1, 6, 16, 21, 23, 24, 25, 26, 30, 31], 32) self.S = [i for i in range(256)] # Fisher-Yates shuffle S-table for i in range(255, 0, -1): # generate j s.t. 0 &lt;= j &lt;= i, has modulo bias but good luck exploiting that j = (self.lfsr17.next_byte() ^ self.lfsr32.next_byte()) % (i + 1) self.S[i], self.S[j] = self.S[j], self.S[i] j = 0 # use nonce to scramble S-table some more for i in range(256): j = (j + self.lfsr17.next_byte() ^ self.lfsr32.next_byte() + self.S[i] + nonce[i]) % 256 self.S[i], self.S[j] = self.S[j], self.S[i] self.S_inv = [0 for _ in range(256)] for i in range(256): self.S_inv[self.S[i]] = i self.initialized = True def _update(self, v): i = self.lfsr17.next_byte() ^ self.lfsr32.next_byte() self.S[v], self.S[i] = self.S[i], self.S[v] self.S_inv[self.S[v]] = v self.S_inv[self.S[i]] = i def encrypt(self, msg): assert self.initialized ct = bytes() for v in msg: ct += self.S[v].to_bytes() self._update(v) return ct def decrypt(self, ct): assert self.initialized msg = bytes() for v in ct: vo = self.S_inv[v] msg += vo.to_bytes() self._update(vo) return msgif __name__ == \"__main__\": cipher = ExportGradeCipher(int.from_bytes(os.urandom(5))) nonce = os.urandom(256) print(\"=\"*50) print(\"Cipher Key: {}\".format(cipher.key)) print(\"Nonce: {}\".format(nonce)) msg = \"ChatGPT: The Kerckhoffs' Principle, formulated by Auguste Kerckhoffs in the 19th century, is a fundamental concept in cryptography that states that the security of a cryptographic system should not rely on the secrecy of the algorithm, but rather on the secrecy of the key. In other words, a cryptosystem should remain secure even if all the details of the encryption algorithm, except for the key, are publicly known. This principle emphasizes the importance of key management in ensuring the confidentiality and integrity of encrypted data and promotes the development of encryption algorithms that can be openly analyzed and tested by the cryptographic community, making them more robust and trustworthy.\" print(\"=\"*50) print(\"Plaintext: {}\".format(msg)) cipher.init_with_nonce(nonce) ct = cipher.encrypt(msg.encode()) print(\"=\"*50) print(\"Ciphertext: {}\".format(ct)) cipher.init_with_nonce(nonce) dec = cipher.decrypt(ct) print(\"=\"*50) try: print(\"Decrypted: {}\".format(dec)) assert msg.encode() == dec except: print(\"Decryption failed\")solvesumaaryThe class ExportGradeCipher is implemented in ExportGradeCipher.py. In this class, the state is initialized by the function init_with_nonce using key and nonce. After that, the function _update constructs a nfsr(non linear shift register) of lfsr17 and lfsr32, and appears to perform encryption using them. In encrypt, after outputting the location of one character of msg in the S array as ct, the output of 256 bytes of nfsr and the location of one character of msg are swapped. def _update(self, v): i = self.lfsr17.next_byte() ^ self.lfsr32.next_byte() self.S[v], self.S[i] = self.S[i], self.S[v] def encrypt(self, msg): assert self.initialized ct = bytes() for v in msg: ct += self.S[v].to_bytes(1,\"little\") self._update(v) return ct cryptanisisSuppose we have an S array of length 4 and msg is b”\\x00\\x01\\x02\\x03” i 0 1 2 3 S[i] 2 4 6 8 If you follow the processing of the encrypt function in order, the first character is when v=0 and the ct at that time is ct[0]=2. The self._update(v) causes a swap self.S[v], self.S[i] = self.S[i], self.S[v]. We know that v=0 here, so let’s assume i=1. Then the table transitions as follows. i 0 1 2 3 S[i] 4 2 6 8 We see that v in the second week is v=1 and that ct at that time is ct[1]=2. I want you to wait a moment. This time, the array S is all set to different values, so the same value ct[0]=ct[1]=2 could be used for something. S[v], self.S[i] = self.S[i], self.S[v] means that v can set itself and swap its value with the i-th value, and if the same value appears here, we know that it was swapped with the i-th value in the process at this time. So, at this point, we know the output i of the nfsr when the same value appears for the first time. The rest is a repeat of this.By the time you reach the end, you have obtained a certain amount of S array and nfsr output i. And considering that the nonce changes only S array in this setup, repeating the above process up to the upper limit will give us almost perfect nfsr output.solverTherefore, now that we have obtained the output of nfsr, we can also reverse the initial state of lfsr32 by considering that lfsr17 is within the brute force range. At this point, checking whether the upper 2bytes are such that they are 0xAB will reduce the number of candidate solutions.self.lfsr32 = LFSR(((self.key &gt;&gt; 16) | 0xAB &lt;&lt; 24) &amp; 0xFFFFFFFF, [1, 6, 16, 21, 23, 24, 25, 26, 30, 31], 32)Nevertheless, since about 30 candidates for the key remain, and considering that this cipher can only affect nonce and key, the key can be checked if the cipher is the same for that plaintext by performing the cipher again.Thus, the following is my implementation. Note that I have used a matrix to speed up the lfsr.from pwn import *import astimport randomfrom tqdm import tqdmfrom exportcipher import *class LFSR: def __init__(self, seed, taps, size): assert seed != 0 assert (seed &gt;&gt; size) == 0 assert len(taps) &gt; 0 and (size - 1) in taps self.state = seed self.size = size self.taps = taps self.mask = (1 &lt;&lt; size) - 1 self.mat = matrix(GF(2),size,size) for i in range(size-1): self.mat[i,i+1] = 1 for t in self.taps: self.mat[-1,-t-1] = 1 self.state_vec = vector(GF(2),[int(i) for i in bin(seed)[2:].zfill(size)]) def _shift(self): feedback = 0 for tap in self.taps: feedback ^^= (self.state &gt;&gt; tap) &amp; 1 self.state = ((self.state &lt;&lt; 1) | feedback) &amp; self.mask def next_byte(self): val = self.state &amp; 0xFF for _ in range(8): self._shift() return val def _shift_mat(self, k): state_vec = self.mat^(8*k)*self.state_vec return int(\"\".join([str(i) for i in list(state_vec)[-8:]]),2) def after_255_256_next_byte(self): val1 = self._shift_mat(255+256) val2 = self._shift_mat(256+256) val3 = self._shift_mat(257+256) val4 = self._shift_mat(258+256) return bytes([val1,val2,val3,val4]) def check(self, vec): vec = vector(GF(2),[int(i) for i in bin(vec[0])[2:].zfill(8)+bin(vec[1])[2:].zfill(8)+bin(vec[2])[2:].zfill(8)+bin(vec[3])[2:].zfill(8)]) self.inv_mat = self.mat^(-1) if list(self.inv_mat^(8*514)*vec)[:8] == [int(i)for i in bin(0xab)[2:].zfill(8)]: return int(\"\".join([str(i) for i in list(self.inv_mat^(8*514)*vec)[8:]]),2) return Falsedef bxor(a,b): return bytes([_a^^_b for _a,_b in zip(a,b)])lfsr17s = []lfsr32s = []for key in tqdm(range(256**2)): lfsr17 = LFSR((key &amp; 0xFFFF) | (1 &lt;&lt; 16), [2, 9, 10, 11, 14, 16], 17) lfsr17s.append(lfsr17.after_255_256_next_byte())io = remote(\"0.cloud.chals.io\",\"23753\")# io = process([\"python3\",\"chal.py\"])CNT = 256lfsr = [-1 for i in range(CNT)]pt = [(i)%256 for i in range(CNT)]for __ in tqdm(range(100)): random.shuffle(pt) io.sendlineafter(b\": \",str(bytes(pt)).encode()) nonce = ast.literal_eval(io.recvline().decode().split(\"nonce: \")[1]) ct = ast.literal_eval(io.recvline().decode().split(\"ciphertext: \")[1]) S = [-1 for i in range(256)] print(lfsr.count(-1)) for i in range(CNT): if not ct[i] in S: S[pt[i]] = ct[i] else: if lfsr[ct[:i].index(ct[i])] != -1: continue lfsr[ct[:i].index(ct[i])] = pt[i] S[pt[i]] = ct[i] S[S.index(ct[i])] = -1lfsr32 = LFSR(((0x123456 &gt;&gt; 16) | 0xAB &lt;&lt; 24) &amp; 0xFFFFFFFF, [1, 6, 16, 21, 23, 24, 25, 26, 30, 31], 32)for i in tqdm(range(256**2)): a = lfsr32.check(bxor(bytes(lfsr[:4]),lfsr17s[i])) if a != False: key1 = i key2 = a key = key1 + (key2 &lt;&lt; 16) cipher = ExportGradeCipher(key) cipher.init_with_nonce(nonce) if ct == cipher.encrypt(pt): io.sendlineafter(b\": \", str(key)) io.interactive() exit()# uoftctf{wH0_w0u1D_h4ve_7houGHt_l0ng_nONceS_CAnt_S4ve_w3ak_KeYS}" }, { "title": "cakectf 2023", "url": "/posts/cakecft/", "categories": "writeup", "tags": "writeup", "date": "2023-09-30 00:00:00 +0900", "snippet": "cakectf 2023 BunkyoWesternsに入れてもらったのでチームでやってました。色々名言が生まれたので楽しかったです。後買ってきたケーキをみんなで食べましたまる。kanon on X: “cakectf終わったのでケーキ食べます https://t.co/Kj9xOJZACy” / X (twitter.com)simple signature 88 solvechallimport osimport sysfrom hashlib import sha512from Crypto.Util.number import getRandomRange, getStrongPrime, inverse, GCDimport signalflag = os.environ.get(\"FLAG\", \"neko{cat_does_not_eat_cake}\")p = getStrongPrime(512)g = 2p = 11551622313922707550008678743003601832188036792175262302397935776595208393670456612224185992217183071863853189220628487330346803009314560368938395241129573def keygen(): while True: x = getRandomRange(2, p-1) y = getRandomRange(2, p-1) w = getRandomRange(2, p-1) v = w * y % (p-1) if GCD(v, p-1) != 1: continue u = (w * x - 1) * inverse(v, p-1) % (p-1) return (x, y, u), (w, v)def sign(m, key): x, y, u = key r = getRandomRange(2, p-1) return pow(g, x*m + r*y, p), pow(g, u*m + r, p)def verify(m, sig, key): w, v = key s, t = sig return pow(g, m, p) == pow(s, w, p) * pow(t, -v, p) % pdef h(m): return int(sha512(m.encode()).hexdigest(), 16)if __name__ == '__main__': magic_word = \"cake_does_not_eat_cat\" skey, vkey = keygen() print(f\"p = {p}\") print(f\"g = {g}\") print(f\"vkey = {vkey}\") signal.alarm(1000) while True: choice = input(\"[S]ign, [V]erify: \").strip() if choice == \"S\": message = input(\"message: \").strip() assert message != magic_word sig = sign(h(message), skey) print(f\"(s, t) = {sig}\") elif choice == \"V\": message = input(\"message: \").strip() s = int(input(\"s: \").strip()) t = int(input(\"t: \").strip()) assert 2 &lt;= s &lt; p assert 2 &lt;= t &lt; p if not verify(h(message), (s, t), vkey): print(\"invalid signature\") continue print(\"verified\") if message == magic_word: print(f\"flag = {flag}\") sys.exit(0) else: breaksolve基本的に、公開鍵と秘密鍵は何か数学的な関連性が必要であるから解けないわけで、今回は$x,u$が公開鍵にしか使われていないため、なんでもおｋとなるfrom pwn import *from Crypto.Util.number import getRandomRange, getStrongPrime, inverse, GCDfrom hashlib import sha512io = remote(\"crypto.2023.cakectf.com\" ,10444)# io = process([\"python3\",\"server.py\"])p = int(io.recvline().decode().split(\"= \")[1])g = int(io.recvline().decode().split(\"= \")[1])w,v = eval(io.recvline().decode().split(\"= \")[1])y = (v * pow(w,-1,p-1))%(p-1)x = getRandomRange(2, p-1)magic_word = \"cake_does_not_eat_cat\"u = ((w * x - 1) * inverse(v, p-1)) % (p-1)def h(m): return int(sha512(m.encode()).hexdigest(), 16)def sign(m, key): x, y, u = key r = getRandomRange(2, p-1) return pow(g, x*m + r*y, p), pow(g, u*m + r, p)def verify(m, sig, key): w, v = key s, t = sig print(pow(g, m, p) , pow(s, w, p) * pow(t, -v, p) % p) return pow(g, m, p) == pow(s, w, p) * pow(t, -v, p) % p# sig = sign(h(\"message\"), (x, y, u), )# print( verify(h(\"message\"), sig, (w, v)))# exit()s,t = sign(h(magic_word), (x, y, u))io.sendlineafter(b\": \",b\"V\")io.sendlineafter(b\": \",b\"cake_does_not_eat_cat\")io.sendlineafter(b\": \",str(s).encode())io.sendlineafter(b\": \",str(t).encode())io.interactive()# io.sendlineafter(b\": \",str(t).encode())# CakeCTF{does_yoshiking_eat_cake_or_cat?}janken vs yoshiking 2 43 solvechallimport randomimport signalimport osHANDNAMES = { 1: \"Rock\", 2: \"Scissors\", 3: \"Paper\"}def commit(M, m): while True: r = random.randint(2, 2**256) if r % 3 + 1 == m: break return M**r, rsignal.alarm(1000)flag = os.environ.get(\"FLAG\", \"neko{old_yoshiking_never_die,simply_fade_away}\")p = 1719620105458406433483340568317543019584575635895742560438771105058321655238562613083979651479555788009994557822024565226932906295208262756822275663694111M = random_matrix(GF(p), 5)print(\"[yoshiking]: Hello! Let's play Janken(RPS)\")print(\"[yoshiking]: Here is p: {}, and M: {}\".format(p, M.list()))round = 0wins = 0while True: round += 1 print(\"[system]: ROUND {}\".format(round)) yoshiking_hand = random.randint(1, 3) C, r = commit(M, yoshiking_hand) print(\"[yoshiking]: my commitment is={}\".format(C.list())) hand = input(\"[system]: your hand(1-3): \") print(\"\") try: hand = int(hand) if not (1 &lt;= hand &lt;= 3): raise ValueError() except ValueError: print(\"[yoshiking]: Ohhhhhhhhhhhhhhhh no! :(\") exit() print(\"[yoshiking]: My hand is ... {}\".format(HANDNAMES[yoshiking_hand])) print(\"[yoshiking]: Your hand is ... {}\".format(HANDNAMES[hand])) result = (yoshiking_hand - hand + 3) % 3 if result == 0: print(\"[yoshiking]: Draw, draw, draw!!!\") print(\"[yoshiking]: I'm only respect to win!\") print(\"[system]: you can check that yoshiking doesn't cheat\") print(\"[system]: here's the secret value: {}\".format(r)) exit() elif result == 1: print(\"[yoshiking]: Yo! You win!!! Ho!\") wins += 1 print(\"[system]: wins: {}\".format(wins)) if wins &gt;= 100: break elif result == 2: print(\"[yoshiking]: Ahahahaha! I'm the winnnnnnner!!!!\") print(\"[yoshiking]: You, good loser!\") print(\"[system]: you can check that yoshiking doesn't cheat\") print(\"[system]: here's the secret value: {}\".format(r)) exit()print(\"[yoshiking]: Wow! You are the king of roshambo!\")print(\"[yoshiking]: suge- flag ageru\")print(flag)solvematrixでのDDH仮定みたいなものを判定しろってことみたいです。ただ今回は弱めで$M^t = Y$での$t$が3で割ったあまりがいくつになるかですね。pがb-smoothなので固有値計算してdlpに持ち込もうとしたけど、固有値がなくどうしたものかと思っていたら、前に自作したもので絶対値に落としてdlpができることを思い出し(一部失敗するかもしれないが)やってみたら解けた。solvefrom pwn import *from tqdm import tqdmp = 1719620105458406433483340568317543019584575635895742560438771105058321655238562613083979651479555788009994557822024565226932906295208262756822275663694111# io = process([\"sage\",\"server.sage\"])io = remote(\"crypto.2023.cakectf.com\" ,\"10555\")io.recvline()M = eval(io.recvline().decode().split(\": \")[-1])M = matrix(GF(p),[[M[i+k*5] for i in range(5)] for k in range(5)])Mdet = GF(p)(M.det())for i in tqdm(range(100)): io.recvuntil(b\"[system]: R\") io.recvline() yoshi = eval(io.recvline().decode().split(\"=\")[1]) yoshi = matrix(GF(p),[[yoshi[i+k*5] for i in range(5)] for k in range(5)]) yoshi_det = yoshi.det() nad = discrete_log(GF(p)(yoshi_det), Mdet) if int((nad)%3)+1==1: io.sendlineafter(b\": \",str(int(3)).encode()) if int((nad)%3)+1==2: io.sendlineafter(b\": \",str(int(1)).encode()) if int((nad)%3)+1==3: io.sendlineafter(b\": \",str(int(2)).encode()) io.interactive() # CakeCTF{though_yoshiking_may_die_janken_will_never_perish}ding-dong-ting-ping 17 solvechallimport osfrom base64 import b64decode, b64encodefrom hashlib import md5from datetime import datetimefrom Crypto.Cipher import AESFLAG = os.environ.get(\"FLAG\", \"neko{cat_does_not_eat_cake}\")PREFIX = os.environ.get(\"PREFIX\", \"cakecakecakecake1\").encode()KEY = os.urandom(16)IV = os.urandom(16)aes = AES.new(KEY, AES.MODE_ECB)xor = lambda a, b: bytes([x^y for x, y in zip(a, b)])def pad(data: bytes): l = 16 - len(data) % 16 return data + bytes([l]*l)def unpad(data: bytes): return data[:-data[-1]]def encrypt(plain: bytes): plain = pad(plain) blocks = [plain[i:i+16] for i in range(0, len(plain), 16)] ciphers = [IV] for block in blocks: block = xor(block, md5(ciphers[-1]).digest()) ciphers.append(aes.encrypt(block)) return b\"\".join(ciphers)def decrypt(cipher: bytes): blocks = [cipher[i:i+16] for i in range(0, len(cipher), 16)] h = md5(blocks[0]).digest() # IV plains = [] for block in blocks[1:]: plains.append(xor(aes.decrypt(block), h)) h = md5(block).digest() return unpad(b\"\".join(plains)) def register(): username = b64decode(input(\"username(base64): \").strip()) if b\"root\" in username: print(\"Cannot register as root user!\") else: cookie = b\"|\".join([PREFIX, b\"user=\"+username, str(datetime.now()).encode()]) cookie = encrypt(cookie) cookie = b64encode(cookie) print(\"your cookie =&gt;\", cookie.decode()) returndef login(): cookie = input(\"cookie: \").strip() cookie = decrypt(b64decode(cookie)) data = cookie.split(b\"|\") if (data[0] == PREFIX) and data[1].startswith(b\"user=\"): username = data[1].split(b\"=\")[1] time = data[2] else: print(\"Authentication unsuccessful...\") return print(f\"Hi, {username.decode()}! [registered at {time.decode()}]\") if username != b\"root\": print(\"You're not the root user...\") else: print(\"Ding-Dong, Ding-Dong, Welcome, root. The ultimate authority has logged in.\") print(\"This is for you =&gt; \", FLAG) returnwhile True: print(\"===== MENU =====\") choice = int(input(\"[1]register [2]login: \").strip()) if choice == 1: register() elif choice == 2: login() else: print(\"Invalid choice\") print()solveAES-CBCのxor演算にmd5を用いてるもので、エラーを吐かない限りいくらでもoracleは使える。さらに、timeの部分はcheckされてないことからうまく復元されればなんでも表示してくれる。けど、使わなかった…orz方針として任意の暗号文を暗号化してくれるoracleを構成し、そこから暗号文を組みたてるという作業をおこなえばおｋ問題としては、prefixの長さによってメンドサが変わるが今回は運よく、17文字？だったので1文字をブルートフォースして求めればいいことになる。import osfrom base64 import b64decode, b64encodefrom hashlib import md5from datetime import datetimefrom Crypto.Cipher import AESfrom tqdm import tqdmfrom pwn import *from itertools import productPrint = strcontext.log_level = \"debug\"def encrypt(io,m): io.sendlineafter(b\": \",b\"1\" ) io.sendlineafter(b\": \",b64encode(m)) return b64decode(io.recvline(None).split(b\"=&gt; \")[1])def decrypt(io,m): io.sendlineafter(b\": \",b\"2\" ) io.sendlineafter(b\": \",b64encode(m)) return io.recvline(None).decode()def ecb_oracle(io,m): user = b\"A\"*9 + b\"A\"*16 ret = encrypt(io,user) b = md5(ret[3*16:4*16]).digest() ret = encrypt(io,user + xor(b,m)) return ret[4*16:5*16] io = remote(\"crypto.2023.cakectf.com\" ,\"11111\")# io = process([\"python3\",\"server.py\"])enc_PREFIX = encrypt(io,b\"1\")[:2*16]ret = encrypt(io,b\"AAAAAAAAA\")[2*16:3*16]for i in range(256): if ret == ecb_oracle(io,xor(bytes([i]) + b\"|user=AAAAAAAAA\", md5(enc_PREFIX[-16:]).digest())): print(i) breakelse: print(\"NOT found\") exit()pad = b\"\\x01\"*16body1 = bytes([i])+b\"|user=root|1234\"body1 = ecb_oracle(io,xor(body1, md5(enc_PREFIX[-16:]).digest()))body2 = ecb_oracle(io,xor(pad, md5(body1).digest()))aim = enc_PREFIX + body1+ body2print(decrypt(io,aim))io.interactive()# CakeCTF{dongdingdongding-dingdong-dongdingdong-ding}" }, { "title": "十月初週のupsolve", "url": "/posts/", "categories": "writeup", "tags": "writeup", "date": "2023-09-30 00:00:00 +0900", "snippet": "十月初週のupsolve時間的に出れなかったやつ+解けなかったやつのupsolve時間が許す限り書いてみた。他にもやったけど忘れた…ASISCTF refactorchall#!/usr/bin/env python3from Crypto.Util.number import *from flag import flagdef pgen(nbit):\tx, y = 0, 1\twhile True:\t\tu, v = getRandomRange(1, 110), getRandomRange(1, 313)\t\tprint(u, v )\t\tx, y = u * x + 31337 * v * y, v * x - u * y\t\tif x.bit_length() &lt;= nbit // 2 and x.bit_length() &lt;= nbit // 2:\t\t\tp = x**2 + 31337 * y**2 | 1\t\t\tif isPrime(p) and p.bit_length() &gt;= nbit:\t\t\t\treturn p,x**2 + 31337 * y**2 \t\telse:\t\t\tprint()\t\t\tx, y = 0, 1def encrypt(msg, pkey):\te, n = pkey\tm = bytes_to_long(msg)\tc = pow(m, e, n)\treturn cp, q = [pgen(1024) for _ in '__']pkey = (31337, p * q)c = encrypt(flag, pkey)print(f'n = {p * q}')print(f'c = {c}')solveはじめは一次変換で何とかできんのかねと思ってましたが。。。特に行列の線形で何とかできるわけでもなく適当に生成した$p = 383335841611474253288258749967087188658203719865678826202588775827454938897094153644206800790962935429622538072389187334174056071856288025761508719826829572233136259075355366784281390335902964426872367689398610556483495586882838606704940310135146159104045784806491756138016281172853224810405203956107889868800$が以下に素因数分解できるので、$2^32 * 3^41 * 5^2 * 7^13 * 23^3 * 43^2 * 47^3 * 59^2 * 83^2 * 139 * 149 * 229 * 239 * 257 * 271 * 307 * 673 * 677 * 683 * 691 * 769 * 919 * 1163 * 1289 * 4691 * 4969 * 6229 * 9157 * 10799 * 16883 * 16979 * 29837 * 31337 * 34807 * 44953 * 65633 * 77999 * 235099 * 267781 * 271027 * 378283 * 545023 * 594469 * 644647 * 1498009 * 1535837 * 6577127 * 11794219 * 12075199 * 14300119 * 17062301 * 22574411 * 41120153 * 50521253 * 91379653 * 111311803 * 524726357 * 581782787 * 1026631601$さすがに、なんかあるなぁと思って、$x_{i+1}, y_{i+1} = u_{i} * x_{i} + 31337 * v_{i} * y_{i}, v_{i} * x_{i} - u_{i} * y_{i}$と漸化式を置いて、$p=x_1^2 + 31337 * y_1^2+1$を求めると、ええ感じに因数分解$p=(x_0^2 + 31337*y_0^2) * (u_0^2 + 31337*v_0^2)+1$になったことより$(u_0^2 + 31337*v_0^2)$の全てを求めることができるので、pollardのp-1で求まりそうな予感n = 15354257069173285781905276045639014609593379926482050489113547339117588412057832262093892509606681500550900795674355198875730897090963848584014735402479257641196755288572505568604616504895577156519599359709585689487167929035277328860394887100644352498762646576634768748203691626550604902474991908656069443025123380468043304218262437495617397923826383876725820263637369772201236276175774820781740263113457945850397866995318921153304724846886489062447149970082086628646772837892015556355384776002878980523779509899708723447721484662031731419684247739500573264103203416815345858413217500504527510275599764791910780108801c = 11319719392368830772976523857976369154729855326260479489071566552409492905894844561614086707874832191432242950123964961582894044688274348653418226595519872495639236324552876924940961325755770656445013054487327399663358245181836741250528901918846037855858412978924591011941242779828600098063462814300900861180897010043498668688944295535981632815932395145673684660722012731208682402231321184600968865557231738026003707732466182970622224802483189066444000715061144732475930157185474148162121034705457395021374353689284243509307079898846581316271587575615363632603786729853488699442091342820074301120194843407072588515822from Crypto.Util.number import *cand = [u**2 + 31337 * v**2 for u in range(110) for v in range(313)]tmp = Zmod(n)(c)for k in cand[1:]: tmp ^= k if GCD(tmp-1,n)!=1: p = GCD(tmp-1,n) breakelse: print(\"NOT FOUND\")q = n//pe = 31337for i in GF(p)(c).nth_root(e,all=True): if b\"ASIS\" in long_to_bytes(int(i)): print(long_to_bytes(int(i)))# ASIS{P0lL4rd5_p-1_Al9oR!7Hm_gg!!}もとまった。楽maplectf RNGchallfrom Crypto.Util.number import getPrimefrom secret import flagimport randomclass RNG: def __init__(self, s, a): self.s = s self.a = a def next(self): self.s = (self.s * self.a) % (2 ** 128) return self.s &gt;&gt; 96if __name__ == \"__main__\": rng1 = RNG(getPrime(128), getPrime(64)) rng2 = RNG(getPrime(128), getPrime(64)) assert flag.startswith(\"maple{\") and flag.endswith(\"}\") flag = flag[len(\"maple{\"):-1] enc_flag = [] for i in range(0, len(flag), 4): enc_flag.append(int.from_bytes(flag[i:i+4].encode(), 'big') ^ rng1.next() ^ rng2.next()) outputs = [] for _ in range(42): if random.choice([True, False]): rng1.next() if random.choice([True, False]): rng2.next() if random.choice([True, False]): outputs.append(rng1.next()) else: outputs.append(rng2.next()) print(\"RNG 1:\", rng1.a) print(\"RNG 2:\", rng2.a) print(\"Encrypted flag:\", enc_flag) print(\"Outputs:\", outputs)solveこの問題CTF中はめんどすぎて解いてませんでした(わかったならやるべきだよなぁ、反省してます)まずはkurenaifさんのturncated LCGを詳しく見てください。さて、今回の設定としては2つのLCGの出力がランダムに与えられます。そもそもとしてturncated LCGはLLLの部分で適当に工夫すれば非連続でも解ける時があるので、これをうまく使っていきます。from sage.all import QQfrom sage.all import ZZfrom sage.all import matrixfrom sage.all import vector# modified for https://github.com/jvdsn/crypto-attacks/blob/master/attacks/lcg/truncated_state_recovery.pydef tlcg(y, k, s, m, a, c): diff_bit_length = k - s # Preparing for the lattice reduction. delta = c % m yi = [_[1] for _ in y] y = vector(ZZ, [_[0] for _ in y]) for i in range(len(y)): # Shift output value to the MSBs and remove the increment. y[i] = (y[i] &lt;&lt; diff_bit_length) - delta delta = (a * delta + c) % m # This lattice only works for increment = 0. B = matrix(ZZ, len(y), len(y)) B[0, 0] = m for i in range(1, len(y)): B[i, 0] = a ** yi[i] B[i, i] = -1 B = B.LLL() # Finding the target value to solve the equation for the states. b = B * y for i in range(len(b)): b[i] = round(QQ(b[i]) / m) * m - b[i] # Recovering the states delta = c % m x = list(B.solve_right(b)) for i, state in enumerate(x): # Adding the MSBs and the increment back again. x[i] = int(y[i] + state + delta) delta = (a * delta + c) % m return xfrom Crypto.Util.number import *from itertools import combinationsfrom tqdm import tqdmfrom lll import tlcga1 = 17858755236422136913a2 = 10444850750214055793ct = [3999539808, 1592738381, 1057217965, 215730455, 2499659667]Outputs = [3110779950, 3143489116, 2523808356, 59145943, 424415688, 1607693531, 2579126212, 1755297842, 3906113295, 1470215707, 3409703846, 3241626049, 3619900521, 3320623221, 2749059114, 775644902, 2452534658, 1107040405, 1783853908, 280554339, 3216758786, 2250874382, 2218107153, 4254508193, 2241158217, 2648593639, 2984582005, 3238054409, 3573713662, 2295623647, 1012063687, 1503914767, 2705122053, 2969541370, 2233703326, 1334624347, 1016155206, 2288145534, 2614694809, 1778390279, 999900406, 2501497460]Outputs2 = [3110779950, 3143489116, 2523808356, 59145943, 424415688, 1607693531, 2579126212, 1755297842, 3906113295, 1470215707, 3409703846, 3241626049, 3619900521, 3320623221, 2749059114, 775644902, 2452534658, 1107040405, 1783853908, 280554339, 3216758786, 2250874382, 2218107153, 4254508193, 2241158217, 2648593639, 2984582005, 3238054409, 3573713662, 2295623647, 1012063687, 1503914767, 2705122053, 2969541370, 2233703326, 1334624347, 1016155206, 2288145534, 2614694809, 1778390279, 999900406, 2501497460]class RNG: def __init__(self, s, a): self.s = s self.a = a self.a_inv = pow(a,-1,2 ** 128) def back(self): self.s = (self.s * self.a_inv) % (2 ** 128) return self.s &gt;&gt; 96 def next(self): self.s = (self.s * self.a) % (2 ** 128) return self.s &gt;&gt; 96def oracle(i0,i1,i2,i3,i4): for k0,k1,k2,k3,k4 in combinations(range(15), 5): y = [(Outputs[i0],k0-k0),(Outputs[i1],k1-k0),(Outputs[i2],k2-k0),(Outputs[i3],k3-k0),(Outputs[i4],k4-k0)] state1 = attack(y, 128, 128-96, 2**128, a1, 0) state2 = attack(y, 128, 128-96, 2**128, a2, 0) # print(state1) rng1 = RNG(state1[-1],a1) rng2 = RNG(state2[-1],a2) for i in range(10): if rng1.next() in Outputs: print(\"FOUND STATE1\",state1[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4)) return state1[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4) if rng2.next() in Outputs: print(\"FOUND STATE2\",state2[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4)) return state2[0],[i0,i1,i2,i3,i4],[k0,k1,k2,k3,k4] return False for i0,i1,i2,i3,i4 in tqdm(combinations(range(8), 5)): i0,i1,i2,i3,i4 = (1, 3, 4, 6, 7) tmp = oracle(i0,i1,i2,i3,i4) if tmp!=False: state1, iis, _ = tmp breakrng1 = RNG(state1,a1)rng1.back()for i in range(1000): tmp = rng1.next() if tmp in Outputs2: Outputs2[Outputs2.index(tmp)] = 0state2 = []for i in range(15): if Outputs2[i] !=0: state2.append(i)state2 = oracle(*state2[:5])[0]print(state1)print(state2)for i in range(4): for k in range(4): rng1 = RNG(state1,a1) rng2 = RNG(state2,a2) for _ in range(i): rng1.back() for _ in range(k): rng2.back() m = [] for l in range(5): m.append(long_to_bytes(ct[4-l]^rng2.back()^rng1.back())) print(m[::-1]) print()b\"maple{lcgs_and_lattices}\"" }, { "title": "十月初週のupsolve", "url": "/posts/(copy)/", "categories": "writeup", "tags": "writeup", "date": "2023-09-30 00:00:00 +0900", "snippet": "十月初週のupsolve時間的に出れなかったやつ+解けなかったやつのupsolve時間が許す限り書いてみた。他にもやったけど忘れた…ASISCTF refactorchall#!/usr/bin/env python3from Crypto.Util.number import *from flag import flagdef pgen(nbit):\tx, y = 0, 1\twhile True:\t\tu, v = getRandomRange(1, 110), getRandomRange(1, 313)\t\tprint(u, v )\t\tx, y = u * x + 31337 * v * y, v * x - u * y\t\tif x.bit_length() &lt;= nbit // 2 and x.bit_length() &lt;= nbit // 2:\t\t\tp = x**2 + 31337 * y**2 | 1\t\t\tif isPrime(p) and p.bit_length() &gt;= nbit:\t\t\t\treturn p,x**2 + 31337 * y**2 \t\telse:\t\t\tprint()\t\t\tx, y = 0, 1def encrypt(msg, pkey):\te, n = pkey\tm = bytes_to_long(msg)\tc = pow(m, e, n)\treturn cp, q = [pgen(1024) for _ in '__']pkey = (31337, p * q)c = encrypt(flag, pkey)print(f'n = {p * q}')print(f'c = {c}')solveはじめは一次変換で何とかできんのかねと思ってましたが。。。特に行列の線形で何とかできるわけでもなく適当に生成した$p = 383335841611474253288258749967087188658203719865678826202588775827454938897094153644206800790962935429622538072389187334174056071856288025761508719826829572233136259075355366784281390335902964426872367689398610556483495586882838606704940310135146159104045784806491756138016281172853224810405203956107889868800$が以下に素因数分解できるので、$2^32 * 3^41 * 5^2 * 7^13 * 23^3 * 43^2 * 47^3 * 59^2 * 83^2 * 139 * 149 * 229 * 239 * 257 * 271 * 307 * 673 * 677 * 683 * 691 * 769 * 919 * 1163 * 1289 * 4691 * 4969 * 6229 * 9157 * 10799 * 16883 * 16979 * 29837 * 31337 * 34807 * 44953 * 65633 * 77999 * 235099 * 267781 * 271027 * 378283 * 545023 * 594469 * 644647 * 1498009 * 1535837 * 6577127 * 11794219 * 12075199 * 14300119 * 17062301 * 22574411 * 41120153 * 50521253 * 91379653 * 111311803 * 524726357 * 581782787 * 1026631601$さすがに、なんかあるなぁと思って、$x_{i+1}, y_{i+1} = u_{i} * x_{i} + 31337 * v_{i} * y_{i}, v_{i} * x_{i} - u_{i} * y_{i}$と漸化式を置いて、$p=x_1^2 + 31337 * y_1^2+1$を求めると、ええ感じに因数分解$p=(x_0^2 + 31337*y_0^2) * (u_0^2 + 31337*v_0^2)+1$になったことより$(u_0^2 + 31337*v_0^2)$の全てを求めることができるので、pollardのp-1で求まりそうな予感n = 15354257069173285781905276045639014609593379926482050489113547339117588412057832262093892509606681500550900795674355198875730897090963848584014735402479257641196755288572505568604616504895577156519599359709585689487167929035277328860394887100644352498762646576634768748203691626550604902474991908656069443025123380468043304218262437495617397923826383876725820263637369772201236276175774820781740263113457945850397866995318921153304724846886489062447149970082086628646772837892015556355384776002878980523779509899708723447721484662031731419684247739500573264103203416815345858413217500504527510275599764791910780108801c = 11319719392368830772976523857976369154729855326260479489071566552409492905894844561614086707874832191432242950123964961582894044688274348653418226595519872495639236324552876924940961325755770656445013054487327399663358245181836741250528901918846037855858412978924591011941242779828600098063462814300900861180897010043498668688944295535981632815932395145673684660722012731208682402231321184600968865557231738026003707732466182970622224802483189066444000715061144732475930157185474148162121034705457395021374353689284243509307079898846581316271587575615363632603786729853488699442091342820074301120194843407072588515822from Crypto.Util.number import *cand = [u**2 + 31337 * v**2 for u in range(110) for v in range(313)]tmp = Zmod(n)(c)for k in cand[1:]: tmp ^= k if GCD(tmp-1,n)!=1: p = GCD(tmp-1,n) breakelse: print(\"NOT FOUND\")q = n//pe = 31337for i in GF(p)(c).nth_root(e,all=True): if b\"ASIS\" in long_to_bytes(int(i)): print(long_to_bytes(int(i)))# ASIS{P0lL4rd5_p-1_Al9oR!7Hm_gg!!}もとまった。楽maplectf RNGchallfrom Crypto.Util.number import getPrimefrom secret import flagimport randomclass RNG: def __init__(self, s, a): self.s = s self.a = a def next(self): self.s = (self.s * self.a) % (2 ** 128) return self.s &gt;&gt; 96if __name__ == \"__main__\": rng1 = RNG(getPrime(128), getPrime(64)) rng2 = RNG(getPrime(128), getPrime(64)) assert flag.startswith(\"maple{\") and flag.endswith(\"}\") flag = flag[len(\"maple{\"):-1] enc_flag = [] for i in range(0, len(flag), 4): enc_flag.append(int.from_bytes(flag[i:i+4].encode(), 'big') ^ rng1.next() ^ rng2.next()) outputs = [] for _ in range(42): if random.choice([True, False]): rng1.next() if random.choice([True, False]): rng2.next() if random.choice([True, False]): outputs.append(rng1.next()) else: outputs.append(rng2.next()) print(\"RNG 1:\", rng1.a) print(\"RNG 2:\", rng2.a) print(\"Encrypted flag:\", enc_flag) print(\"Outputs:\", outputs)solveこの問題CTF中はめんどすぎて解いてませんでした(わかったならやるべきだよなぁ、反省してます)まずはkurenaifさんのturncated LCGを詳しく見てください。さて、今回の設定としては2つのLCGの出力がランダムに与えられます。そもそもとしてturncated LCGはLLLの部分で適当に工夫すれば非連続でも解ける時があるので、これをうまく使っていきます。from sage.all import QQfrom sage.all import ZZfrom sage.all import matrixfrom sage.all import vector# modified for https://github.com/jvdsn/crypto-attacks/blob/master/attacks/lcg/truncated_state_recovery.pydef tlcg(y, k, s, m, a, c): diff_bit_length = k - s # Preparing for the lattice reduction. delta = c % m yi = [_[1] for _ in y] y = vector(ZZ, [_[0] for _ in y]) for i in range(len(y)): # Shift output value to the MSBs and remove the increment. y[i] = (y[i] &lt;&lt; diff_bit_length) - delta delta = (a * delta + c) % m # This lattice only works for increment = 0. B = matrix(ZZ, len(y), len(y)) B[0, 0] = m for i in range(1, len(y)): B[i, 0] = a ** yi[i] B[i, i] = -1 B = B.LLL() # Finding the target value to solve the equation for the states. b = B * y for i in range(len(b)): b[i] = round(QQ(b[i]) / m) * m - b[i] # Recovering the states delta = c % m x = list(B.solve_right(b)) for i, state in enumerate(x): # Adding the MSBs and the increment back again. x[i] = int(y[i] + state + delta) delta = (a * delta + c) % m return xfrom Crypto.Util.number import *from itertools import combinationsfrom tqdm import tqdmfrom lll import tlcga1 = 17858755236422136913a2 = 10444850750214055793ct = [3999539808, 1592738381, 1057217965, 215730455, 2499659667]Outputs = [3110779950, 3143489116, 2523808356, 59145943, 424415688, 1607693531, 2579126212, 1755297842, 3906113295, 1470215707, 3409703846, 3241626049, 3619900521, 3320623221, 2749059114, 775644902, 2452534658, 1107040405, 1783853908, 280554339, 3216758786, 2250874382, 2218107153, 4254508193, 2241158217, 2648593639, 2984582005, 3238054409, 3573713662, 2295623647, 1012063687, 1503914767, 2705122053, 2969541370, 2233703326, 1334624347, 1016155206, 2288145534, 2614694809, 1778390279, 999900406, 2501497460]Outputs2 = [3110779950, 3143489116, 2523808356, 59145943, 424415688, 1607693531, 2579126212, 1755297842, 3906113295, 1470215707, 3409703846, 3241626049, 3619900521, 3320623221, 2749059114, 775644902, 2452534658, 1107040405, 1783853908, 280554339, 3216758786, 2250874382, 2218107153, 4254508193, 2241158217, 2648593639, 2984582005, 3238054409, 3573713662, 2295623647, 1012063687, 1503914767, 2705122053, 2969541370, 2233703326, 1334624347, 1016155206, 2288145534, 2614694809, 1778390279, 999900406, 2501497460]class RNG: def __init__(self, s, a): self.s = s self.a = a self.a_inv = pow(a,-1,2 ** 128) def back(self): self.s = (self.s * self.a_inv) % (2 ** 128) return self.s &gt;&gt; 96 def next(self): self.s = (self.s * self.a) % (2 ** 128) return self.s &gt;&gt; 96def oracle(i0,i1,i2,i3,i4): for k0,k1,k2,k3,k4 in combinations(range(15), 5): y = [(Outputs[i0],k0-k0),(Outputs[i1],k1-k0),(Outputs[i2],k2-k0),(Outputs[i3],k3-k0),(Outputs[i4],k4-k0)] state1 = attack(y, 128, 128-96, 2**128, a1, 0) state2 = attack(y, 128, 128-96, 2**128, a2, 0) # print(state1) rng1 = RNG(state1[-1],a1) rng2 = RNG(state2[-1],a2) for i in range(10): if rng1.next() in Outputs: print(\"FOUND STATE1\",state1[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4)) return state1[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4) if rng2.next() in Outputs: print(\"FOUND STATE2\",state2[0],(i0,i1,i2,i3,i4),(k0,k1,k2,k3,k4)) return state2[0],[i0,i1,i2,i3,i4],[k0,k1,k2,k3,k4] return False for i0,i1,i2,i3,i4 in tqdm(combinations(range(8), 5)): i0,i1,i2,i3,i4 = (1, 3, 4, 6, 7) tmp = oracle(i0,i1,i2,i3,i4) if tmp!=False: state1, iis, _ = tmp breakrng1 = RNG(state1,a1)rng1.back()for i in range(1000): tmp = rng1.next() if tmp in Outputs2: Outputs2[Outputs2.index(tmp)] = 0state2 = []for i in range(15): if Outputs2[i] !=0: state2.append(i)state2 = oracle(*state2[:5])[0]print(state1)print(state2)for i in range(4): for k in range(4): rng1 = RNG(state1,a1) rng2 = RNG(state2,a2) for _ in range(i): rng1.back() for _ in range(k): rng2.back() m = [] for l in range(5): m.append(long_to_bytes(ct[4-l]^rng2.back()^rng1.back())) print(m[::-1]) print()b\"maple{lcgs_and_lattices}\"" }, { "title": "DEF CON31参加記", "url": "/posts/DEFCON/", "categories": "DEF CON31", "tags": "DEF CON31", "date": "2023-08-26 00:00:00 +0900", "snippet": "DEF CON31参加記　DEF CONとは…? アメリカのラスベガスで毎年開催される、コンピュータや情報セキュリティーに関係した世界最大規模のイベントまんまこの通りですね。イベントにはvillageやcontestsなどがありまして、それぞれに沿ったテーマに関する体験やCTF、講演を聞くことができます。DEF CON CTF 2023 QualifiersDEF CON finalへの出場を得るための予選が5/27 0:00~5/29 0:00(UTC)に行われていました。実は私も別チーム(if this doesn’t work we’ll get more for next year)で参加していましたが、15位で負けてしましました。さらに、問題自体がrev・pwnが8割を占めているため得意分野がcryptoな私は、椅子を温めているだけでした。(１つcryptoっぽいものがありましたが、唯の暗号ソムリエみたいに暗号を特定するだけの問題でした)なので、実はDEFCONに行く予定はさらさらなかったんですよね…CTFtime.org / DEF CON CTF Qualifier 2023DEFCON 行く経緯リーダーのsahuangさんが行く人いるかと聞いていたので、そこで「多分?」って答えたのが始まりです。（答えていなかったら日本からtwitterを眺めていた気がする）まじで、感謝してます。準備やったことは少なくて、荷造り、ESTAの申請、航空機のチケット確保、ローミングの申請だけですね。荷造りフライトの半月前にsatoki君から「会場はくそ寒いからパーカー持っていくといい」と事前に聞いていたのにもかかわらず、荷造りの時点ですっかり忘れて入れていなかったのですが、DEFCONフライト前日のスペースで言われて急いで魔女パーカーとカーディガンを詰め込みました。あとは、機内goodsとしておしりに敷く用の膨らませる座布団を買いました。ESTAの申請ESTAは申請してから2時間で承認が通ったので特に気にする必要はなかったですね。航空機のチケットの確保航空機のチケットは総額32万ぐらいした気がします。値段を抑えたいのなら早めにとることを強くお勧めします。ローミングの申請海外で自分の携帯を使おうとすると、モバイルルーターかローミングの申請が必要です。モバイルルーターを持ち歩くのは面倒なので携帯会社にローミングの申請をしてそのまま接続すれば、使えるようにしました。フライト当日フライトルートは成田→シアトル→ラスベガスを2つの航空会社を使うルートで取りました。 成田→シアトルはJAL シアトル→ラスベガスはアラスカ航空成田→シアトルフライト時間は8時間程度だったかな…?(履歴がなくて遡れない) なので、座布団で体勢を変える＋ちょっとした運動で体をほぐしてました。ただ、それでも足が痛かったので考え物ですね…機内では、寝るか映画見てました。シアトル→ラスベガスここで、まさかのシアトル行きの飛行機でたまたま同じ飛行機に乗っていることがわかり急遽合流して、入国審査を済ませてシアトルラスベガス行きの飛行機に乗りました。自席に座ると隣に日本人の方がおられました。更に反対側の席には外国の方座られて、お二方ともDEFCON行くとのことだったので情報交換兼ねつつ談笑してました。飛行機から見る景色はずっと岩だらけで町があるのか正直疑いました。DECFON DAY 0飛行機から降りると先についているsahuangさんと合流し、enscribeさんとは後から合流流れとなりましたが、enscribeさんの飛行機が不運なことに2時間半程度遅れることに…ここで、kurenaifさんとはお別れし、sahuangさんとenscribeさんを空港の外のスタバで待つことになり、今度行うSekaiCTFの問題や音ゲーについて話してました。(ただ音ゲーやるのが久しぶりすぎて、くそ雑魚かましていたのは内緒)というわけで、enscribeと合流してからホテルまでuberで向い、チェックインを済ませ、legoclonesさん、zafirrさん、やCSN3RDさんと更に合流し晩飯を食べてました。せっかくなのでカジノやるかという話になり、CSN3RDさんがATMから引き出そうとすると引き出せないという謎な状況もありましたが、とりあえず私は適当に座って20$入れて遊んでたら謎に110$当たって結果的に+110儲けました。(残りのラスベガスでの生活はほとんどこのお金で過ごしていた記憶ですね…)DEF CON DAY 1(8/10)DEFCONに入場するためにはbadgeが必要で、事前に申し込んでいた分の受け取りをしないといけないので皆で受け取っていました。その後はHTBのブースになだれ込んでSekai + 数名でHTB CTFをやることに、ただ問題として私の英語がカスなのとPCをホテルに置いたまんまだったので、自分で勝手にできることもなく意思疎通にとんでもなく苦労しましたが、結果的にsahuangさんやquaserさんがいたのでcryotoは速攻終わり、他のジャンルはわからんのでぶっちゃけ暇な時間となってました。そうこうしていると運営の方が来られて一緒に写真撮ったり、グッズをもらったりしてありがたかったです。その後、kurenaifさんがショッピングしているtweetを見かけたので、HTBを抜けてkurenaifさんと合流してファッション・ショー・ラス・ベガスに行き、くそデカショッピングモールの中を散策してました。その後、satoooonさんとれっくすさんがsekaiと合流しているというのをkurenaifさんからお聞きして私たちも合流することにしたのはいいものの…途中迷子になってあーだーこうだいいつつ何とか？合流場所にたどり着くことができました。その後、日本チックなゲーセンに行くということだったので興味がそそられてついていくと、なんか「平成で見たことあるようなゲーセン」でした。DiceGangの人と合流して遊んでました。その後ラーメンで死ぬほどカルチャーショック受けたのは別のお話…DEF CON DAY 2(8/11)おはようございます。からのIoT villageへそこでIoTを軽くやってからDEFCONの日本組に会いに行こうかなと思っていたら、1時間たってもIoT CTFが始まらないので、先にcloiud villageに移動してazaraさんと初めて会うことに…cloud villageに行ったはいいものの大盛況で部屋に入ろうとするもすぐに入れず30分ほど待ちました。その後部屋の中でazaraさんと合流してcloud ctfをお手伝いしようとしたはいいものの、そもそもcloud自体よくわからず敗北…昼飯時なので、DEFCON finalの会場に移動して頑張っている人たちに挨拶してから、アメリカ版マクドを食べに行くことにしたけど、ビックマックは相変わらず旨かった。その後、会場をふらつきながらcloud ctfの続きもやったりする感じでだらだらしてからazaraさんとお別れした後に、sekaiの人と合流してflamingo近くで行われているタコスパーティへ。このタコスが旨かった…ステージではrickrollでラップするわでハチャメチャだった。その後に会場からペプシ持って帰って、ホテルでenscribeさんと日本旅行について話してたら午前1:30で、腹減ったしペプシ飲むかって飲んだら「BRO…!??、お前寝れるのか..?」って聞かれて「大丈夫、大丈夫」って言った後に「kanon just drank pepsi. idk if he will sleep💀」ってdiscrodで書かれて笑ってましたwwちなみに、布団に入ると10分ほどで寝れました。普通に疲れすぎた。DEF CON DAY 3(8/12)起きて、red alert ctfやってました。なんかジャンルの複合？みたいな問題もあって難しいよりも面倒だなって感じでした。午後からは、昨日にbig Dere6さんとazaraさんと飯を食べに行く約束をしていたので、ハンバーガーを食べてブースを回りながらcloudctfの続きをずっとしてました。夜にZonectfやるぞという話がチームに上がっていたので。DEF CON DAY 4(8/13)朝起きて、DEFCONには行かず、Zonectfを解いていましたが解けずに少し悔しかったです…その後、お昼を食べて、その後に、sahuangさんが余ったお金でカジノ回したらまた大当たり。昼食代をカジノで回収できたらしい…後は空港まで行ってからお別れして、チェックインしたり、スタバ買ったり、スタバ買ったり(時間が余りすぎたので…)して時間つぶしてました。帰り飛行機帰りのフライトルートはラスベガス→ロサンゼルス→羽田をアメリカン航空会社を使うルートで取りました。ラスベガス→ロサンゼルス午後7:30発の飛行機で寝るにも寝れない感じでした。ただ、隣の方がアメリカの軍人の方でちょっとテンション上がってました。ほかにも、飛び立つときや着陸の夜景は綺麗でおおってなってました。ロサンゼルス→ラスベガスロサンゼルスには午後10時ぐらいに着いて、父親から野球のエンゼルスのグッズを買ってくれと言われていたので、買ってきました。あとは適当にケンタッキー食べてこのブログのプロットを書いていたら飛行機の場所が変更になったらしく、しかもターミナルも異なるレベルでの移動で少し疲れました。その後、飛行機に乗ったはいいもののフライト時間は12時間程度かつ出発時間が午前1:30ぐらいだったので、飛行機の10時間は寝てました。すごい疲れてたんだと思います。日本に着くと速攻でラーメン食べました。くそ旨かった最後に初めてのこういうイベントに参加したり、多くのチームのメンバーに会えたりしたのでいい刺激になりました。ただ、英語の能力が低すぎるのもあってチームのメンバーには申し訳なかったのかなと思います。" }, { "title": "zer0pts 2023 writeup", "url": "/posts/zer0ptsCTF-writeup/", "categories": "writeup", "tags": "writeup", "date": "2023-07-16 00:00:00 +0900", "snippet": "zer0ptsCTF久しぶりに長時間参加した気がする…前置き　Project Sekaiで参加してました。結果は18位なのでomgって感じですね。。。実際参加してる人が少なかった＋メインの人がほぼいなかったのも大きいんですかね…代わりにMr godがいましてrevを爆速で全部終わらしてました(強すぎる)残りは、upsolveしたら追加します。。。SquareRNG [crypto 54 solve ] (30 minuts)chall#!/usr/bin/env python3import osfrom Crypto.Util.number import getPrime, getRandomRangedef isSquare(a, p): return pow(a, (p-1)//2, p) != p-1class SquareRNG(object): def __init__(self, p, sa, sb): assert sa != 0 and sb != 0 (self.p, self.sa, self.sb) = (p, sa, sb) self.x = 0 def int(self, nbits): v, s = 0, 1 for _ in range(nbits): self.x = (self.x + 1) % p s += pow(self.sa, self.x, self.p) * pow(self.sb, self.x, self.p) s %= self.p v = (v &lt;&lt; 1) | int(isSquare(s, self.p)) return v def bool(self): self.x = (self.x + 1) % self.p t = (pow(self.sa, self.x, self.p) + pow(self.sb, self.x, self.p)) t %= self.p return isSquare(t, self.p)p = getPrime(256)sb1 = int(input(\"Bob's seed 1: \")) % psb2 = int(input(\"Bob's seed 2: \")) % pfor _ in range(77): sa = getRandomRange(1, p) r1 = SquareRNG(p, sa, sb1) print(\"Random 1:\", hex(r1.int(32))) r2 = SquareRNG(p, sa, sb2) print(\"Random 2:\", hex(r2.int(32))) guess = int(input(\"Guess next bool [0 or 1]: \")) if guess == int(r1.bool()): print(\"OK!\") else: print(\"NG...\") breakelse: print(\"Congratz!\") print(os.getenv(\"FLAG\", \"nek0pts{*** REDACTED ***}\"))solveLCG$s_x \\equiv \\sum_{i=1}^{x}(sa^x*sb^x) + 1\\mod p$の出力に関して$(s_x/p)$のルジャンドル記号の値が$sb$が2回入力できることから2つ得られるので、そこから$(sa^{33}+sb^{33} /p)$のルジャンドル記号の出力を当てろっていう感じみたいです。そもそも、ルジャンドル記号はその数$a$がある素数$p$において$a \\equiv x^2 \\mod p$となるような$x$の存在の判定するものです。ルジャンドル記号には平方剰余の相互法則という$(a/p)*(b/p) = (ab/p)$があるのでこれを使えたらなーという気持ちで男は黙って因数分解します。ここで、$sa^{33}+sb^{33}$を因数分解しちゃって、$sa^{33}+sb^{33} = (sa + sb) * (sa^2 - sa*sb + sb^2) * (sa^{10} - sa^9*sb + sa^8*sb^2 - sa^7*sb^3 + sa^6*sb^4 - sa^5*sb^5 + sa^4*sb^6 - sa^3*sb^7 + sa^2*sb^8 - sa*sb^9 + sb^10) * (sa^{20} + sa^{19}*sb - sa^{17}*sb^3 - sa^{16}*sb^4 + sa^{14}*sb^6 + sa^{13}*sb^7 - sa^{11}*sb^9 - sa^{10}*sb^10 - sa^9*sb^{11} + sa^7*sb^{13} + sa^6*sb^{14} - sa^4*sb^{16} - sa^3*sb^{17} + sa*sb^{19} + sb^{20})$ってなります。めでたく因数分解できた(てか対称式なので当たり前)ので、さっき貰った出力に置き換えていきます。ここで、最初の項以外をかけわせてしまえば、$sa^{32} - sa^{31}*sb + sa^{30}*sb^2 - sa^{29}*sb^3 + sa^{28}*sb^4 - sa^{27}*sb^5 + sa^{26}*sb^6 - sa^{25}*sb^7 + sa^{24}*sb^8 - sa^{23}*sb^9 + sa^{22}*sb^{10} - sa^{21}*sb^{11} + sa^{20}*sb^{12} - sa^{19}*sb^{13} + sa^{18}*sb^{14} - sa^{17}*sb^{15} + sa^{16}*sb^{16} - sa^{15}*sb^{17} + sa^{14}*sb^{18} - sa^{13}*sb^{19} + sa^{12}*sb^{20} - sa^{11}*sb^{21} + sa^{10}*sb^{22} - sa^9*sb^{23} + sa^8*sb^{24} - sa^7*sb^{25} + sa^6*sb^{26} - sa^5*sb^{27} + sa^4*sb^{28} - sa^3*sb^{29} + sa^2*sb^{30} - sa*sb^{31} + sb^{32} = \\sum_{i=1}^{x}(sa^x + (-sb)^x) + 1$$sb$に$-sb$を代入したときに得られた項の最終項と一致します。さらに残りの$sa+sb$は仮に$sb=1$とすると？$sa+1$となりこれは、$s_1 \\equiv sa + 1\\mod p$と同値なので、$sb1=1,sb2=-1$を代入します。そこから結果の1bitを掛け算すると答えが出ます。from Crypto.Util.number import getPrime, getRandomRangefrom pwn import *io = remote(\"crypto.2023.zer0pts.com\",\"10666\")io.sendlineafter(b\": \",b\"1\")io.sendlineafter(b\": \",b\"-1\")for i in range(77): ct1 = eval(io.recvline().decode().split(\" \")[-1]) ct2 = eval(io.recvline().decode().split(\" \")[-1]) ct1 = bin(ct1)[2:].zfill(32) ct2 = bin(ct2)[2:].zfill(32) ans = (1-(int(ct2[-1])^int(ct1[0])))%2 io.sendlineafter(b\": \",str(int(ans)).encode()) print(io.recvline())io.interactive()# zer0pts{L(a)L(b)=L(ab)}easy_factoring (coworker solved) [crypto 95 solve ] (?? minuts)challimport osimport signalfrom Crypto.Util.number import *flag = os.environb.get(b\"FLAG\", b\"dummmmy{test_test_test}\")def main(): p = getPrime(128) q = getPrime(128) n = p * q N = pow(p, 2) + pow(q, 2) print(\"Let's factoring !\") print(\"N:\", N) p = int(input(\"p: \")) q = int(input(\"q: \")) if isPrime(p) and isPrime(q) and n == p * q: print(\"yey!\") print(\"Here you are\") print(flag) else: print(\"omg\")def timeout(signum, frame): print(\"Timed out...\") signal.alarm(0) exit(0)if __name__ == \"__main__\": signal.signal(signal.SIGALRM, timeout) signal.alarm(30) main() signal.alarm(0)solve???さっきのLCG解いて休憩したらsahuangパイセンとquasarさんが爆速で解いてました(多分unintend)ので、また今度のupsolveってことで….$N = p^2+q^2$の$p,q$を求めよということですが、なんということでしょうディオファントス問題(だよね??)まぁOTOKO HA DAMATTE INSUUBUNKAI $N=(p+qi)*(p-qi)$って感じですね。んで、複素数体自体はUFDだけどその$(p+qi)$自体がさらに因数を持つ可能性があるので因数の積で出るのかなぁ？(知らない)elliptic_ring_rsa [crypto 27 solve ] (2 hour)challimport stringimport randomimport osflag = os.environb.get(b\"FLAG\", b\"dummmmy{test_test_test}\")class EllipticRingElement:\tpoint = None\tdef __init__(self, point):\t\tself.point = point\t\tdef __add__(self, other):\t\tif self.point == dict():\t\t\treturn other\t\tif other.point == dict():\t\t\treturn self\t\tres = self.point.copy()\t\tfor k in other.point.keys():\t\t\tif k in res:\t\t\t\tres[k] += other.point[k]\t\t\t\tif res[k] == 0:\t\t\t\t\tres.pop(k)\t\t\telse:\t\t\t\tres[k] = other.point[k]\t\t\t\tif res[k] == 0:\t\t\t\t\tres.pop(k)\t\treturn EllipticRingElement(res)\t\tdef __mul__(self, other):\t\tif self.point == dict() or other.point == dict():\t\t\treturn self.point()\t\tres = dict()\t\tfor k1 in other.point.keys():\t\t\tfor k2 in self.point.keys():\t\t\t\tE = k1 + k2\t\t\t\tk = other.point[k1] * self.point[k2]\t\t\t\tif E in res:\t\t\t\t\tres[E] += k\t\t\t\t\tif res[E] == 0:\t\t\t\t\t\tres.pop(E)\t\t\t\telse:\t\t\t\t\tres[E] = k\t\t\t\t\tif res[E] == 0:\t\t\t\t\t\tres.pop(E)\t\treturn EllipticRingElement(res)\t\tdef __repr__(self):\t\tst = \"\"\t\tfor k in self.point.keys():\t\t\tst += f\"{self.point[k]}*({k[0]}, {k[1]}) + \"\t\treturn st[:-3]\tclass EllipticRing:\tE = None\tBase = None\tdef __init__(self, E):\t\tself.E = E\t\tself.Base = E.base()\tdef __call__(self, pt):\t\tfor P in pt:\t\t\tpt[P] = self.Base(pt[P])\t\treturn EllipticRingElement(pt)\t\tdef zero(self):\t\treturn EllipticRingElement(dict())\t\tdef one(self):\t\treturn EllipticRingElement({E(0): self.Base(1)})\t\tdef pow(self, x, n):\t\tres = self.one()\t\twhile n:\t\t\tif (n &amp; 1):\t\t\t\tres = res * x\t\t\tx = x * x\t\t\tn &gt;&gt;= 1\t\treturn res\t\tdef encode(self, m, length):\t\tleft = random.randint(0, length - len(m))\t\tpad1 = \"\".join(random.choices(string.ascii_letters, k=left)).encode(\"utf-8\")\t\tpad2 = \"\".join(random.choices(string.ascii_letters, k=length-len(m)-left)).encode(\"utf-8\")\t\tm = pad1 + m + pad2\t\tPs = []\t\twhile len(Ps) &lt; length:\t\t\tPP = self.E.random_element()\t\t\tif PP not in Ps:\t\t\t\tPs.append(PP)\t\tPs = sorted(Ps)\t\tM = dict()\t\tfor coef, pt in zip(m, Ps):\t\t\tM[pt] = self.Base(coef)\t\treturn EllipticRingElement(M)\tdef random_prime_bits(nbits):\treturn random_prime(2^nbits-1, false, 2^(nbits-1))nbits = 8p = random_prime_bits(nbits)Fp = GF(p)a = Fp.random_element()b = Fp.random_element()E = EllipticCurve(Fp, [a, b])ER = EllipticRing(E)P = ER.encode(flag, 30)e = 13C = ER.pow(P, e)print(f\"p: {p}\")print(f\"C: {C}\")print(f\"a: {a}\")print(f\"b: {b}\")print(f\"e: {e}\")solveとりあえず楕円は楕円だけど演算が..?て感じなので見ていきます。なんか$A’ =a_0*P_0 + a_2*P_2 + …+a_{r-1}*P_{r-1}$って感じの元に見えますねこれ。掛け算は、多項式の掛け算と同じで$A’*B’ = \\sum_{i=0}^{r-1}\\sum_{j=0}^{r-1}((a_i+b_j)*P_{i+j})$って感じですね。足し算も、多項式の掛け算と同じで$A’+B’ = \\sum_{i=0}^{r-1}(a_i+b_j)*P_{i})$って感じ。乗算における逆元は….$A = (1+P_1)$等が存在しないはず！(理由は後程)てな感じで多項式環に準同型写像出来そうですねこれ！！ならこの元全体の集合を$G$、写像先の集合を$H$とすると、$\\phi : G\\to H: P_i \\mapsto x^i$っていう多項式への写像を構成することにします。ここで、$A$の世界で行われていたことを考えてみると、$P$という元を構築し、$P^e$しているだけです。ってことで$\\phi$→rsaのような逆演算→$\\hat \\phi$ で元に戻ります。STEP1 写像の作成とりあえず基準となる$g \\in A$を探します(位数は最大のもの)、それを使って写像します。def plus2dict(_C): cc = dict() _C = _C.split(\" + \") for c in _C: if c.split(\"*\")[1] == \"(0, 1)\": cc[E(0)] = c.split(\"*\")[0] else: cc[E(eval(c.split(\"*\")[1]))] = c.split(\"*\")[0] _C = cc return _CPR.&lt;x&gt; = PolynomialRing(GF(p))gen = x^192-1QR.&lt;x&gt; = QuotientRing(PR, gen)while True: g = E.random_element() if g.order() == r: break def ec2vec(g,_C): vec = 0 for i in range(0,r): try: vec += (int(_C[g*i])*x^i) except KeyError as e: continue return vecC = plus2dict(C)C = ec2vec(g,C)これでおしまい。PART2 rsa likeな復号$A’ \\in G$から$A’'\\in H$に写像できたので、$H$について考えます。$Z_p[x]/(X^{192}-1)$という群構造を持ちます。ここで、$x^{192}-1$は因数分解できてしまい、規約多項式にはなりませんので拡大体にはならないのですべての元が乗法での逆元を持ちません。($(X+1)| X^{192}-1$より逆元を持たない、かつさっきの写像を考えると…)よって、$H$は多項式環になるので多項式環のrsaの復号を考えます。略しますが、位数は$p^k-1$の約数なことが知られていています。ここで、Men must keep their mouths shut and factorizeすると$e | p^k-1$といういやーな感じですが、位数的には$A’'^{p^k-1//e} \\equiv 1 \\mod p$で問題なかったのでよしとします。よって、通常のRSAっぽく$d = e^{-1} \\mod (p^k-1)//e$として、$B’'\\equiv A’'^d \\mod p $で最終的に復号できます。d = int(pow(13,-1,(p^192-1)//13))print((C^d))m = str(C^d)PART3 逆写像最後に逆写像して終わりです。最初に求めた$g$を基準にして逆写像していきます。ms = []ps = []for i in m.split(\" + \")[:-1]: g_tmp = g*int(i.split(\"^\")[1]) ms.append([g_tmp,chr(int(i.split(\"*\")[0]))]) ps.append(g_tmp)これで、最後にソートして順に係数を文字に起こしてやるとflagが求まります。写像考えるのまじで楽しかったです。あと、これはそれなりに実行速度早いはず..??(知らんけど)ってことで、これの想定解が気になるところ…??ps_ori = str([i.xy() for i in ps])ps_sort = sorted(ps)print(ps_ori)ps_ori = [E(i) for i in eval(ps_ori)]for i in range(len(ps_sort)): num = ps_ori.index(ps_sort[i]) print(ms[num][1],end=\"\")# zer0pts{Gr0up_r1ng_meow!!}C = \"182*(91, 45) + 147*(3, 164) + 85*(62, 60) + 53*(77, 59) + 99*(77, 152) + 18*(137, 59) + 106*(169, 101) + 147*(127, 127) + 154*(152, 163) + 121*(43, 73) + 155*(110, 160) + 202*(116, 45) + 195*(1, 84) + 106*(71, 162) + 33*(209, 122) + 112*(134, 164) + 186*(1, 127) + 72*(183, 116) + 141*(141, 39) + 72*(83, 127) + 157*(197, 175) + 6*(178, 24) + 106*(71, 49) + 114*(57, 201) + 95*(181, 58) + 1*(174, 44) + 193*(202, 27) + 182*(121, 95) + 52*(167, 179) + 109*(184, 177) + 110*(21, 162) + 101*(126, 170) + 208*(47, 102) + 168*(129, 105) + 209*(179, 123) + 210*(160, 70) + 10*(13, 103) + 159*(76, 55) + 165*(31, 26) + 31*(44, 119) + 47*(6, 70) + 150*(74, 47) + 117*(30, 65) + 3*(108, 69) + 61*(43, 138) + 151*(72, 209) + 122*(110, 51) + 127*(44, 92) + 64*(191, 113) + 61*(45, 70) + 155*(91, 166) + 175*(95, 194) + 97*(21, 49) + 210*(66, 191) + 129*(129, 106) + 210*(80, 7) + 157*(174, 167) + 45*(141, 172) + 189*(155, 78) + 160*(194, 1) + 209*(82, 28) + 142*(164, 136) + 135*(199, 155) + 166*(118, 95) + 100*(123, 14) + 203*(121, 116) + 22*(36, 20) + 33*(65, 58) + 196*(189, 60) + 75*(137, 152) + 22*(125, 4) + 45*(119, 162) + 59*(47, 109) + 102*(177, 157) + 196*(109, 20) + 112*(192, 94) + 97*(209, 89) + 67*(95, 17) + 129*(75, 55) + 34*(134, 47) + 156*(60, 156) + 135*(127, 84) + 11*(148, 147) + 194*(202, 184) + 27*(45, 141) + 131*(4, 166) + 166*(148, 64) + 183*(164, 75) + 177*(130, 145) + 128*(107, 8) + 204*(156, 40) + 131*(17, 25) + 99*(177, 54) + 122*(82, 183) + 52*(178, 187) + 130*(168, 19) + 14*(150, 150) + 173*(167, 32) + 82*(184, 34) + 172*(72, 2) + 144*(169, 110) + 7*(118, 116) + 96*(181, 153) + 34*(133, 5) + 97*(207, 17) + 24*(78, 161) + 54*(57, 10) + 90*(143, 188) + 172*(130, 66) + 179*(146, 65) + 38*(55, 202) + 170*(63, 31) + 99*(35, 65) + 162*(150, 61) + 56*(74, 164) + 146*(144, 85) + 196*(133, 206) + 164*(152, 48) + 139*(176, 153) + 92*(125, 207) + 124*(31, 185) + 136*(0, 1) + 118*(107, 203) + 28*(24, 56) + 66*(171, 151) + 127*(76, 156) + 63*(208, 59) + 187*(146, 146) + 138*(85, 0) + 195*(19, 190) + 115*(60, 55) + 87*(171, 60) + 194*(17, 186) + 79*(75, 156) + 181*(27, 37) + 38*(192, 117) + 168*(13, 108) + 41*(143, 23) + 167*(199, 56) + 177*(86, 71) + 160*(35, 146) + 165*(189, 151) + 130*(32, 30) + 39*(108, 142) + 197*(36, 191) + 176*(120, 17) + 180*(194, 210) + 204*(19, 21) + 160*(6, 141) + 195*(109, 191) + 194*(155, 133) + 62*(65, 153) + 6*(138, 107) + 12*(201, 62) + 43*(180, 43) + 178*(208, 152) + 86*(180, 168) + 135*(55, 9) + 5*(138, 104) + 118*(207, 194) + 58*(160, 141) + 173*(66, 20) + 16*(179, 88) + 181*(61, 131) + 3*(80, 204) + 137*(119, 49) + 106*(126, 41) + 127*(176, 58) + 64*(144, 126) + 96*(30, 146) + 165*(168, 192) + 104*(27, 174) + 64*(63, 180) + 35*(123, 197) + 111*(86, 140) + 141*(197, 36) + 83*(116, 166) + 159*(4, 45) + 165*(62, 151) + 94*(183, 95) + 133*(3, 47) + 58*(83, 84) + 149*(201, 149) + 96*(20, 112) + 141*(191, 98) + 113*(24, 155) + 139*(61, 80) + 73*(120, 194) + 116*(78, 50) + 68*(156, 171) + 31*(32, 181)\"p = 211a = 201b = 102e = 13r = 192 # E.order()E = EllipticCurve(GF(p),[a,b])def plus2dict(_C): cc = dict() _C = _C.split(\" + \") for c in _C: if c.split(\"*\")[1] == \"(0, 1)\": cc[E(0)] = c.split(\"*\")[0] else: cc[E(eval(c.split(\"*\")[1]))] = c.split(\"*\")[0] _C = cc return _CPR.&lt;x&gt; = PolynomialRing(GF(p))gen = x^192-1QR.&lt;x&gt; = QuotientRing(PR, gen)while True: g = E.random_element() if g.order() == r: breakprint(\"[+] REFERNCE POINT\",g) def ec2vec(g,_C): vec = 0 for i in range(0,r): try: vec += (int(_C[g*i])*x^i) except KeyError as e: continue return vecC = plus2dict(C)C = ec2vec(g,C)d = int(pow(13,-1,(p^192-1)//13))print(\"[+] AFTER DECRYPT\",C^d)m = str(C^d)ms = []ps = []for i in m.split(\" + \")[:-1]: g_tmp = g*int(i.split(\"^\")[1]) ms.append([g_tmp,chr(int(i.split(\"*\")[0]))]) ps.append(g_tmp) print(\"[+] AFTER INVERSE MAPPING\",ps)ps_ori = str([i.xy() for i in ps])ps_sort = sorted(ps)ps_ori = [E(i) for i in eval(ps_ori)]print(\"[+] FLAG : \",end=\"\")for i in range(len(ps_sort)): num = ps_ori.index(ps_sort[i]) print(ms[num][1],end=\"\")# zer0pts{Gr0up_r1ng_meow!!}" }, { "title": "CPCTF 2023 writeup", "url": "/posts/CPCTF-writeup/", "categories": "writeup", "tags": "writeup", "date": "2023-02-19 00:00:00 +0900", "snippet": "CPCTFなんか空き時間見つけて参加してました。面白かったですsimplechallfrom Crypto.Util.number import inverse, bytes_to_long, getPrimefrom flag import flagclass complex_over_p: \"\"\" a + bi \"\"\" def __init__(self, a, b, p): self.a = a self.b = b self.p = p def __mul__(self, other): return complex_over_p( (self.a * other.a - self.b * other.b) % self.p, (self.a * other.b + self.b * other.a) % self.p, self.p, ) def __pow__(self, n: int): ret = complex_over_p(1, 0, self.p) x = complex_over_p(self.a, self.b, self.p) while n &gt; 0: if n &amp; 1: ret = ret * x x = x * x n &gt;&gt;= 1 return ret def __str__(self): return str(self.a) + \" + \" + str(self.b) + \"i\"p = getPrime(512)q = getPrime(512)n = p * qphi = (p - 1) * (q - 1)e = 65537m = bytes_to_long((flag).encode(\"utf-8\"))c_1 = complex_over_p(p, m, n) ** ec_2 = complex_over_p(q, m, n) ** ewith open(\"cipher.txt\", \"w\") as f: f.write(f\"c_1 = {str(c_1)}\\n\") f.write(f\"c_2 = {str(c_2)}\\n\") f.write(f\"n = {n}\\n\") f.write(f\"e = {e}\\n\")solve面白いですね。複素数体上での離散対数問題的な？？とりあえず、こういうのは$p,q$を求めないと始まらないのが鉄則なので求めていきます。$c_1 = (p+mi)^e=\\sum_{i=0}^e {}_eC_i p^i(mi)^{e-i}$より実数部は$p$でくくれる気がします。よって、$p=GCD(Re(c_1),n)$で求まりそうな気がします。さて、ここから問題で$m$を求めなければいけないですが、どうしたものかと。。。$c_1 \\equiv (p+mi)^e \\mod n$より$c_1 \\equiv (mi)^e \\mod p$となるのでこれの虚数部を考えるとただのフェルマーの小定理ですよね！なら、$d \\equiv e^{-1} \\mod p-1$とすれば解決しますね！！ここで一つ、$phi$についてミスリードではないかという話を見かけた気がするので。。。実際そこだけ見るとミスリードな気もしますが、そもそもとして$p$の値を出せた時点でその辺の知識を理解しているものと考えていいような気がしますで、ミスリードにならないと私は考えますし、これは解いたうえでの私の意見です。c_1 = [88947353384906315386142174915579230007708484691905461586249734733895208303904624706955572569717469153074453837889147058757297004159523404800499566731846573280606881057150101844929178328363240743156762837486978571114151912836342740869293096891054377782752248810122413624567401981982628574682163267589540717955 , 105796218607197626508309219898970081654433389611035862776816738031930217893350585142033078143656160997324512315260317101196998029046142078518167267210684968483205795618377068578645969888568133775820377659323101885187136507439656053103103802476138541844262969937543381511564444761769799873705129093296227488320]c_2 = [6246646181898635030418930144979030696163268885489193597189892517442414814959679853409630585655482080447639092928109757977342458025765218315720433756032748568912426451942636486110411038484872363928990656032625950245328223463301109739166158341796991125915052131277132622262221136515681121985807852466393611412 , 53817519046828021036896927561082153848829725683909509411136093993919199941896521025977358288420902565544951255959786518459773639829589216874164688208953119794504853435052217109342811249935881805211646847973929482665869312260539685753735469177452027367949870932823024534083790996822338074496201028292592498398]n = 115660927134746496667389439939121894365639159618801107805144217447831876345527158612296725729945512010246362315164908359385194177739042272399000609673334050698528059482827768728850630523188582862374516240503442919767592843273925939238586765096529791229982128395675821790738782110235716669724330392693672332699e = 65537from Crypto.Util.number import *p = GCD(n,88947353384906315386142174915579230007708484691905461586249734733895208303904624706955572569717469153074453837889147058757297004159523404800499566731846573280606881057150101844929178328363240743156762837486978571114151912836342740869293096891054377782752248810122413624567401981982628574682163267589540717955)q = GCD(6246646181898635030418930144979030696163268885489193597189892517442414814959679853409630585655482080447639092928109757977342458025765218315720433756032748568912426451942636486110411038484872363928990656032625950245328223463301109739166158341796991125915052131277132622262221136515681121985807852466393611412,n)assert p*q == nclass complex_over_p: \"\"\" a + bi \"\"\" def __init__(self, a, b, p): self.a = a self.b = b self.p = p def __mul__(self, other): return complex_over_p( (self.a * other.a - self.b * other.b) % self.p, (self.a * other.b + self.b * other.a) % self.p, self.p, ) def __pow__(self, n: int): ret = complex_over_p(1, 0, self.p) x = complex_over_p(self.a, self.b, self.p) while n &gt; 0: if n &amp; 1: ret = ret * x x = x * x n &gt;&gt;= 1 return ret def __str__(self): return str(self.a) + \" + \" + str(self.b) + \"i\" dp = pow(e,-1,p-1)mp = pow(c_1[1],int(dp),p)print(long_to_bytes(mp))misusechall\"\"\"This code is designed to be run with SageMath.See https://www.sagemath.org/If you don't have SageMath installed, you can use the online version at https://cocalc.com/ or https://sagecell.sagemath.org/But you may not use pyton lib online...ref: https://doc.sagemath.org/html/en/index.html\"\"\"from Crypto.Util.number import bytes_to_long, long_to_bytes, isPrimefrom flag import flagfrom Crypto.Cipher import AESfrom base64 import b64encodefrom secret import keyfrom Crypto.Util.Padding import padp = 1457379754778834114393428514496372769300186542434939310975944765431765709327445548009771988242361974038539406450275157591a = 1236064211753439722521344199773932075287648377233139862790772102290062141518569630890922001641345393262197009050412379555b = 1128111897991419355721141214155995058314857116431662004640521251265155838304469066234949556324122951758680646976644303642def lift_x(x, p): assert p % 4 == 3 z = (x**3 + a * x + b) % p res = pow(z, (p + 1) // 4, p) return res % p, -res % pif __name__ == \"__main__\": assert isPrime(p) F = GF(p) m = flag.encode(\"utf-8\") cipher = AES.new(long_to_bytes(key), AES.MODE_CBC) iv = cipher.iv c = cipher.encrypt(pad(m, AES.block_size)) x = bytes_to_long(long_to_bytes(key) + c) assert x &lt; p d = 65537 ecc = EllipticCurve(F, [a, b]) y = lift_x(x, p)[0] P = ecc(x, y) Q = d * P with open(\"public.txt\", \"w\") as f: f.write(f\"iv={bytes_to_long(b64encode(iv))}\\n\") f.write(f\"Q_x={Q[0]}\\n\") f.write(f\"Q_y={Q[1]}\\n\")solve楕円曲線問題ですね。。。$Q=[65537]P$となる$P$を見つけてほしいと。。。位数を$r$とする時において$P=[e]Q$となるような$e$が存在する時、$P=[e]([65537]P)=[65537e]P)$となるわけですね！！よって$65537e \\mod r \\equiv1$が成り立ち$e$を求めてGGですね!!from Crypto.Util.number import bytes_to_long, long_to_bytes, isPrimefrom Crypto.Cipher import AESfrom base64 import b64encode,b64decodefrom Crypto.Util.Padding import padfrom attacks.ecc.mov_attack import attackiv=1605329254557036569964018111218106639001485748371419774269Q_x=1392303607889887553584136595208390161792050603172364540235291678701315789244344186052295822556700256817290239704363991998Q_y=1217907436356492041789129865417129927287034438783900990437895711720259012753482269603468893642710812002767867785347902249p = 1457379754778834114393428514496372769300186542434939310975944765431765709327445548009771988242361974038539406450275157591a = 1236064211753439722521344199773932075287648377233139862790772102290062141518569630890922001641345393262197009050412379555b = 1128111897991419355721141214155995058314857116431662004640521251265155838304469066234949556324122951758680646976644303642ecc = EllipticCurve(GF(p), [a, b])d = 65537# r = ecc.order()r = 1457379754778834114393428514496372769300186542434939310975942617452418525644269374582205991018703761232026759172619867624Q = ecc(Q_x, Q_y)Px = int(pow(d,-1,r))*Qassert Px*d == QPx = Px.xy()[0]Px = long_to_bytes(int(Px))key = Px[:AES.block_size]ct = Px[AES.block_size:]cipher = AES.new(key, AES.MODE_CBC,iv=b64decode(long_to_bytes(int(iv))))c = cipher.decrypt(ct)print(c)# 'CPCTF{Manual_is_imp0rtant}" }, { "title": "大学院が終わってしまった", "url": "/posts/Reflections_on_Graduate_School/", "categories": "university", "tags": "university", "date": "2023-02-19 00:00:00 +0900", "snippet": "初めに3月24日を持ちましてとある大学の博士前期課程を修了し、無事修士(工学)の学位を頂くことができました。あまり、大学院のことを書くこともなかったので振り返りの意味も込めて研究室配属から修了まで書いてみようかと思います。ただ、1年以上前のこともあるので記憶があやふやなかもしれません。研究生活B4そもそも、僕の大学では学部4年生から研究室に配属され卒業論文と修士論文に向けて研究を始めます。この時点では、今の大学に残る気は毛頭なく、別の大学に大学院から移る予定でいました。(B3の3月には研究室見学に行ったり、院試対策始めたり)　なので、セキュリティとはどんなものかや数学を学ぶつもりで学部4年を過ごそうかなと考えていたら4月前ぐらいから日本でもコロナが流行し、研究室でも感染症対策が行われるようになりました。ゼミはオンラインで行い、研究室の同期や先輩がどんな人かもわからず、あれこれ詰んでね????ってなってゲームに逃げました。8月頃?(曖昧です…)には少しは緩和されたので少しは研究室で研究できるようになりました。このころには研究室の最低限の知識やテーマを把握できてきたタイミングで、あまり詳しくは述べられませんが研究室の数学を扱ったテーマが実装寄りな部分なことが大半なこともあってモチベは正直全くなかったです。（ごめんなさい）さらに、この時期に院試がありますが、予定していた大学院の院試日程が今いる大学の院試日程と被ってしまうので、どうするのかめちゃくちゃ悩みましたが、チキって今いる大学の院試を受けました。受験終わりに本当にこの選択で良かったのか今でも悩んでいます。そろそろテーマの研究を決めてスタートさせないと卒業論文が後々きつくなると思いますが、研究テーマは先生が適当に興味もったものを適当に理論構築してやってました。ここでも、興味はありましたがモチベは正直なかった状態から変わらなかったのでどうしようもないです。ただ、ここから転機があり、ある先輩から10月ごろに「数学好きなんだよね?、ならこの研究やってみない？」って言われながら両肩をポンっと叩かれました。基本的な内容は知っていたのと楽しそうだったので二つ返事で「やります!!」って答えて研究がスタートします。とはいっても、卒業論文はこのテーマでないので、ちゃんと研究するのはまた今度という状態でしたが。。。こんな半分適当な感じで過ごして学部4年生は終わりました。この時点でapex legendのプレイ時間が3000時間突破してた気がする…M1修士1年は、前に比べてコロナの対応も比較的緩くなったので、週2-3ぐらいで研究室に行って作業・研究してました。同期や先輩のこともだんだんと分かってきたので、前半にNISTのPQCの選定が佳境に入ったというのを聞いて、研究室の同級生PQCの論文を読んでみることにしました。初めて英語論文かつ、初めての見る理論なので読むのには相当の時間(2-3ヵ月)を使いましたが、やりたいことや数学的な構造は最低限わかるようになり少しずつモチベが出てきて来ました。そんなこんやで、PQCと格闘してたら、何かのはずみ(研究室のドクターの人からだったかも?)でcryptoctfなるものを聞いたので、研究室の先輩や同級生とやってました。面白いけど実装力が皆無なので、思いついた解法を同級生に実装してもらって解いてました。この後ぐらいに2週間の会社へのインターンへ行くことになり、詳しくは話せませんがいい体験をさせていただきました。研究と営利企業との差を感じれたのは大きいと感じてます。少しして、私の大学の大学生・大学院生を対象としたCTFを12月に行うという話がありました。へー研究室でやるんだと思っていると、サーバー周りは先輩が、私はcryptoの問題作成する流れになったので4問ほど簡単な奴をあれやこれや言いながら作ってました。更にdiscord serverを調整したりしてちょっとした裏方もやってると、本番が来たので作問ミスがないようにお祈りしながらdiscord serverとsolve数を見てました。結果としてミスはなかったようでいい経験ができました。更にこの頃からkanonを名乗って本格的にCTFをやるようになっていきました。更に、学部4年生の時に引き継いだ研究に進展があり、準教授の先生に話し見るといいところまで狙えるかもしれないとなったので、修士論文もある程度目途がついたこともあり一気に肩の荷が下りました。さらにこの時点で就活もある程度目途がつき、就職に悩む必要もなくなりました。そんなこんなで、修士1年生はCTFを始めて、研究に進展があったので一安心できる一年でした。M2コロナの制限も昔ほどきつくはないのでほぼほぼ研究室にきて作業してました。さらに、M2になると研究より発表の方がメインになるので比較的時間は作りやすかったです。そのため、前半は研究の成果として国際会議での発表やCTFやCTFをしてました。6月に後輩の一部もCTFをやり始めていたこともあり、10問ほど作問して先生からお金を出してもらい少しの賞金付きの研究室内CTFを1人で開催したりもしてました。7-8月頃に転機があり、今まで1年間誰とも交流せず一人でやってきましたが、twitterを作成して情報収集するかと思っていると札幌でオフラインイベントがあったので申し込むと、ありがたいことにSECCON Beginners 2022 札幌 に参加させていただくことができました。revとwebでしたが運よく3位になれてよかったです。てか、意外と学部生や高専生がいることに驚きが隠せませんでした。そんなこんやで、Satoooon (@Satoooon1024) / Twitterさんとチーム組んでsekaictfに出たり11月にはSECCON CTFの予選をやったりしてました。研究の方も成果は修士1年の時にある程度出ていたのでそれをもって6月と10月に国際会議で発表してました。これで、後はSECCON 本戦だけだと思ってたら、準教授の先生に論文誌も出すよって言われて締め切り見ると2月中旬で、その時は後だからいいやと思ってましたが、実は2月が一番忙しかったという。。。2月に二日おきに締め切りが来て順に、修論の提出期限、SECCON本戦、論文誌の投稿期限、修論の発表スライド、修論発表会という意味不明で地獄の時間でした。まじで、SECCONメンバーには迷惑かけたので申し訳ないです。。そんなこんなもありましたが、無事卒業できたのでよかったです。遊び元々旅行が好きで色々な場所に行ってましたがコロナになって旅行ができなくなり楽しみも消えました。でも、修士になると制限も徐々に解除されてきたので、だんだんと頻度が増えていきました。高校の同級生や学部の友達、研究室の友達とか色々誘って高知や札幌などなど日本各地に行きました。多分、コロナがまだ流行っていたら行けてなかったのでそこは救いでした。結構リフレッシュになるので。。これから実は、新社会人と並行して博士後期課程に社会人Dとして進学します。今出している論文の採録結果が4月初めに通知が来るはずで、もし、通ればこれの採録が8月になるので論文誌の業績が稼げるので博士課程の修了要件の一番重い部分をクリアできるので。でも、通らなかったら即やめることになります。もし、通らずに博士課程に行くと多分多忙で死ねるので。。。それは、先に話を通して教授や会社の方も了承済みです。まとめ初めはコロナに翻弄された研究生活でしたが、後々になるとコロナも落ち着いてきて比較的自由に色々研究や活動をさせていただいたので大変ありがたかったです。そのおかげでCTFから得たものを研究に還元できたり、色々な人と交流を持てたのはいいことかなと思いました。ここまで駄文を読んでくださりありがとうございます！　また、どこかでお会いしましょう！ではまたﾉｼP.S. 就職先は東京なので、飯行きましょう！！" }, { "title": "HackTM writeup", "url": "/posts/HackTM-writeup/", "categories": "ctf, writeup", "tags": "ctf, writeup", "date": "2023-02-19 00:00:00 +0900", "snippet": "初めにSECCON終わりの初フル参加CTFでした。SECCONでぼこされたので、初心忘るべからずでいきました。色々見てる感じ Double Lariat のメンバー誘えば良かったと後悔…orz多分いい所まで行けたんじゃないかなぁ…[crypto] d-phi-encchallfrom Crypto.Util.number import bytes_to_long, getStrongPrimefrom secret import flagassert len(flag) == 255e = 3p = getStrongPrime(1024, e=e)q = getStrongPrime(1024, e=e)n = p * qphi = (p - 1) * (q - 1)d = pow(e, -1, phi)enc_d = pow(d, e, n)enc_phi = pow(phi, e, n)enc_flag = pow(bytes_to_long(flag), e, n)print(f\"{n = }\")print(f\"{enc_d = }\")print(f\"{enc_phi = }\")print(f\"{enc_flag = }\")solve$enc_{phi} \\equiv phi^e \\mod n,enc_d \\equiv d^e \\mod n$ から $phi$ を復元すればおっけーです。なので $e^e*enc_d \\equiv (ed)^e \\mod n \\equiv (k*phi+1)^e \\mod n$ で$k$は2であることが手元で実験してわかってるので、 多項式gcdで$phi$だして後は良しなに…from Crypto.Util.number import *from sage.all import *n = 24476383567792760737445809443492789639532562013922247811020136923589010741644222420227206374197451638950771413340924096340837752043249937740661704552394497914758536695641625358888570907798672682231978378863166006326676708689766394246962358644899609302315269836924417613853084331305979037961661767481870702409724154783024602585993523452019004639755830872907936352210725695418551084182173371461071253191795891364697373409661909944972555863676405650352874457152520233049140800885827642997470620526948414532553390007363221770832301261733085022095468538192372251696747049088035108525038449982810535032819511871880097702167enc_d = 23851971033205169724442925873736356542293022048328010529601922038597156073052741135967263406916098353904000351147783737673489182435902916159670398843992581022424040234578709904403027939686144718982884200573860698818686908312301218022582288691503272265090891919878763225922888973146019154932207221041956907361037238034826284737842344007626825211682868274941550017877866773242511532247005459314727939294024278155232050689062951137001487973659259356715242237299506824804517181218221923331473121877871094364766799442907255801213557820110837044140390668415470724167526835848871056818034641517677763554906855446709546993374enc_phi = 3988439673093122433640268099760031932750589560901017694612294237734994528445711289776522094320029720250901589476622749396945875113134575148954745649956408698129211447217738399970996146231987508863215840103938468351716403487636203224224211948248426979344488189039912815110421219060901595845157989550626732212856972549465190609710288441075239289727079931558808667820980978069512061297536414547224423337930529183537834934423347408747058506318052591007082711258005394876388007279867425728777595263973387697391413008399180495885227570437439156801767814674612719688588210328293559385199717899996385433488332567823928840559enc_flag = 24033688910716813631334059349597835978066437874275978149197947048266360284414281504254842680128144566593025304122689062491362078754654845221441355173479792783568043865858117683452266200159044180325485093879621270026569149364489793568633147270150444227384468763682612472279672856584861388549164193349969030657929104643396225271183660397476206979899360949458826408961911095994102002214251057409490674577323972717947269749817048145947578717519514253771112820567828846282185208033831611286468127988373756949337813132960947907670681901742312384117809682232325292812758263309998505244566881893895088185810009313758025764867e = 3poly_gcd = lambda g1, g2: g1.monic() if not g2 else poly_gcd(g2, g1%g2)PR.&lt;phi&gt; = PolynomialRing(Zmod(n))poly = [(2*phi +1)^e - enc_d * e^3, phi^3 -enc_phi,]phi = poly_gcd(poly[0],poly[1]).small_roots()[0]PR.&lt;p,q&gt; = QQ[]polys = [ p*q -n, (p-1)*(q-1) - int(phi),]I = Ideal(polys)ans = I.variety(ring=ZZ)[0]p, q = ans[p], ans[q]d = pow(e,-1,int(phi))print(long_to_bytes(int(pow(enc_flag,d,n))))# HackTM{Have you warmed up? If not, I suggest you consider the case where e=65537, although I don't know if it's solvable. Why did I say that? Because I have to make this flag much longer to avoid solving it just by calculating the cubic root of enc_flag.}[crypto] kaitenzushichallfrom math import gcdfrom Crypto.Util.number import bytes_to_long, isPrimefrom secret import p, q, x1, y1, x2, y2, e, flag# properties of secret variablesassert isPrime(p) and p.bit_length() == 768assert isPrime(q) and q.bit_length() == 768assert isPrime(e) and e.bit_length() == 256assert gcd((p - 1) * (q - 1), e) == 1assert x1.bit_length() &lt;= 768 and x2.bit_length() &lt;= 768assert y1.bit_length() &lt;= 640 and y2.bit_length() &lt;= 640assert x1 ** 2 + e * y1 ** 2 == p * qassert x2 ** 2 + e * y2 ** 2 == p * q# encrypt flag by RSA, with xorn = p * qc = pow(bytes_to_long(flag) ^^ x1 ^^ y1 ^^ x2 ^^ y2, e, n)print(f\"{n = }\")print(f\"{c = }\") ,# hints 🍣F = RealField(1337)x = vector(F, [x1, x2])y = vector(F, [y1, y2])# rotatetheta = F.random_element(min=-pi, max=pi)R = matrix(F, [[cos(theta), -sin(theta)], [sin(theta), cos(theta)]])x = R * xy = R * yprint(f\"{x = }\")print(f\"{y = }\")solve見た感じ $x1,y1,x2,y2$ の復元をやらないと始まんないみたいですね。てなわけで、方針として以下の感じになります。 $x1,y1,x2,y2$ の復元 $p,q$ の素因数分解part1写像後のprintされているものを $X_i,Y_i$ にして式に書くと下の感じになる。\\[\\begin{bmatrix} X_1 &amp; Y_1 \\\\ X_2 &amp; Y_2\\end{bmatrix} =\\begin{bmatrix} cos(\\theta) &amp; sin(\\theta) \\\\ sin(\\theta) &amp; cos(\\theta)\\end{bmatrix} \\begin{bmatrix} x_1 &amp; y_1 \\\\ x_2 &amp; y_2\\end{bmatrix}\\]さらに、$x_1^2 + e* y_1^2 = p*q,x_2^2 + e* y_2^2 = p*q$であることも考えると全て変数化して、終結式へ投げるといい感じに帰ってくるdef resultant(f1, f2, var): return Matrix(f1.sylvester_matrix(f2, var)).determinant()PR.&lt;c,s,e,x0,x1,y0,y1,n&gt; = QQ[]polys = [ c^2 + s^2 - 1, (x0*c + x1*s)^2 + e*(c* y0 + s*y1)^2 - n, (x1*c + x0*(-s))^2 + e*(c* y1 + (-s)*y0)^2 - n,]print(resultant(polys[1], polys[2], s))# s side# 4*s^4*x0^2*x1^2*y0^4 + 4*s^4*x1^4*y0^4 - 8*s^4*x0^3*x1*y0^3*y1 - 8*s^4*x0*x1^3*y0^3*y1 + 4*s^4*x0^4*y0^2*y1^2 + 8*s^4*x0^2*x1^2*y0^2*y1^2 + 4*s^4*x1^4*y0^2*y1^2 - 8*s^4*x0^3*x1*y0*y1^3 - 8*s^4*x0*x1^3*y0*y1^3 + 4*s^4*x0^4*y1^4 + 4*s^4*x0^2*x1^2*y1^4 - 8*s^4*x1^2*y0^4*n + 16*s^4*x0*x1*y0^3*y1*n - 8*s^4*x0^2*y0^2*y1^2*n - 8*s^4*x1^2*y0^2*y1^2*n + 16*s^4*x0*x1*y0*y1^3*n - 8*s^4*x0^2*y1^4*n - 4*s^2*x0^2*x1^2*y0^4 - 4*s^2*x1^4*y0^4 + 8*s^2*x0^3*x1*y0^3*y1 + 8*s^2*x0*x1^3*y0^3*y1 - 4*s^2*x0^4*y0^2*y1^2 - 8*s^2*x0^2*x1^2*y0^2*y1^2 - 4*s^2*x1^4*y0^2*y1^2 + 8*s^2*x0^3*x1*y0*y1^3 + 8*s^2*x0*x1^3*y0*y1^3 - 4*s^2*x0^4*y1^4 - 4*s^2*x0^2*x1^2*y1^4 + 4*s^4*y0^4*n^2 + 8*s^4*y0^2*y1^2*n^2 + 4*s^4*y1^4*n^2 + 8*s^2*x1^2*y0^4*n - 16*s^2*x0*x1*y0^3*y1*n + 8*s^2*x0^2*y0^2*y1^2*n + 8*s^2*x1^2*y0^2*y1^2*n - 16*s^2*x0*x1*y0*y1^3*n + 8*s^2*x0^2*y1^4*n + x1^4*y0^4 - 2*x0^2*x1^2*y0^2*y1^2 + x0^4*y1^4 - 4*s^2*y0^4*n^2 - 8*s^2*y0^2*y1^2*n^2 - 4*s^2*y1^4*n^2 - 2*x1^2*y0^4*n + 2*x0^2*y0^2*y1^2*n + 2*x1^2*y0^2*y1^2*n - 2*x0^2*y1^4*n + y0^4*n^2 - 2*y0^2*y1^2*n^2 + y1^4*n^2後は代入すると、n = ----[snipped]----ct = ----[snipped]----x = ----[snipped]----y = ----[snipped]----F = RealField(1337)PR.&lt;s&gt; = PolynomialRing(F)x0,x1 = xy0,y1 = ypoly_s = 4*s^4*x0^2*x1^2*y0^4 + 4*s^4*x1^4*y0^4 - 8*s^4*x0^3*x1*y0^3*y1 - 8*s^4*x0*x1^3*y0^3*y1 + 4*s^4*x0^4*y0^2*y1^2 + 8*s^4*x0^2*x1^2*y0^2*y1^2 + 4*s^4*x1^4*y0^2*y1^2 - 8*s^4*x0^3*x1*y0*y1^3 - 8*s^4*x0*x1^3*y0*y1^3 + 4*s^4*x0^4*y1^4 + 4*s^4*x0^2*x1^2*y1^4 - 8*s^4*x1^2*y0^4*n + 16*s^4*x0*x1*y0^3*y1*n - 8*s^4*x0^2*y0^2*y1^2*n - 8*s^4*x1^2*y0^2*y1^2*n + 16*s^4*x0*x1*y0*y1^3*n - 8*s^4*x0^2*y1^4*n - 4*s^2*x0^2*x1^2*y0^4 - 4*s^2*x1^4*y0^4 + 8*s^2*x0^3*x1*y0^3*y1 + 8*s^2*x0*x1^3*y0^3*y1 - 4*s^2*x0^4*y0^2*y1^2 - 8*s^2*x0^2*x1^2*y0^2*y1^2 - 4*s^2*x1^4*y0^2*y1^2 + 8*s^2*x0^3*x1*y0*y1^3 + 8*s^2*x0*x1^3*y0*y1^3 - 4*s^2*x0^4*y1^4 - 4*s^2*x0^2*x1^2*y1^4 + 4*s^4*y0^4*n^2 + 8*s^4*y0^2*y1^2*n^2 + 4*s^4*y1^4*n^2 + 8*s^2*x1^2*y0^4*n - 16*s^2*x0*x1*y0^3*y1*n + 8*s^2*x0^2*y0^2*y1^2*n + 8*s^2*x1^2*y0^2*y1^2*n - 16*s^2*x0*x1*y0*y1^3*n + 8*s^2*x0^2*y1^4*n + x1^4*y0^4 - 2*x0^2*x1^2*y0^2*y1^2 + x0^4*y1^4 - 4*s^2*y0^4*n^2 - 8*s^2*y0^2*y1^2*n^2 - 4*s^2*y1^4*n^2 - 2*x1^2*y0^4*n + 2*x0^2*y0^2*y1^2*n + 2*x1^2*y0^2*y1^2*n - 2*x0^2*y1^4*n + y0^4*n^2 - 2*y0^2*y1^2*n^2 + y1^4*n^2# print(poly_s.roots())_, _, c, s = [_[0] for _ in poly_s.roots()]これで $sin(\\theta),cos(\\theta)$の値がわかった。ただ、候補が2つある(正回転or逆回転)ので代入して、値が整数ということを考えてやれば一意に決まる。def solve_xs_ys(s,c): x = ----[snipped]---- y = ----[snipped]---- F = RealField(1337) x = vector(F, [_ for _ in x]) y = vector(F, [_ for _ in y]) # rotate R = matrix(F, [[c, -s], [s, c]]) x = R^(-1) * x y = R^(-1) * y # print(f\"{x = }\") # print(f\"{y = }\") return x,y# true# print(solve_xs_ys(s,c))# ret = (1.23343431936894440973263647479974540141395074556779828339916509613682879668610901423506961118285523166037774054833601787794419590891163752205158573276826154790166536984681500991748749778629881670438838666011425669518792357094873553000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005e230, -9.93315378106395196440156892634615357425859001976376351903878161126954317590016249318316631584063366449446002974804447367756266228508159317926113473123770241598131922105753478630709094061327843793983555725542453353312556415777678936999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999998e230), (2.95702891759040183827241488621026109955415212852401225663178715196876893509028690821994463400830412991408307468450766653970029004782754586267046590672581397139817053510458959806568392753705926800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e192, -1.93518098174342694414424160720807163740044134017573004218248685165604434384710484681124817651698709818703976889508767807895216618103609127904817977547152172876909535027087606807328610207963607999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999989e191)ret = (123343431936894440973263647479974540141395074556779828339916509613682879668610901423506961118285523166037774054833601787794419590891163752205158573276826154790166536984681500991748749778629881670438838666011425669518792357094873553, -993315378106395196440156892634615357425859001976376351903878161126954317590016249318316631584063366449446002974804447367756266228508159317926113473123770241598131922105753478630709094061327843793983555725542453353312556415777678937), (2957028917590401838272414886210261099554152128524012256631787151968768935090286908219944634008304129914083074684507666539700290047827545862670465906725813971398170535104589598065683927537059268, -193518098174342694414424160720807163740044134017573004218248685165604434384710484681124817651698709818703976889508767807895216618103609127904817977547152172876909535027087606807328610207963608)(x1, x2), (y1, y2) = retこれで、part1はおしまい。part2難関??なのか風呂入ってたら思いつきました。兎にも角にも $e$ は速攻でわかるので、出しておきます。x0,x1 = xy0,y1 = ypoly_e = (x0*c + x1*s)^2 + e*(c* y0 + s*y1)^2 - nprint(poly_e.roots())#[(1.1157800980263640943712375759161704818976014542355242141862733874983591656180100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e77, 1)]e = 111578009802636409437123757591617048189760145423552421418627338749835916561801本題です。今回は条件として $x1,y1,x2,y2$ が楕円上の有理点であることから、$x_1^2 + e* y_1^2 = p*q,x_2^2 + e* y_2^2 = p*q$ の等式が成り立つ。一旦、$\\mod p$ を取ると\\[x_1^2 + e* y_1^2 \\equiv 0 \\mod p\\]\\[x_2^2 + e* y_2^2 \\equiv 0 \\mod p\\]ここで、上の式には $y_2^2$ を、下の式には $y_1^2$ を、かけてやると以下になる。\\[(x_1y_2)^2 + e* (y_1y_2)^2 \\equiv 0 \\mod p\\]\\[(x_2y_1)^2 + e* (y_1y_2)^2 \\equiv 0 \\mod p\\]仮に、ある $x_{tmp}$ が座標に存在すると $±y_{tmp}$ も同様に存在します。このことも加味すると\\[(x_1y_2)^2 \\equiv (x_2y_1)^2\\]\\[±x_1y_2 \\equiv \\mp x_2y_1\\]これより $p,q$ どちらかの素数が出すことができるので復号しておわり。p = GCD(int(x1*y2 -x2*y1),n)q = n//pprint(p)assert p*q == nn = ----[snipped]----ct = ----[snipped]----x = ----[snipped]----y = ----[snipped]----e = 111578009802636409437123757591617048189760145423552421418627338749835916561801p = 957509848415776008506125961998120495161250346184055094697245571121876444575553394581756735245207167681344755095903616730328731358607257251854603846193989936802222147961302618645021044609662945352893811478461448918625795339911124621ret = (123343431936894440973263647479974540141395074556779828339916509613682879668610901423506961118285523166037774054833601787794419590891163752205158573276826154790166536984681500991748749778629881670438838666011425669518792357094873553, -993315378106395196440156892634615357425859001976376351903878161126954317590016249318316631584063366449446002974804447367756266228508159317926113473123770241598131922105753478630709094061327843793983555725542453353312556415777678937), (2957028917590401838272414886210261099554152128524012256631787151968768935090286908219944634008304129914083074684507666539700290047827545862670465906725813971398170535104589598065683927537059268, -193518098174342694414424160720807163740044134017573004218248685165604434384710484681124817651698709818703976889508767807895216618103609127904817977547152172876909535027087606807328610207963608)(x1, x2), (y1, y2) = retq = n//pphi = (p-1)*(q-1)d = pow(int(e),-1,phi)m = pow(c,d,n)print(m)m = x1 ^ y1 ^ x2 ^ y2 ^ mprint(m.bit_length())print(long_to_bytes(int(m)))# HackTM{r07473_pr353rv35_50m37h1n6}ただ、復号すると HackTM{r07473_pr353rv35_50m37h1n6sになるので何かミスってる可能性あるかも…????でも、ここまで来たら初心者OSINTしてs → }だろってことで出したら通りました。GG[crypto] broken_oracle (can’t solve)chall#!/usr/local/bin/python3\"\"\"implementation of https://www.cs.umd.edu/~gasarch/TOPICS/miscrypto/rabinwithrecip.pdf\"\"\"import osimport randomfrom dataclasses import dataclassfrom math import gcdfrom typing import List, Tupleimport gmpy2from Crypto.Util.number import bytes_to_long, getPrimefrom secret import flag@dataclassclass Pubkey: n: int c: int@dataclassclass Privkey: p: int q: int@dataclassclass Enc: r: int s: int t: int def __repr__(self) -&gt; str: return f\"r = {self.r}\\ns = {self.s}\\nt = {self.t}\"def crt(r1: int, n1: int, r2: int, n2: int) -&gt; int: g, x, y = gmpy2.gcdext(n1, n2) assert g == 1 return int((n1 * x * r2 + n2 * y * r1) % (n1 * n2))def gen_prime(pbits: int) -&gt; int: p = getPrime(pbits) while True: if p % 4 == 3: return p p = getPrime(pbits)def genkey(pbits: int) -&gt; Tuple[Pubkey, Privkey]: p, q = gen_prime(pbits), gen_prime(pbits) n = p * q c = random.randint(0, n - 1) while True: if gmpy2.jacobi(c, p) == -1 and gmpy2.jacobi(c, q) == -1: break c = random.randint(0, n - 1) pubkey = Pubkey(n=n, c=c) privkey = Privkey(p=p, q=q) return pubkey, privkeydef encrypt(m: int, pub: Pubkey) -&gt; Enc: assert 0 &lt; m &lt; pub.n assert gcd(m, pub.n) == 1 r = int((m + pub.c * pow(m, -1, pub.n)) % pub.n) s = int(gmpy2.jacobi(m, pub.n)) t = int(pub.c * pow(m, -1, pub.n) % pub.n &lt; m) enc = Enc(r=r, s=s, t=t) assert s in [1, -1] assert t in [0, 1] return encdef solve_quad(r: int, c: int, p: int) -&gt; Tuple[int, int]: \"\"\" Solve x^2 - r * x + c = 0 mod p See chapter 5. \"\"\" def mod(poly: List[int]) -&gt; None: \"\"\" Calculate mod x^2 - r * x + c (inplace) \"\"\" assert len(poly) == 3 if poly[2] == 0: return poly[1] += poly[2] * r poly[1] %= p poly[0] -= poly[2] * c poly[0] %= p poly[2] = 0 def prod(poly1: List[int], poly2: List[int]) -&gt; List[int]: \"\"\" Calculate poly1 * poly2 mod x^2 - r * x + c \"\"\" assert len(poly1) == 3 and len(poly2) == 3 assert poly1[2] == 0 and poly2[2] == 0 res = [ poly1[0] * poly2[0] % p, (poly1[1] * poly2[0] + poly1[0] * poly2[1]) % p, poly1[1] * poly2[1] % p, ] mod(res) assert res[2] == 0 return res # calculate x^exp mod (x^2 - r * x + c) in GF(p) exp = (p - 1) // 2 res_poly = [1, 0, 0] # = 1 cur_poly = [0, 1, 0] # = x while True: if exp % 2 == 1: res_poly = prod(res_poly, cur_poly) exp //= 2 if exp == 0: break cur_poly = prod(cur_poly, cur_poly) # I think the last equation in chapter 5 should be x^{(p-1)/2}-1 mod (x^2 - Ex + c) # (This change is not related to vulnerability as far as I know) a1 = -(res_poly[0] - 1) * pow(res_poly[1], -1, p) % p a2 = (r - a1) % p return a1, a2def decrypt(enc: Enc, pub: Pubkey, priv: Privkey) -&gt; int: assert 0 &lt;= enc.r &lt; pub.n assert enc.s in [1, -1] assert enc.t in [0, 1] mps = solve_quad(enc.r, pub.c, priv.p) mqs = solve_quad(enc.r, pub.c, priv.q) ms = [] for mp in mps: for mq in mqs: m = crt(mp, priv.p, mq, priv.q) if gmpy2.jacobi(m, pub.n) == enc.s: ms.append(m) assert len(ms) == 2 m1, m2 = ms if m1 &lt; m2: m1, m2 = m2, m1 if enc.t == 1: m = m1 elif enc.t == 0: m = m2 else: raise ValueError return mif __name__ == \"__main__\": pbits = 1024 pub, priv = genkey(pbits) while len(flag) &lt; 255: flag += os.urandom(1) enc_flag = encrypt(bytes_to_long(flag), pub) print(\"encrypted flag:\") print(enc_flag) while True: try: r, s, t = map(int, input(\"r, s, t = \").split(\",\")) enc = Enc(r=r, s=s, t=t) enc_dec_enc = encrypt(decrypt(enc, pub, priv), pub) print(\"decrypt(encrypt(input)):\") print(enc_dec_enc) except Exception: print(\"Something wrong...\")solve初めに $priv,pub$ すら分かってないので、一旦、$p,q$ を求めていく。具体的には、このシステムはdec → enc を行ってくれるもの、たまに入力した $enc$ ではない値が出ることがあるので、それを使って $p,q$ を求めていく。帰ってくる値としては(多分) $a, a+k_1p,a+k_2q,a+k_3p+k_3q$的な感じだと思う。なので、GCD を上手く使ってやるdef find_n(io,p,n): cnt = 1 factors =set() while True: ret = [] for _s in [-1,1]: for _t in [0,1]: tmp = send_ans(cnt,_s,_t) if False == tmp: return False ret.append(tmp[0]) if len(set(ret)) ==2: _ = abs(ret[0]-ret[1]) _ = factor(_,limit=10^8)[-1][0] factors.add(_) if len(set(ret)) ==4: _ = GCD(abs(ret[0]-ret[2]) ,abs(ret[3]-ret[1])) _ = factor(_,limit=10^8)[-1][0] factors.add(_) fac_list = list(factors) fac_list.sort() for i in fac_list: for k in fac_list: if GCD(i,k) !=1: factors.add(GCD(i,k)) if len(factors) &lt;3: cnt +=1 continue if int(fac_list[0]).bit_length() &lt; 1025 and int(fac_list[1]).bit_length() &lt; 1025 and int(fac_list[0])!=1 and int(fac_list[1])!=1: print(\"ret=\",int(fac_list[0]),int(fac_list[1])) return int(fac_list[0]),int(fac_list[1]) cnt +=1これで、 $priv$ の復元が終わったので、$pub$ どうすっかなー問題の発生案1 $x^2 + E*x + c$の剰余環を考えるsolve_quad関数で $x^{(p-1)//2} \\equiv ax +b-1 \\mod x^2 + E*x + c$ を考えているよって、安直に2変数の剰余環でいいかなぁって考えていたら toy implementation でいつまでたっても終わらない…案2 案1を encの解を$A_1,A_2$ として　グレブナーごり押し$x^{(p-1)//2}$ を $x^2 -Ex+c$ が割り切れない時に値がバグるので、この時のsolve_quad関数の解を $A_1,A_2$ とする。ここで、$r = A_1 + {C \\over A_1}$ であることから $r = A_1 + A_1 * {C \\over A_1*A_2}$となる??\\[r1 + r2 = A_1 + A_1 * {C \\over A_1*A_2} + A_2 + A_2 * {C \\over A_2*A_1}\\]\\[r1 * r2 = (A_1 + A_1 * {C \\over A_1*A_2}) * (A_2 + A_2 * {C \\over A_2*A_1})\\]以上の式が成り立ちそう…???でもとけぬ…げせぬ…多分あってた….でも、 間に合わないです……orz# PR.&lt;c&gt; = PolynomialRing(GF(q))PR.&lt;C,C_prime&gt; = PolynomialRing(GF(q))# C_prime = A1 * A2# i = A1 + A2polys = [ C_prime^2 + (i^2 - 2*C_prime)*C + C^2 - C_prime* dec[0] * dec[1], i * (C + C_prime) - C_prime * (dec[0] + dec[1]),]I = Ideal(polys)ans = I.variety()print(ans)追記競技終了10分後に求まりました。泣きそうです。。。方針案2で合っていてそれで終わります。GGfrom pwn import *from server import decrypt, Privkey,Pubkey,Encfrom random import randintfrom factordb.factordb import FactorDBimport gmpy2from Crypto.Util.number import *poly_gcd = lambda g1, g2: g1.monic() if not g2 else poly_gcd(g2, g1%g2)def send_ans(r,s,t): io.sendlineafter(b\"r, s, t = \",(str(r)+\",\"+str(s)+\",\"+str(t)).encode()) if b\"Something\" in io.recvline(): return False return [int(_) for _ in io.recvline().decode().split(\"=\")[1].split(\",\")]p = 0n = 0def find_n(io,p,n): cnt = 1 p,n =0,0 factors =set() while True: ret = [] for _s in [-1,1]: for _t in [0,1]: tmp = send_ans(cnt,_s,_t) if False == tmp: return False ret.append(tmp[0]) if len(set(ret)) ==2: _ = abs(ret[0]-ret[1]) _ = factor(_,limit=10^8)[-1][0] factors.add(_) if len(set(ret)) ==4: _ = GCD(abs(ret[0]-ret[2]) ,abs(ret[3]-ret[1])) _ = factor(_,limit=10^8)[-1][0] factors.add(_) fac_list = list(factors) fac_list.sort() for i in fac_list: for k in fac_list: if GCD(i,k) !=1: factors.add(GCD(i,k)) if len(factors) &lt;3: cnt +=1 continue if int(fac_list[0]).bit_length() &lt; 1025 and int(fac_list[1]).bit_length() &lt; 1025 and int(fac_list[0])!=1 and int(fac_list[1])!=1: # print(\"ret=\",int(fac_list[0]),int(fac_list[1])) return int(fac_list[0]),int(fac_list[1]) return False cnt +=1def find_c(io,p,q): p = int(str(p)) q = int(str(q)) retc = [] for t_prime in [q,p]: for i in range(3,100): ret = [] for _t in [0,1]: # for _s in [-1,1]: ret.append(send_ans(i,1,_t)[0]) if len(set(ret)) !=2: continue # print(ret,i) if GCD(ret[0] - ret[1],t_prime) !=1: continue PR.&lt;C,C_prime&gt; = PolynomialRing(GF(t_prime)) polys = [ C_prime^2 + (i^2 - 2*C_prime)*C + C^2 - C_prime* ret[0] * ret[1], i * (C + C_prime) - C_prime * (ret[0] + ret[1]), ] I = Ideal(polys) ans = I.variety()[1] print(t_prime,ans) retc.append([t_prime,ans[C]]) break return retc while True: io = remote(\"34.141.16.87\", 50001) # io = process([\"python3\",\"server.py\"]) io.recvline() # rst exec(io.recvline(None).decode()) exec(io.recvline(None).decode()) exec(io.recvline(None).decode()) print(r,s,t) tmp = find_n(io,p,n) if False == tmp: io.close() continue q,p = tmp n = p*q if p&gt;q: p,q = q,p print(p,q) print(\"findc\") cs = find_c(io,p,q) C = int(CRT([int(cs[0][1]),int(cs[1][1])],[int(cs[0][0]),int(cs[1][0])])) print(\"C\",C) p = int(p) q = int(q) r = int(r) s = int(s) t = int(t) for c in cs: m = decrypt(Enc(r,s,t),Pubkey(n = p*q,c = C),Privkey(p=p,q=q)) print(decrypt(Enc(r,s,t),Pubkey(n = p*q,c = C),Privkey(p=p,q=q))) print(long_to_bytes(int(m))) exit()# b'HackTM{h4v3_y0u_r34lly_f0und_4ll_7h3_bu65...?}\\x8d\\xc3\\xd5~vH\\x918\\xd1\\t\\x92 \\x13v\\xd9\\xee\\x8aS&gt;B\\xd3\\xdbl\\xe5\\x88\\xcfE\\xfc\\xa1\\x18o@=\\x8b\\xfdI\\x987]\\xdc1\\xa2\"|\\xc6\\x0fO\\xc6\\x9c\\xa8\\xf9\\xd3\\xa3\\x01\\xdb\\x04\\t(+\\xe9\\xd7(s\\xbb\\xaa\\xb7\\xe2\\xba\\xd9\\xf4\\xfd\\xde\\xef\\x0f\\x84\\x85.\\xc01\\x97\\x13rJ\\xa0\\xba\\xa7\\x93&amp;\\x10\\xb8\\xde\\x08\\x1a\\x1f\\xb3I\\x8e\\x82\\r\\xb2\\xda]\\x1b;p\\x16\\xc7&gt;\\x86\\xb3\\x81\\xd2\\xf8\\x04\\xff\\x15S\\xf2\\xbe\\xcd\\x98\\xaaW\\xfd\\xe8\\x88\\xd9h\\x11\\x99\\x1bo\\xcaB\\x95\\x95\\xccA\\xefmx\\x9c\\xcf\\xe3f\\xd2\\xd9\\xf9\\xe71\\xefZ-d\\x8e\\x84\\xbf,\\xd6\\x06S\\x0b\\xafiyWX\\x8f\\x91,\":\\xc5\\xae\\xea\\x8f\\xd1\\x0b\\x93\\x13\\x02\\xe7&gt;\\xb2\\x16\\xf0\\x80\\xe4\\xb5j\\n\\xd3S_C\\xd7C\\x8c#\\xde\\xd1W\\x8b\\xfet\\n\\xaf\\rf" }, { "title": "bi0sCTF writeup", "url": "/posts/bi0sCTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, writeup", "date": "2023-01-26 00:00:00 +0900", "snippet": "初めにそういえば今年入ってから書いて無かったなぁとか思ったので今更ですが書きます。といってもそんな書くことないんですがね…てか、HNPが32 solveってみんな賢すぎでしょ…正直レベル上がりすぎて怖いです…[crypto] leaky-dsa [32 solve]challfrom Crypto.Util.number import *from secret import flagfrom hashlib import sha256p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffa = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffcb = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bE = EllipticCurve(GF(p), [a,b])G = E.gens()[0]q = G.order()priv = Integer(bytes_to_long(flag))def sign(msg, d): k = int.from_bytes(sha256(int(d).to_bytes(d.nbits()//8 + 1, 'big') + sha256(msg).digest()).digest(), 'big') z = int.from_bytes(sha256(msg).digest(),'big') r = int((k * G)[0]) % q s = (inverse_mod(k, q) * (z + d * r)) % q leak_k = (k &gt;&gt; 120) &lt;&lt; 120 return z, r, s, leak_kfor i in range(2): msg = input(\"Enter message: \").encode() print(sign(msg, priv))solveなんか、$k$の上位120bitがリークされているので実質の$k$のビットサイズは136bit程度、HNPのLLLでなんとかなりそうfrom pwn import *from Crypto.Util.number import *from random import randintfrom sage.modules.free_module_integer import IntegerLatticep = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffa = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffcb = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bE = EllipticCurve(GF(p), [a,b])# 256bitq = E.order()ret = []N =1for _ in range(N): io = remote(\"crypto.chall.bi0s.in\" ,10000) io.sendlineafter(b\": \",str(randint(0,100)).encode()) ret.append(eval(io.recvline(None).decode())) io.sendlineafter(b\": \",str(randint(0,100)).encode()) ret.append(eval(io.recvline(None).decode())) io.close()Z = [ret[i][0] for i in range(len(ret))]R = [ret[i][1] for i in range(len(ret))]S = [ret[i][2] for i in range(len(ret))]T = [ret[i][3] for i in range(len(ret))]N = len(Z)mat = matrix(QQ,N+2,N+2)for i in range(N): mat[i,i] = -q mat[-2,i] = (pow(S[i],-1,q) * (Z[i] - T[i]*S[i]))%q mat[-1,i] = (pow(S[i],-1,q) * R[i])%qmat[-2,-2] = 2^136mat[-1,-1] = 2^136/qfor row in mat.LLL(): if abs(row[-2]) == 2^136: d = abs(row[-1]) * q/2^136 print(long_to_bytes(int(d))) exit() # 3CC_S1gn1nG_1s_SECCY_6675636b# bi0sctf{3CC_S1gn1nG_1s_SECCY_6675636b}[crypto] bad2code [24 solve]challfrom Crypto.Util.number import *from secrets import FLAGassert len(FLAG) == 44FLAG_FORMAT = \"bi0s\"NBITS = len(FLAG)&lt;&lt;2a = 0xBAD2C0DEc = 0x6969m = 1&lt;&lt;NBITSseed = getRandomNBitInteger(NBITS)state = seedciphertext = []for i,f in enumerate(FLAG): state = (state*a+c)%m ciphertext.append((state&gt;&gt;(NBITS&gt;&gt;1))^^i^^ord(f))public = [1]for i in range(2, 91): public.append(public[-1]*i)q = sum(public)while True: r = getRandomInteger(100) if GCD(r, q) == 1: breakB = [r*i % q for i in public]def encrypt(ct): blen = ct.bit_length() ct = bin(ct)[2:] ct = [int(i) for i in ct] ct = [ct[i]*B[i] for i in range(len(ct))] return blen, sum(ct)ct = []for i in ciphertext: ct.append(encrypt(i))with open(\"ct.txt\", \"w\") as f: f.write(str(ct))print(r)# r = 439336960671443073145803863477solveファイルの変更で$r$の値が分かるようになってたみたい…??(未確認)まぁ、気を取り直して問題は、truncated LCG → xor → bitにして積の計算を行っている感じなので、順に後ろからやっていく bitにして積の計算は$B$がわかるのでLLLでsubset sum problemで解決 truncated LCGからパラメータの復元HITCON CTF 2022 writeup で書いてある感じで$ciphertext$の復元を行う。truncated LCGはkurenaifさんが詳しく解説されているようにすればokkurenaif@2/12まで活動お休み中 on Twitter: “【17兆通り】4bitの値20個からJavaの乱数予測をする【kurenaif】 https://t.co/JLONaT2ydz @YouTubeより 格子基底簡約というテクニックを使って、4bitの値から乱数予測をする動画です！Javaや格子基底簡約を知らなくても楽しめるように動画を作ったので、よかったらみてみてください！ https://t.co/PrDitaanHU” / Twitterあとは平文範囲を1文字づつ探索してGG!!from Crypto.Util.number import *from tqdm import tqdm# assert len(FLAG) == 44FLAG_FORMAT = \"bi0s\"# NBITS = len(FLAG)&lt;&lt;2# 11 bitsNBITS = 44 &lt;&lt;2A = 0xBAD2C0DEC = 0x6969m = 1&lt;&lt;NBITScts = [(85, 2009755672435753240933297922620729942110285100089234834611189610638944428122270966606450209287004686147490741726074233399923807772025455384), (87, 4996607263053501712119670315411210635641476911112656716346186101581162098939506206462698692878856867719374177604968008598982986859155008123), (87, 4837953870616520482139098354277306810171956043791834010204071803405678054968703256907153189059041329376000508442178425613919361101370091597), (87, 2933251583165904105425041103443198171501175581919361545836839336222902826332690613281372817019459906816365925875888304559050438360535693754), (87, 3687643521316276110350069295074808763624177150637370283489602776297956670406673088896906135313859622547057266461156951352840606158133939326), (85, 1338269001646504891852362627714857562957599731250242281507737655117481275381522940187354460968741738873145343823622277547003496172474140929), (88, 7933296831307546148859657742504382496951023270916400508699917815337497611045057441275885597739792345698682705664067022591023419704320903682), (88, 5551940689407978486506000896917506389553250109195458521661213619690861850998613004330276887098156130761269810440548744569924180624922795113), (84, 4231118499738387243085586897653540321361890016337481573279774741827125072054069869204040621495890626440611926639348835434382399384680055422), (85, 4704615409370307656606356674605132679559694819773906599372238093928995241862651680281288235856744305731307534075261385839804274777809615349), (88, 8080256207998531514821351856269697662773084407605094205301308544428843939544685672982309353297946702140050231399104513874885470725033197665), (88, 5409126049900711181553897969759692389994841569000620092514718715454021797905578507700126871105210241868943216288008246115824215988452628610), (87, 9252119153621946581189075112355267174890952393437560488066048810424246555795717704306898381332924931192879341998003358581626937969846419514), (88, 4309485343027874993328683769447337855319861832898927390313412221773647599911173732334028315977555272520439642698050646195173212678056296824), (87, 7585821393024154059281324167310518147335428246416250953866063679865301977430635054486170591035445789330984486529581273451159109931487791502), (87, 4266559781861060657731014334455291598689251074723949797856286897802219958857948301662899795696748957745131495362941575798432727634477829169), (85, 2641970821454174926450206596995181582610648509828849026215891906920020076919398240347027542452996819530972432115175678566086129470049375389), (86, 3077438307667140950446795937461054813957511252383671895612002141778156796698300700433893422617209993376314581927862590976739430303756825799), (84, 6606999799754153651147831000154190219518207430742825676139927743071667153908159445512098245423654757585044526053832363134210629951000894424), (88, 5670578370066772514741437284311647297873639929831922637574590430528630079731096253156055423807240883352926044290617794045498770071653673648), (87, 6894132144232319468740512750496837680809983881874187255032194645685827169634783788480774942267705885439820208999500465383743432841886297780), (88, 6348559834296411797469331328911826454137045759724408730535584371919321718963812479226912064993936288733920150791627489465935504738729746712), (87, 7457067309408071136462520290099813600595760616382451252266638576757556195357758384430233685566475045370258747830063483558129016033041534121), (87, 7138834056650788599340304091245357448689914704543367476875970477848587821892811763578094466693024724929034161719556439516286550418480386826), (85, 4214620981374285095640824086913124961419729602098347661701803957979165936606167686524401563099707189265200486482516005732059773306234258420), (87, 7739066385937951930229094506964291860284170243142110190122036300802992602806430896564185899709833543891933679072444463084661529668059219104), (86, 7996763147644153267931052506581385268378745125996592054161290689392831593366496210631236238142447646254463386914159791951904746842709666621), (83, 2363927368088545362888027832425184786062409622322321649991521010872009124933023792724085312213031828468440431258319304817389205319949123017), (86, 8952178949693065428977346330331508030115172989418887909205463101008773555390353195154597245789628940426095401145185560848927781578325104633), (87, 5437733249052136209105079687557091961563919494484950700755430118355692330802405578709308644911805929080699188377572804834481019970451287210), (88, 6015299972513982077146707497576267202666793107003902152334693697774096888512046451228148219477544391600946101222260160929679756603685952858), (88, 4568852671731251436040898868989551602956632306950375030804513367391992286782270552341135397170272362552944089560054885656717064705695931608), (88, 5214418374014497232007521802148945843762329611158152570151078790657020448385624421117820553224634987052518291618670107521494031262847423514), (85, 4868781049816097655711690233312446779184038900364456479177916582789767967134191139603006712483609665048365174590374678749717762853252392898), (87, 7487878378499555558388350908281092245535427011554302229088273963701472371659945154073798520163320208196872977374676841353329741664704431049), (88, 4804650300297155317595282760599161747288241275410480931480258003053935686370721999717184367371623277273540661128542000775004283694728585525), (87, 6324353155591926121419512579497192374524354396151314193997508188259969434627055717937503525281909856550845807173753553651932260148517039625), (87, 5546469224661430242652418747991106002905180051710879985326544434722895447041925331360634907813012794515907098935485171653197695779005009826), (86, 6493922061250196900387871627336695511599800586007321943800903718034500613505566204881495072235610494479661303981584755703237874004730700241), (84, 3304267236247240014753455621608696126482869339445549240138779235284450054938719633292333925332195771054789798560540593262065547955691287860), (86, 7470707627092056238764393981318045721888042683539521453158125764519328859948265999477619788387120366063077899885955739104933799243393828710), (88, 6674831873895816998217860257081780104168741154329195649911902365299495130324698497916172758145782383658122037059537201009889153133307754158), (88, 5323014117483698150842190422231005724805137799598831691161862346623039247622359972881775361362745899238680458901399065283489317592046388919), (85, 3763698408921732607951773848228884704668238062686979349129116312470621538052054791662510364394420612090312977770614743449723324784458538150)]r = 439336960671443073145803863477public = [1]for i in range(2, 91): public.append(public[-1]*i)q = sum(public)B = [r*i % q for i in public]def encrypt(ct): blen = int(ct).bit_length() ct = bin(ct)[2:] ct = [int(i) for i in ct] ct = [ct[i]*B[i] for i in range(len(ct))] return blen, sum(ct)def recover_ciphertext(c): N = len(B) M = matrix(QQ, N+1,N+2 ) for i in range(N): M[i,i+1] = 1/65537 M[i,0] = -B[i] M[-1,0] = c M[-1,-1] = 2*q for row in M.LLL(): if abs(row[-1]) == 2*q: return list(row*65537)[:-1]state = []for i in range(4): ciphertext = [str(k) for k in recover_ciphertext(cts[i][1])] l = cts[i][0] c = int(\"\".join(ciphertext[:l+1]),2) state.append(int(c)^^int(i)^^int(ord(FLAG_FORMAT[i])))from attacks.lcg.truncated_state_recovery import attackret = attack(state,int(m).bit_length(), int(m).bit_length() - (NBITS &gt;&gt;1),m,A,C)pt = \"b\"assert (ret[2]*A+C)%m ==ret[3]assert (ret[0]*A+C)%m ==ret[1]s = ret[0]for i in range(1,44): for f in range(0,0xff): _s = (s*A+C)%m c = int(_s&gt;&gt;(NBITS&gt;&gt;1))^^int(i)^^int(f) ec = encrypt(c) if ec[1] == cts[i][1]: pt +=chr(f) s = _s break else: print(\"not found\") breakprint(pt)# bi0sctf{lcg_is_good_until_you_break_them_!!}" }, { "title": "2022年の振り返り", "url": "/posts/2022/", "categories": "ctf", "tags": "ctf", "date": "2023-01-05 00:00:00 +0900", "snippet": "初めに2022年も終わり2023年がやってきました。個人的には2022年後半から2023年の前半がここ最近の一番の環境の変化になる気がしてずっとそわそわしてます。本題となるのは2022年の振り返り+2023年の目標ですかね…2022年の振り返り前半は特に何もなく、唯々大学の研究や学会に参加したりをしてる傍らにCTFに適当に参加する的な?感じでした。しかも何も情報もなくCTFTimeみて参加してdiscordの議論を傍らから見てるだけなので、特に書くこともないんですよねぇ…後半、というかSECCON CTF beginners in 札幌に参加してからの環境が変わりすぎですねぇ。参加した後にTwitterでいろんな人をフォローしていくうちにフォロバもらえたので、ここで最初の承認欲求の爆上がり+モチベの爆上がりは天井知らず。。。さらに、適当にTwitterでSekai CTFにチームで出たいなぁ的なことをつぶやいてるとSatoooonさんに拾ってもらえて2人で出たりと、ここが大きな環境の変化でしたね。。。チームで出る喜びを覚えた僕はSECCON CTF 2022 QUALSにチームで出ることになってmisoさんとIwancofさんを追加する形の4人ででて決勝へと進むことができました(個人的にはcryptoが解けなくて結構悔しい…orz)とまぁ、前半には想像もしていなかった感じになりましたね。。。2023年の予定(?)と目標今僕が修士2年ということもあり、2023年は社会人一年目の年になります。ということで2022年とはまた違った形での環境の変化が来るのが確定しているんですよね。。。でも、会社でやる業務はsecurity関係なので比較的ましかなぁと考えています。(多分researcher??わかんない)さて、目標ですが 死なない rustやれたらいいなぁ ZKPをやる(多分zk-SNARKsかな) revを初心者レベルは越えておきたいざっと、こんなもんですかね。死なないはなぜか会う人会う人に「お前死ぬなよ」といわれるので目標に入れてます。(筋トレやろう…)ZKPは今ホットな分野(Asia cryptoでZKPに関するものがほぼほぼだったり)で理論は知っておきたいなという感じです。あとは、自分が興味持っている部分なのでゆるゆるとやっていきたい所存です。締め今はザックリこんな感じでやっていこうかなぁと思っています。途中で脇道それそうな予感も…??とりあえず、今年一年もよろしくお願いします。" }, { "title": "CTF advent calendar 2022", "url": "/posts/adventcalender2022/", "categories": "advent_calendar", "tags": "advent_calendar", "date": "2022-12-11 00:00:00 +0900", "snippet": "初めにCTF Advent Calendar 2022の15日目ということで色々書きます。前回はhamayanさんのCTFにおけるステガノグラフィ入門とまとめ - はまやんはまやんはまやんでした。webわからなさすぎるので、いつもwebのwriteup参考にさせてもらってます。ありがたやー～…はじめましての方は初めまして、そうでない方も初めまして、kanonです。去年の11月(?)から本格的にCTFに参加始めた新人プレイヤーです。(そう考えると1年と少ししかやってない..??)まぁそれはさておき、この記事は新しくCTFを始める人に向けての記事にしようかなと思っています。理由として、僕自身がCTFのコミュニティに参加した(?)のが2か月前なのとそれまでの約一年間は個人でしかもtwitterとかもやらずにCTFtimeだけ見てCTFに参加し経験積んでました。時間だけ見ると結構無駄なことや逆に良かったこともあるので今からCTFやってみようかな!!でもどうしたらいいんだろ…orzって人向けに紹介していこうかなと思っています。ただ、話すものは個人の経験に基づいていますので、間違ってたらすみません…CTF用のTwitterアカウントを作ろうとりあえず、CTFやっている人をババっとフォローしておきます。そうすることで、色々な情報(CTFの開催情報・writeup・良問等々)が手に入ります。これって、凄く重要な情報で自分のスキルアップにもつながりますし、みんなめっちゃスプラやってるやんってなります。それはさておき、チームのお誘いや逆に今度一緒にやりませんかといったチームな話もあるかもしれません。横のつながりはめちゃ大事。CTFに参加するには…?基本的に大体のCTFには参加できます。ただ、決勝戦や特定地域のみといったものには参加することができません。(そりゃそうですよね、W杯の決勝トーナメントに部外者が参加できないのと同じで)基本的にはCTFtimeで纏まって確認することもできますが、たまにローカルなCTF(taskさんのtaskctfやtsukuCTF)や企業さんが開いてくださるものもあります。それらは基本的にTwitterで情報が流れてくるので、参加したいのであればTwitterにアンテナ張る方がいいかなぁなんて思っています。(なんなら僕自身10月までそういうものの存在を知らなかった…)こんな感じで色々なCTFがあり、最初の内はCTFtimeの説明にある難易度にビギナーも大丈夫って書かれているものかローカルで開かれる(初心者でも楽しめるものが多いイメージ)ものを選んだ方がいいです。(大丈夫な人は問題ないですが、難しいのだと普通に心折れます。。。)CTFに参加してみる..!!チームってどうなの??じゃあ、参加しよう!!… あれ、チーム組んで参加するの??参加するにあったってチーム戦で行うCTFか、はたまた個人戦で行うCTFの2つあります。チーム組む人がいればそれに越したことはないですが、組めない場合は一人で参加しても全然問題ないです。最初は順位よりもCTFに慣れようがメインになるので…!!!(プラットフォームとかdiscordの使い方等々)問題にジャンルがあるCTFは基本的にジャンルがあります。(まれに特定ジャンルのみやジャンルが複合している場合も…)以下に簡単に書いてみます。 crypto 昔のものから現在使われているものまで暗号を解読しようぜ web Webのセキュリティを解析しようぜ reversing 実行ファイルを解析しようぜ pwn プログラムのやばい所を探して突こうぜ forensics データから情報を抜き出してみようぜ misc その他諸々なんだぜ とりあえず、挙げてみましたがぶっちゃけ個人の性格と知識と興味でどの分野が得意なのかは異なりますので、一度すべての分野を触って行けそうと思う分野を中心に始めるといいです。(僕は大学院の研究柄cryptoやってます)先の話にはなりますが、その分野がある程度解けるようになると他の分野で使える知識も意外とあったりします。なので、まずは得意な分野をある程度作ってからほかの分野も挑戦するといいのかなぁと思っています。参加したけど解けなった…orz安心してください!!解けなくても解けた人たちがwriteupとして解き方を公開してくれている場合やCTFの運営者たちが想定解を公開してくれる場合があります。それを見て今まで自分が知らなった手法・知識・技術を吸収して自分のものにするのも大きな学びになります。じゃあどこに上がっているのかというと、discordに上がることが大半ですが、googleで「〇〇CTF writeup」とかで検索すると見つかるときもあります。ただ、時と場合によってはwriteupが禁止(期間禁止はたまにある)やwriteupが上がってなかったりする場合もあります。その場合は、あきらめましょう…(discordで聞いてもいいとは思いますが、相手方も善意でやってくれているので返信が返ってくるかは未知数…)そして、時間があればupsolve(解きなおし)するのもいいと思います。(思考のトレースってめちゃ大事)解けた!!ならwriteup書きましょう!!それを世界に公開するかどうかは置いておくとして、自分の思考がwriteup書くことで纏まりますし、文章で思考を説明するいい機会にもなります。(僕みたいに下手にはならないでね。約束だよ)結局チームは組むべき…??1人で参加するメリット・デメリットメリットはめっちゃ気楽。デメリットは1人ですべて行うので負担が半端ないし、寂しい。チームで参加するメリット・デメリットメリットは単純で、人数が増えて負担が減る。ワイワイできる。デメリットは貢献しないとというプレッシャーがある。個人的な意見大学の研究室の人たちや、先輩・友達にCTFに興味持ちそうな人がいれば声をかけて一緒にやるってのはいいと思いますし、大学のサークルでCTFをやってるような所もあったりします。そういう所に話を聞きに行ってみるのもありなのかもしれません。そういう場合を除くと、初めは1人の方がいいのかなぁと思っています。強い人と出ると最初は貢献できなくて楽しむことより申し訳なさが勝手しましますし、初心者同士でチームで出ても、同じ問題を複数人で解く場合を除いてソロと変わらないのではと思ってしまします。同じ問題を複数人で解く場合は、それを続けると問題の取り合いになってしまうことが多いのかなぁって勝手に思ってます。(経験なし)なので、自分が初心者卒業したなぁ…!!と思ったらチームを組むのがいいと思います。しかも、自分の苦手な分野が得意な人と組むと得意な部分に集中できてかつ、苦手の部分でも得点してくれるというまさに一石二鳥になります。どうやってみつけるの…野良CTFerの人がいるのか問題で…自分が初心者卒業したなぁ…と思う頃にはTwitterにCTF興味あるよって人たちと相互フォローになっているはずです。(ちゃんと動かしていれば)同じ実力そうな人に一緒に出ませんかってメッセージを送ってみるのがいいのかと思います。(諸説あり)じゃあ、強くなるには…?とりあえず、CTFに出て出て、出てください。出て問題を死ぬほど解いて、知らないことを知って理解を深めてください。ここまでくれば…もう後は、上を目指して精進するのみです…!!!! お互い頑張りましょう最後に僕はいつでも誰でもウェルカムですのでお気軽にお誘いください…!!ソロ過ぎてソロの感覚が染みついてますが…ｵｰﾏｲｶﾞｰ…次回はLaikaさんがなにか書いてくれるみたいです。ありがとうございました。" }, { "title": "shakti CTF 2022 writeup", "url": "/posts/shakti-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-12-11 00:00:00 +0900", "snippet": "初めにsolveが少ないものを…CRTの使い方が面白かったので後で自分なりにいじってみます。[crypto] d0uble_cbc [16 solve]challfrom Crypto.Cipher import AES from Crypto.Util.Padding import pad,unpad from Crypto.Util.strxor import strxorfrom secret import key,flag ,ivfrom os import * def encryptt(pt): return (AES.new(key,AES.MODE_CBC,iv)).encrypt(pad(pt,16)) def decryptt(ct): if len(ct)%16 == 0: return (AES.new(key,AES.MODE_CBC,iv)).decrypt(ct) elif len(ct)%16 != 0: return (unpad((AES.new(key,AES.MODE_CBC,iv)).decrypt(ct) , 16)) def verify_ivv(iv,iv_detected): if iv.hex() == iv_detected: print(\"Yooo... you are going good, move forward with some more courage\") return True else: print(\"Don't lose hope buddy , you can get through this, try again \") return Falsedef sign(iv,key,message): try: cbc = AES.new(key, AES.MODE_CBC,iv) messageblocks = [message[i:i + 16] for i in range(0, len(message), 16)] tag = cbc.encrypt(messageblocks[0]) for i in range(1,len(messageblocks)): cbc1 = AES.new(key, AES.MODE_CBC,tag) tag = cbc1.encrypt(messageblocks[i]) return tag.hex() except: print(\"\\nNo padding done here !, try again \") exit() def main(): print(\"******************************Welcome to the john's CBC server************************\") print(\"You really wanna get into the system? \\n then search for IV \") print(\"Choose 1 option among four \\n \\t 1.Encrypt the plain text \\n \\t 2.Decrypt the ciphertext \\n \\t 3.feed IV \\n \\t 4.exit\") op = int(input()) if op == 1: print(\"I will provide the encrypted text for you\") print(\"Input the plaintext in hex format\\n\") pt = input() ct = encryptt(bytes.fromhex(pt)).hex() print(f\"cipher text for provided\" , ct); if op == 2: print(\"I will provide the reasonable plaintext for you\") print(\"Input the cipher text in bytes to decrypt\") ct = input() pt = decryptt(bytes.fromhex(ct)).hex() print(f\"decrypted text for provided\" , pt); if op == 3: print(\"Provide reasonable IV to proceed further\") iv_detected = input() verify_iv = verify_ivv(iv,iv_detected) print(verify_iv) if verify_iv: print(\"Let me see whether you are worth enough to gain my gold coins.\") print(\"To prove yourself, give me two different hex-encoded messages that could sign to the same tag.\") print(\"Now press '0' to get your hex inputs signed and press 1 to submit two same messages\") iv_detected = bytes.fromhex(iv_detected) x = input() if x == '0': print(\"Input hash encoded message:\\n\") msg = bytes.fromhex(input()) x = sign(iv_detected,key,msg) print(\"\\n Tag for your message\") print(x) if x == '1': msg1 = bytes.fromhex(input(\"\\nMessage #1: \\n\")) msg2 = bytes.fromhex(input(\"\\nMessage #2: \\n\")) if(msg1 == msg2): print(\"\\nThis is not a correct way to do this, think again!!!\") exit() if(msg1 != msg2 and sign(iv_detected,key,msg1)==sign(iv_detected,key,msg2)): print(flag) exit() else: print(\"\\nOops! They don't match!...Better luck next time!\") exit() if op==4: exit() if __name__ == '__main__': main()solve$m = m_1+m_2$とし、$c_1 = enc(m_1 \\oplus iv),c_2 = enc(m_2 \\oplus c_1)$としておきます。ここでの$+$は文字列の結合です。更に$m’_2 = dec(c_2)\\oplus iv,m’_1 = dec(c_1) \\oplus c_2$ともしておきます。part1目標 : ivの導出それぞれ既知の変数は$m_1,m_2,c_1,c_2,m’_1,m’_2$の6つ。$c_1 = enc(m_1 \\oplus iv),m’_1 = dec(c_1) \\oplus c_2$を纏めて$dec(c1) = m_1 \\oplus iv=m’_1\\oplus m’_2$より$iv = m_1 \\oplus m’_1\\oplus c_2$で求まるfrom attacks.cbc.padding_oracle import attackfrom pwn import *def bxor(a,b): return bytes([ a_^b_ for a_,b_ in zip(a,b)])BLOCK_SIZE = 16m1 = b\"1\"*16m2 = b\"2\"*16print((m1+m2).hex())# 3131313131313131313131313131313132323232323232323232323232323232enc = bytes.fromhex(\"1ff6715f925f8101e755d865142ca76964a478eee818f9153509586f9a05133d8831c0ab6a1dc68a83cdc8754b360909\")c1 = enc[:BLOCK_SIZE]c2 = enc[BLOCK_SIZE:BLOCK_SIZE*2]print(\"ct\",(c2+c1+enc[BLOCK_SIZE*2:]).hex())plain = bytes.fromhex(\"6c9b2b0cd01dca6cb60589084b71f13e14ca21bea959b17b675a0a01c65b46696b4219a16a576804c24c901a9e39a444\")m1_prime = plain[BLOCK_SIZE:]iv_cal = bxor(bxor(c2,m1_prime),m1)print(iv_cal)iv = b\"A_happy_cbc_mode\"print(iv.hex())part 2目標 : $enc(m_1)とenc(m_2)の最終ブロックが同じ \\ and\\ m_1 \\neq m_2$暗号部分は、なぜか分けているけどAES-CBCと同じ動作するので、細かいことは気にしない。ということで、$m’ = m_2$と$m’’ = m_1+m_2$を用意するが、$iv\\neq enc(m_1\\oplus iv)$ではないため動かない。先ほどより$c_1$が既知なことを利用してとして$m’ = m_2\\oplus c_1 \\oplus iv$と$m’’ = m_1+m_2$とすれば求まる。enc123 = (m1+m2).hex()enc23 = (bxor(bxor(c1,iv),m2)).hex()print(enc123)print(enc23)# shaktictf{double_cheese_double_mac_yummyyyy_4120686170707920636263206d6f6465}[crypto] r3deem_r4Nd0m　[6 solve]challfrom hashlib import sha256from Crypto.Util.number import *from secret import p,q,r,flag# p,q,r = getPrime(256),getPrime(256),getPrime(256)n = p*q*re = 65537phi = (p-1)*(q-1)*(r-1)d = inverse(e,phi)ct = pow(bytes_to_long(flag),e,n)h =int(sha256(flag).hexdigest(),16)dp = d%(p-1)dq = d%(q-1)dr = d%(r-1)sp = pow(h,dp,p)sq = pow(h,dq,q)sr = pow(h,dr,r)s = (((sp*q*r*(inverse(q*r,p)))%n) + (sq*p*r*(inverse(p*r,q)) %(n)) + ((sr*p*q*(inverse((p*q),r)))%n))%n from r3d33m_r4Nd0m import sp,sq,sr,h,e,n,ctfrom Crypto.Util.number import * from secret import flag,p,q,rdef crt(sp1,sq1,sr1,p,q,r): s1 = (sp1*q*r*(inverse((q*r),p)))%n s2 = (sq1*p*r*(inverse((p*r),q)))%n s3 = (sr1*p*q*(inverse((p*q),r)))%n s = (s1+s2+s3)%n return s1,s2,s3,s def server(): print(f\"Welcome to this small crt game\\nI am a poor kid, I am here to do a small job which can help me to coverup my small expenses.\\nSo, My job is to do some simple calulations for inputs provided.\\n\\nAs part of game rules, intially I will give you some parameters, using that parameters and this server try to get me the flag , then you can get the treasure\\nParameters provided\\nn = {n}\\ne = {e}\\nh = {h}\\nct = {ct}\\nPlease try to give valid input, if I am unable do good calulations, my boss will fire me :( \\nYou have two options:\\n\\n1. Input '1' to get sp,sq,sr values and it's computation values from our server\\n2. Input '2' to input your own sp,sq,sr and get corresponding computatuion values\" ) x = input() if x == '1': print(f\"sp = {sp}\\nsq = {sq}\\nsr = {sr}\") s1,s2,s3,s = crt(sp,sq,sr,p,q,r) print(f\"s1 = {s1}\\ns2 = {s2}\\ns3 = {s3}\\ns = {s}\") if x == '2': print(\"Get customized s1,s2,s3 and s values.\") print(\"Input sp,sq,sr values\") sp_u = int(input(\"\\nInput your sp value: \")) sq_u = int(input(\"\\nInput your sq value: \")) sr_u = int(input(\"\\nInput your sr value: \")) s1_u,s2_u,s3_u,s_u = crt(sp_u,sq_u,sr_u,p,q,r) print(f\"s1 = {s1_u}\\ns2 = {s2_u}\\ns3 = {s3_u}\\ns = {s_u}\")if __name__ == '__main__': server() solveRSAで暗号され、その素数でCRTを行うものが渡される。とりあえず、素数$p,q,r$がわからないと始まらないので、CRTをうまく用いて割り出していく。$s_1 = q*r * (q*r \\mod p) -k*n=q*r * ((q*r \\mod p) -k*p) $より$q*r=GCD(s_1,n)$から$p$がわかる。これを同様にすれば他の値もすぐに求まる。from Crypto.Util.number import *n = 671193456450696209294538401092132200835318782822322315634822979842491480350953125013703551172675245349609262913412939263137349891298234146269765976476713743829345089919755818249576374672896649899144345865055014963972247204207494479e = 65537ct = 562424961019202732191255280916393150126209218444188556517270687960305550759526781461098153889147500792001380371454899207533680446302990359819605368684890785759571941069404593981778618037030554910233447127875225743078821221483182353s1 = 299975575615366431743442900345501820171302184916013790549258989583702124067113757045635815940516169014707886648203282728770493017593176259766163134766679080376970009232489603551294208308458498129957898345431067389579567886412734956s2 = 634658493680316046522130611451479798630743814754138967420984564261348394927938620704099453345768485030779025330014580509993617335353452850125123544790400738121047937373231722413387921371961136162073670869158916961134003314014005256s3 = 470074781431408813402769135661849283210474606932730644990171152572265111532273848127919937536197133365570762332224403240917868298063908774205995365446224500933717346898118648118764091769080701066160085582010046429901107442705628137s = 62321937825698873079265845274566500341883040958238771690768746732332669825419975850248104477131296711839148483616387953407278868414069591557750092049876831773045113664328337584293472103707035559902963066490000852670184234717379391p = n//GCD(s1,n)q = n//GCD(s2,n)r = n//GCD(s3,n)assert n == p*q*rd = pow(e,-1,(p-1)*(q-1)*(r-1))print(long_to_bytes(int(pow(ct,d,n))))" }, { "title": "HITCON CTF 2022 writeup", "url": "/posts/HITCON-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-11-30 12:00:00 +0900", "snippet": "初めにHITCONでボコられたのでメモ書きbabyssschallfrom random import SystemRandomfrom Crypto.Cipher import AESfrom hashlib import sha256from secret import flagrand = SystemRandom()def polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])DEGREE = 128SHARES_FOR_YOU = 8 # I am really stingy :)poly = [rand.getrandbits(64) for _ in range(DEGREE + 1)]shares = []for _ in range(SHARES_FOR_YOU): x = rand.getrandbits(16) y = polyeval(poly, x) shares.append((x, y))print(shares)secret = polyeval(poly, 0x48763)key = sha256(str(secret).encode()).digest()[:16]cipher = AES.new(key, AES.MODE_CTR)print(cipher.encrypt(flag))print(cipher.nonce)solveShamir’s Secret Sharingがモチーフの問題今回における脆弱性は、「$\\mod p$での演算でない 」・「$x$座標の桁が大きい」の二点 $\\mod p$での演算でない　⇒　$y = \\sum a_ix_i$ より整数環上の多項式ととえられる $x$座標の桁が大きい　⇒　$a_0 \\equiv \\sum a_i*x_i \\mod x$であるため$a_0$のビットが$x$のビット程度持つ結果として1つ目でGCDやLCMといった整数での話が成り立つ。そして、2つ目で$x$のビット程度持つので組み合わせてCRT１で復元できるまた、格子でのHNPみたく考えられる。solve1lists = [(41458, 3015894889650529600470920314593280408459518223054415623846810748413393737686521849609926975694824777687791824408686652245102687392987299828716863372946074882798754477101786150262288970710451710086966378817944448615584285684364802621112755627795146504720812935041851556318832824799502759754100408717888912062197676588256634343721633045179136302533777168978134770315363985448879229514802330846792965525004570768212871252658334277172395338054448791891165981203069346039654617938169527772805687564575525262812469960675835101499054296722994451502140787064163668418661661374437567033971648550576296023422536253955229), (3389, 188433716494377932944071544153838579057591833387651830021721770473524507947811754295899393634645349682360212761145039355690817927625249659010181081209481357850193656763556243022791637306094953982811471415645267589939465925098159204147714779617946431727015863707468081949286110249296858079354949234074465541940264775783884708819566758872542606519408358277173683256608326688673226933790117016596834640875497643330432185114931410656582728964222203181026468387428893233826461), (20016, 100434774699078525844435127144579870564983915777345068724291926367405061427748836490810414860997895358378538088786283372231649911113841061354335739776409724471256377867811133591349442950556374825868587940833009529662869081130218551306459690738900795035660420986807973542512081415453215211908130387754214098414826747340962722685373241806099462750595976574593799013733614097923338311883793416643213898201680852118540438376386415411317989072583126108177482838299109479175882214603698768498421016054035672774286507312986602290254323930575001551875601243671354491241420409219), (50683, 444545881882748849210617532697661279371689521082184772844723908765173319859389018743414369945234307906596253496624659734919646710483514374218993496994560985318096082923429834553341897367168830049334302307406087637232329348570485341223211629167329394484624055745054495405880099706580380696671879365741197827080224977821589102425678989782880274304484630899425664722718972847034030888019348402685383311095030884356731112886316823960378572796288532824588478234949384868912708000223119984161992105752059185137674711077940232530298853451166664700609238496874366152042676602089571801873748042888046623717879084695143810047335029), (6445, 101461065764578261241074518788237888467081270902741849861528201922043223477790661159690684156056890167304291810116447916457265705130707166062372766839626095333813681671546097679623755546322833727082145873422243641505450049118758544298328784536759107951763715458884889255549767465897671061295486677353893450789955616926292534325337544782386120469581214993770910137353221116457111551538222138388416162630076391624447865248920466274175229034129561913505977209131490066291917549232913771218316393849495621818397), (1359, 301175604076484656987097022479686300460199620068959954988990822483114048418823291831080744590394713639405681060973359346474547015206086229256524657214311815578895906855833813636970640902962286472992468394831014254279137613828904924898823470285520515090889491445149243620044782726415898188702226878029241518020146726699446397961112596830223444821094650508662477147134721631935528182772284099429814417490160457082241680661), (45286, 244867719210730952183489456726726432791149629831242968845409984537752132549250274779516590253042559196452609852176114909791657154092483479876795482861784431886143414585698773882088948703730268947925790809436449512089696895048994874003651088538416399435467483409931121063976149037130454114161175715871108284419975118570732022104749321213013756795645219060997019373915339235627535694458093194617642834806820772479160496966470147893963746139947337914575231526069667124822677688977724313174612816604463495630041075005651663546036363128325535621487658461744362098985183050127661470315454320073092665472364666768205258769), (5649, 4766101906865350375503575239791521167258753430948472304582908507542293595346756303331383584550516424087839316050412570112796817549423179461056531056102741963677007097061600281918678364910813585444151640384802648969082273001142879806475184857246441212406056540028447374033197873299250076862108042582790928405869475508762352345569281589853917902601519294573327847401601789315980414998055948162169170771240383220643819333682845459742335249254576151835966500230706707674854493184181354958093926469960861)]enc = b'G$\\xf5\\x9e\\xa9\\xb1e\\xb5\\x86w\\xdfz\\xbeP\\xecJ\\xb8wT&lt;&lt;\\x84\\xc5v\\xb4\\x02Z\\xa4\\xed\\x8fB\\x00[\\xc0\\x02\\xf9\\xc0x\\x16\\xf9\\xa4\\x02\\xb8\\xbb'nonce = b'\\x8f\\xa5z\\xb4mZ\\x97\\xe9'from sage.all import *from Crypto.Cipher import AESfrom hashlib import sha256def polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])x = []y = []a = []for xi, yi in lists: x.append(xi) y.append(yi)for i in range(129): ai_dist = [] for xi, yi in zip(x,y): ai_dist.append(yi%xi) a.append(CRT(ai_dist,x)) for k in range(len(x)): y[k] = (y[k] - a[i])//x[k]secret = polyeval(a, 0x48763)key = sha256(str(secret).encode()).digest()[:16]cipher = AES.new(key, AES.MODE_CTR,nonce=nonce)print(cipher.decrypt(enc))b'hitcon{doing_SSS_in_integers_is_not_good_:(}'solve2線形和とみなして格子解に持ち込むともできる、、、コメントアウトがミスしていたところで、、、いや、ね？？？LLLで小数使えるの完全に抜けてましたよくよく考えれば、$2^{64}$でスケーリングすると格子の解で$0$が並ぶわけないやないかと…なんなら、同じことをsecretで考えてやってるし…from random import SystemRandomfrom Crypto.Cipher import AESfrom hashlib import sha256def polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])shares = [(41458, 3015894889650529600470920314593280408459518223054415623846810748413393737686521849609926975694824777687791824408686652245102687392987299828716863372946074882798754477101786150262288970710451710086966378817944448615584285684364802621112755627795146504720812935041851556318832824799502759754100408717888912062197676588256634343721633045179136302533777168978134770315363985448879229514802330846792965525004570768212871252658334277172395338054448791891165981203069346039654617938169527772805687564575525262812469960675835101499054296722994451502140787064163668418661661374437567033971648550576296023422536253955229), (3389, 188433716494377932944071544153838579057591833387651830021721770473524507947811754295899393634645349682360212761145039355690817927625249659010181081209481357850193656763556243022791637306094953982811471415645267589939465925098159204147714779617946431727015863707468081949286110249296858079354949234074465541940264775783884708819566758872542606519408358277173683256608326688673226933790117016596834640875497643330432185114931410656582728964222203181026468387428893233826461), (20016, 100434774699078525844435127144579870564983915777345068724291926367405061427748836490810414860997895358378538088786283372231649911113841061354335739776409724471256377867811133591349442950556374825868587940833009529662869081130218551306459690738900795035660420986807973542512081415453215211908130387754214098414826747340962722685373241806099462750595976574593799013733614097923338311883793416643213898201680852118540438376386415411317989072583126108177482838299109479175882214603698768498421016054035672774286507312986602290254323930575001551875601243671354491241420409219), (50683, 444545881882748849210617532697661279371689521082184772844723908765173319859389018743414369945234307906596253496624659734919646710483514374218993496994560985318096082923429834553341897367168830049334302307406087637232329348570485341223211629167329394484624055745054495405880099706580380696671879365741197827080224977821589102425678989782880274304484630899425664722718972847034030888019348402685383311095030884356731112886316823960378572796288532824588478234949384868912708000223119984161992105752059185137674711077940232530298853451166664700609238496874366152042676602089571801873748042888046623717879084695143810047335029), (6445, 101461065764578261241074518788237888467081270902741849861528201922043223477790661159690684156056890167304291810116447916457265705130707166062372766839626095333813681671546097679623755546322833727082145873422243641505450049118758544298328784536759107951763715458884889255549767465897671061295486677353893450789955616926292534325337544782386120469581214993770910137353221116457111551538222138388416162630076391624447865248920466274175229034129561913505977209131490066291917549232913771218316393849495621818397), (1359, 301175604076484656987097022479686300460199620068959954988990822483114048418823291831080744590394713639405681060973359346474547015206086229256524657214311815578895906855833813636970640902962286472992468394831014254279137613828904924898823470285520515090889491445149243620044782726415898188702226878029241518020146726699446397961112596830223444821094650508662477147134721631935528182772284099429814417490160457082241680661), (45286, 244867719210730952183489456726726432791149629831242968845409984537752132549250274779516590253042559196452609852176114909791657154092483479876795482861784431886143414585698773882088948703730268947925790809436449512089696895048994874003651088538416399435467483409931121063976149037130454114161175715871108284419975118570732022104749321213013756795645219060997019373915339235627535694458093194617642834806820772479160496966470147893963746139947337914575231526069667124822677688977724313174612816604463495630041075005651663546036363128325535621487658461744362098985183050127661470315454320073092665472364666768205258769), (5649, 4766101906865350375503575239791521167258753430948472304582908507542293595346756303331383584550516424087839316050412570112796817549423179461056531056102741963677007097061600281918678364910813585444151640384802648969082273001142879806475184857246441212406056540028447374033197873299250076862108042582790928405869475508762352345569281589853917902601519294573327847401601789315980414998055948162169170771240383220643819333682845459742335249254576151835966500230706707674854493184181354958093926469960861)]enc = b'G$\\xf5\\x9e\\xa9\\xb1e\\xb5\\x86w\\xdfz\\xbeP\\xecJ\\xb8wT&lt;&lt;\\x84\\xc5v\\xb4\\x02Z\\xa4\\xed\\x8fB\\x00[\\xc0\\x02\\xf9\\xc0x\\x16\\xf9\\xa4\\x02\\xb8\\xbb'nonce = b'\\x8f\\xa5z\\xb4mZ\\x97\\xe9'DEGREE = 128SHARES_FOR_YOU = 8 # I am really stingy :)N = DEGREE+1m = matrix(QQ, N+1 ,N+1+SHARES_FOR_YOU)for i in range(SHARES_FOR_YOU): for k in range(N): m[k,i] = pow(shares[i][0],k)B = 2^64for i in range(N): # m[i,i+SHARES_FOR_YOU] = 2^64 m[i,i+SHARES_FOR_YOU] = 1/Bfor i in range(SHARES_FOR_YOU): m[-1,i] = -1*shares[i][1]# m[-1,-1] = 2^2048m[-1,-1] = 1M = m.LLL()for row in (M*B): if abs(row[-1]) != B: continue # secret = polyeval([r//2^64 for r in row], 0x48763) secret = polyeval([int(r) for r in row[8:-1]], 0x48763) key = sha256(str(secret).encode()).digest()[:16] cipher = AES.new(key, AES.MODE_CTR,nonce=nonce) # if b\"HIT\" in cipher.decrypt(enc): print(cipher.decrypt(enc)) exit()print(\"[-] not find\")secretchallimport random, osfrom Crypto.Util.number import getPrime, bytes_to_longp = getPrime(1024)q = getPrime(1024)n = p * qflag = open('flag','rb').read()pad_length = 256 - len(flag)m = bytes_to_long(os.urandom(pad_length) + flag)assert(m &lt; n)es = [random.randint(1, 2**512) for _ in range(64)]cs = [pow(m, p + e, n) for e in es]print(es)print(cs)solve1$c_i \\equiv m_i^{(p + e_i)} \\mod n$より$\\sum (p + e_i)*{a_i}=0$となる$a_i$をいくつか探す。もし、これらが見つかるなら$\\prod m_i^{(p + e_i)*{a_i}} \\mod n \\equiv \\prod c_i^{a_i} = 1 $となる。さらに通常であれば$n$がわかっていないので剰余を取ることができないが右辺を単元としているため$a_i$が負の値になるのであれば右辺に移項させることができる。よって、LLLを使って条件を満たすような項を求めていく。$\\sum (p + e_i)*{a_i} = \\sum e_i * a_i + p*\\sum 1* a_i =0$より1列目は$e_i$の項を、2列目には$1$を配置する。残りは単位行列にしてどの項が何回使われたのかの確認の項($a_i$)となる。\\[\\left[\\begin{array}{ccccc}e_0 &amp; 1 &amp; 1 &amp; \\cdots&amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots&amp;\\ddots&amp; 0 \\\\ e_n &amp; 1 &amp; 0 &amp; \\cdots &amp; 1 \\end{array}\\right]\\]がこれで求めると想定していた初手2項答えが$0$とはならず以下みたいになる。(115, -47, 90, 120, -30, 4, 88, 13, -86, 18, -20, -149, -4, 212, -85, 106, -20, -94, 5, 32, 26, 114, 48, -15, -51, -252, 2, 113, -19, -26, 75, -118, 48, -15, -112, 187, -96, -89, -12, -46, 198, -101, -5, -31, -164, 97, -145, -127, 59, 33, 125, -26, -84, -252, 35, 43, 192, -24, 129, -179, 29, -9, 140, 11, 51, -4)$a_i$の項の大きさが$0$よりも大きいため引っ張られて$0$が出なくなる。よって、$a_i$の項を小さくしてやると\\[\\left[\\begin{array}{ccccc}e_0 &amp; 1 &amp; 1/65537 &amp; \\cdots&amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots&amp;\\ddots&amp; 0 \\\\ e_n &amp; 1 &amp; 0 &amp; \\cdots &amp; 1/65537 \\end{array}\\right]\\](0, 0, -202/65537, -8/65537, 28/65537, 227/65537, 253/65537, 61/65537, -3/65537, -128/65537, -2/65537, -83/65537, 31/65537, -85/65537, -51/65537, 85/65537, -123/65537, 2/65537, 191/65537, 62/65537, 23/65537, 227/65537, -151/65537, -8/65537, -108/65537, 257/65537, -16/65537, -67/65537, -221/65537, 120/65537, -85/65537, -79/65537, -67/65537, 19/65537, -20/65537, 44/65537, 30/65537, 125/65537, 25/65537, 220/65537, -33/65537, -128/65537, 50/65537, -24/65537, 117/65537, 19/65537, -15/65537, -104/65537, -23/65537, -173/65537, -100/65537, 84/65537, 1/65537, -27/65537, 40/65537, -59/65537, -47/65537, -53/65537, -63/65537, 173/65537, -103/65537, -31/65537, 1/65537, 3/65537, -29/65537, 1/65537)想定していたように初手2項答えが$0$になったので係数が$a_i/65537$に$65537$かけてやって欲しい$a_i$が求まる。あとは、$a_i$の値が正か負かで分けて差を取れば$n$の倍数となる$\\prod c_i^{a^+_i} - \\prod c_i^{a^-_i} =K*n $これをいくつか繰り返してGCDを取ってうまく求めてやればいいその後はcommon modulus attackでGGfrom sage.all import *from ast import literal_evalfrom factordb.factordb import FactorDBfrom Crypto.Util.number import *lines = open(\"./output.txt\",\"r\").readlines()es = literal_eval(lines[0].strip())cs = literal_eval(lines[1].strip())K = 0x10001N = len(es)m = matrix(QQ,N,N+2)for i in range(N): m[i,0] = es[i] m[i,1] = 1 m[i,i+2] = 1/(K)m = m.LLL()def serch_n(m): minas = 1 plus = 1 assert sum(m[2:])*K == 0 assert sum([m_*e_ for m_, e_ in zip(m[2:],es)]) == 0 for i,ei in enumerate(m[2:]): ei *= K ei = int(ei) if ei &lt; 0: minas = int(minas*cs[i]**(-1*ei)) if ei &gt; 0: plus = int(plus*cs[i]**ei) return plus-minask = 1n = serch_n(m[0])while m[k][0] == 0 and m[k][1] == 0 and k &lt; N: n = GCD(n,serch_n(m[k])) k +=1 if int(n).bit_length()&lt; 6300: f = FactorDB(int(n)) f.connect() n = f.get_factor_list()[-1] assert n.bit_length() == 2048 print(n) break # n = 17724789252315807248927730667204930958297858773674832260928199237060866435185638955096592748220649030149566091217826522043129307162493793671996812004000118081710563332939308211259089195461643467445875873771237895923913260591027067630542357457387530104697423520079182068902045528622287770023563712446893601808377717276767453135950949329740598173138072819431625017048326434046147044619183254356138909174424066275565264916713884294982101291708384255124605118760943142140108951391604922691454403740373626767491041574402086547023530218679378259419245611411249759537391050751834703499864363713578006540759995141466969230839from attacks.rsa.common_modulus import attackmpe1_inv = inverse(cs[0],n)e = [e-es[0] for e in es[1:]]c = [c*pow(cs[0],-1,n)%n for c in cs[1:]]find = Falsefor i in range(len(e)): for j in range(len(e)): if gcd(e[i],e[j]) == 1: m = attack(n, e[i], c[i], e[j], c[j] ) print(long_to_bytes(m)) exit()# hitcon{K33p_ev3rythIn9_1nd3p3ndent!}solve2@maple3142さんから助言いただきまして$p$を復元して、上記のように$n$を求めて通常のRSAのように復元する方法。$m^{(1 + e_i)} = c_i \\mod p$であるので、求め方はほぼ同じなので同じ以下の様に格子を組む\\[\\left[\\begin{array}{ccccc}e_0+1 &amp; 1/65537 &amp; \\cdots&amp; 0 \\\\ \\vdots &amp; \\vdots&amp;\\ddots&amp; 0 \\\\ e_n+1 &amp; 0 &amp; \\cdots &amp; 1/65537 \\end{array}\\right]\\]from sage.all import *from ast import literal_evalfrom factordb.factordb import FactorDBfrom Crypto.Util.number import *lines = open(\"./output.txt\",\"r\").readlines()es = literal_eval(lines[0].strip())cs = literal_eval(lines[1].strip())K = 0x10001N = len(es)m = matrix(QQ,N,N+1)for i in range(N): m[i,0] = es[i] + 1 m[i,i+1] = 1/(K)# m^(p + e_i) = c_i mod n# m^(1 + e_i) = c_i mod pm = m.LLL()def serch_n(m): minas = 1 plus = 1 assert sum([m_*(e_ + 1) for m_, e_ in zip(m[1:],es)]) == 0 for i,ei in enumerate(m[1:]): ei *= K ei = int(ei) if ei &lt; 0: minas = int(minas*cs[i]**(-1*(ei))) if ei &gt; 0: plus = int(plus*cs[i]**(ei)) return plus-minask = 1n = serch_n(m[0])print(k,int(n).bit_length())while m[k][0] == 0 and k &lt; N: n_ = serch_n(m[k]) print(k,int(n_).bit_length()) n = GCD(n,n_) k +=1 if int(n).bit_length()&lt; 6300: f = FactorDB(int(n)) f.connect() p = f.get_factor_list()[-1] # [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 13, 13, 13, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 114123489471785231935784934808971699969409921187241213856052699152350022529522625133249122600992294384493330729753558097354310956450782137388609095123051712848950720360020186805006589596948820312938610934162552701552428320073591829720623902109809701883779673050594202312941073709061911680769616320309646800153] assert p.bit_length() == 1024 print(p) break p = 114123489471785231935784934808971699969409921187241213856052699152350022529522625133249122600992294384493330729753558097354310956450782137388609095123051712848950720360020186805006589596948820312938610934162552701552428320073591829720623902109809701883779673050594202312941073709061911680769616320309646800153" }, { "title": "SECCON CTF 2022 writeup", "url": "/posts/SECCON-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-11-14 14:00:00 +0900", "snippet": "初めにSECCONでちょっと出来なかったことが多すぎたので分かる範囲で纏めました。jyankenとwitches_symmetric_examはまた次回にでも…それよりも問題なのがthis_is_not_lsbがほんとにLLLで解けるのかということで、手元で組んだ感じ全部失敗したのでなえてます。はい。。。年末までにbit長さでのEHNPとHNPのお気持ちを理解したい所存です。(がんばるます…!!)pqpqchallfrom Crypto.Util.number import *from Crypto.Random import *from flag import flagp = getPrime(512)q = getPrime(512)r = getPrime(512)n = p * q * re = 2 * 65537assert n.bit_length() // 8 - len(flag) &gt; 0padding = get_random_bytes(n.bit_length() // 8 - len(flag))m = bytes_to_long(padding + flag)assert m &lt; nc1p = pow(p, e, n)c1q = pow(q, e, n)cm = pow(m, e, n)c1 = (c1p - c1q) % nc2 = pow(p - q, e, n)print(f\"e = {e}\")print(f\"n = {n}\")# p^e - q^e mod nprint(f\"c1 = {c1}\")# (p-q)^e mod nprint(f\"c2 = {c2}\")# m^e mod nprint(f\"cm = {cm}\")solve1STEP : $p,q,r$の導出$c_1 \\equiv p^e - q^e \\mod n,c_2 \\equiv (p-q)^e \\mod n$であることより$c_1-c_2 \\equiv (p^e - q^e) - (p^e+q^e + \\sum^{e-1}{i=1}\\ _eC_ip^i(-q)^{e-i})\\equiv q(-2q^{e-1}+ \\sum^{e-1}{i=1}\\ _eC_ip^i(-q)^{e-i-1}))$となる。よって、$n=pqr$であることより$c_1-c_2$と$n$のGCDを取れば$q$が求まる。$c_1 \\equiv p^e \\mod q$, $e=2*65537$であるので $d \\equiv 65537^{-1} \\mod q-1$とすれば$p^2 \\equiv c_1^d \\mod q $となる。よって、$p^2$の平方根を求めることで$p$がもとまると同時に$n$より$r$も求まる。2STEP : 復号$GCD(e,(p-1)(q-1)(r-1))) \\neq1 $より単純な計算では$d$が求まらないので、素数ごとに復元してCRTで求めるようにする。よって$GCD(\\frac{e}{2},(p-1)(q-1)(r-1))) =1 $より単純な計算で$\\frac{e}{2}$の逆元を求めることで以下の式が求まる。$ d_p \\equiv \\frac{e}{2}^{-1} \\mod p-1,d_q \\equiv \\frac{e}{2}^{-1} \\mod q-1,d_r \\equiv \\frac{e}{2}^{-1} \\mod r-1$よって、$m_p^2 \\equiv cm^{d_p} \\mod p,m_q^2 \\equiv cm^{d_q} \\mod q,m_r^2 \\equiv cm^{d_r} \\mod r$ となりそれぞれの平方根を組み合わせてCRTで復元してflagが求まる。from Crypto.Util.number import *from Crypto.Random import *from itertools import product e = 131074n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866# 1019 601 739# 36230691# e = 131074# n = 452577641# c1 = 64229228# c2 = 200519200# cm = 18095470m = bytes_to_long(b\"1234567890\")# p*qq = GCD(c1-c2,n)assert n%q == 0pr = n// qassert isPrime(q)p2 = pow(c1,pow(e//2,-1,q-1),q)# print(pow(c1,pow(e//2,-1,q-1),q))# print(pow(823,e,q))# print(823%q,pow(823,2,q))# print(p2,q)# print(mod(p2, q).sqrt(all = True))# p = 7572427786695057270624844967644562609112132599800420296747189080920032359205995588384031542287784540006438555802994008688795974493684400576592403320929717for p in mod(p2, q).sqrt(all = True): for i in range(2): p = int(p) p += i*q # print(p,isPrime(p)) if n%p==0: # print(p) breakp = 7572427786695057270624844967644562609112132599800420296747189080920032359205995588384031542287784540006438555802994008688795974493684400576592403320929717assert isPrime(p)assert isPrime(q)assert n%p==0assert n%q==0 r = n//(p*q)# print(r)assert isPrime(r)assert n%r==0def search(c,p): assert pow(mod(pow(c,pow(e//2,-1,p-1),p), p).sqrt(all = True)[0],e,p)==c return mod(pow(c,pow(e//2,-1,p-1),p), p).sqrt(all = True)for cp,cq,cr in list(product(search(cm,p),search(cm,q),search(cm,r))): print(int(cp)) # input() tmp = CRT([int(cp),int(cq),int(cr)],[p,q,r]) if b\"SECCON\" in long_to_bytes(tmp): print(long_to_bytes(tmp)) # SECCON{being_able_to_s0lve_this_1s_great!}BBBchallfrom Crypto.Util.number import bytes_to_long, getPrimefrom random import randintfrom math import gcdfrom secret import FLAGfrom os import urandomassert len(FLAG) &lt; 100def generate_key(rng, seed): e = rng(seed) while True: for _ in range(randint(10,100)): e = rng(e) p = getPrime(1024) q = getPrime(1024) phi = (p-1)*(q-1) if gcd(e, phi) == 1: break n = p*q return (n, e)def generate_params(): p = getPrime(1024) a = randint(0, p-1) return (p,a)def main(): p,a = generate_params() print(\"[+] The parameters of RNG:\") print(f\"{a=}\") print(f\"{p=}\") b = int(input(\"[+] Inject [b]ackdoor!!: \")) rng = lambda x: (x**2 + a*x + b) % p keys = [] seeds = [] for i in range(5): seed = int(input(\"[+] Please input seed: \")) seed %= p if seed in seeds: print(\"[!] Same seeds are not allowed!!\") exit() seeds.append(seed) n, e = generate_key(rng, seed) if e &lt;= 10: print(\"[!] `e` is so small!!\") exit() keys.append((n,e)) flag = bytes_to_long(FLAG + urandom(16)) for n,e in keys: c = pow(flag, e, n) print(\"[+] Public Key:\") print(f\"{n=}\") print(f\"{e=}\") print(\"[+] Cipher Text:\", c)if __name__ == \"__main__\": main()upsolve競技時競技時考えていたこととしては、この問題の特徴として $n_i$ 同士に対しての共通な素数はない $b$で二次関数を操作できる その二次関数から$e$が生成 FLAGに対して128bitのpadding $e$はLCG(2次関数)を適当に繰り返す(10-100回) $e$が11以上が見えたので、1からHastad’s broadcast attack ができるのかなぁと思いつつ、初めに11個のインスタンスからそれぞれ$e=11$と固定したものを取ってきてHastad’s broadcast attack やると当たり前ですが答えは出ません(3. のpaddingによって)。なら、$e=12$にして2乗根を2回、3乗根を3回とれば出るかなと思いつつ実行すると、そもそも$GCD(e,phi)\\neq 1$となりそもそもできなかった。どうしたもんかなと思っていると、2次関数の性質として最大2個の解をもつことがあり、さらに言えば$b$で解を11にしているのでもう1つの解も11となることが言えます。これで2つのseedの値が得ることができたので、残りは以下の式 $\\lim_{n \\rightarrow\\inf} e_{n+1} = e_n^2 + a*e_n +b$ なのでなんかこれ見たことあるなぁと思いまして。。。少し違いますがイメージとして適当な形で表すとこんな感じ…なら、$\\lim_{n \\rightarrow\\inf} e_{n+1} = e_n$であることを追加して考えると$e_n = e_{n-1} \\neq e_{n-2},\\lim_{n \\rightarrow\\inf} e_{n} = e_{n-2}$でも問題ないよなと考えたので逆順となる$n \\rightarrow n-1\\rightarrow n-2$で$e$の値を求めれるじゃん…!!となったので、実装フェーズに移ります。ここで問題が発生sageって.roots()がありますよね…方程式の根を求めるやつ…あれの存在を完全に忘れていたので2次方程式の解の公式を実装したのですが、これやっちゃいました…もうスクリプトはないのであれなんですが実装ミスって終わりました…upsolve時てことで、sageの.roots()を使って実装しました…orzfrom pwn import *from gmpy2 import irootfrom Crypto.Util.number import *from sage.all import *def const_e(x, a, p): return (-x**2 - x*(a-1))%pwhile True: ret = set() def serch_roots(p,a,e,b): PR = PolynomialRing(GF(p),\"x\") x = PR.gen() for i in (x*x +a*x +b -e).roots(): if len(ret)&gt;4: return ret if i[0] in ret: continue ret.add(i[0]) print(\"[+] find \",len(ret)) serch_roots(p,a,int(i[0]),b) return None ns = [] es = [] cts = [] e_ = 11 io = remote( \"BBB.seccon.games\" ,8080) # io = process([\"python3\",\"chall.py\"]) io.recvline() exec(io.recvline().decode()) exec(io.recvline().decode()) io.recvuntil(b\"!!: \") print(\"[+]p\",bin(p)[-9:]) b = const_e(e_,a,p) print(\"fin\") io.sendline(str(b).encode()) li = serch_roots(p,a,e_,b) if li == None: io.close() continue for i in list(li): io.recvuntil(b\" seed: \") io.sendline(str(i).encode()) for i in range(5): io.recvline() exec(io.recvline().decode()) exec(io.recvline().decode()) ns.append(n) es.append(e) cts.append(eval(io.recvline().decode().replace(\"[+] Cipher Text: \",\"\"))) io.close() c = CRT(cts,ns) tmp = iroot(int(c),e_) print(tmp) if tmp[1] == True: print(long_to_bytes(iroot(int(c),e_)[0])) exit()[+] Opening connection to BBB.seccon.games on port 8080: Done[+]p 111011001fin[+] find 1[+] find 2[+] find 3[+] find 4[+] find 5[*] Closed connection to BBB.seccon.games port 8080(mpz(2883019091813529219737035153484934929534955887753874746941092955853444099264575760415715710120591467702376578902084283075705374264225673611778863370445183048344031472894050836959651658562832755850169071594495017590365639338557184317630010978441644681967727625313646557515818101), True)b'SECCON{Can_you_find_d_in_bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbdbbbbbbbbbbbbbbbbbbbbbbbbbbbbb?}\\xf2\\x07\\xb3\\xce\\x19\\xb8\\x8bNH\\xb0\\xa6\\xac\\x10E$u'isufficientchallfrom random import randintfrom Crypto.Util.number import getPrime, bytes_to_longfrom secret import FLAG# f(x,y,z) = a1*x + a2*x^2 + a3*x^3# + b1*y + b2*y^2 + b3*y^3# + c*z + s mod pdef calc_f(coeffs, x, y, z, p): ret = 0 ret += x * coeffs[0] + pow(x, 2, p) * coeffs[1] + pow(x, 3, p)*coeffs[2] ret += y * coeffs[3] + pow(y, 2, p) * coeffs[4] + pow(y, 3, p)*coeffs[5] ret += z * coeffs[6] ret += coeffs[7] return ret % pp = getPrime(512)# [a1, a2, a3, b1, b2, b3, c, s]coeffs = [randint(0, 2**128) for _ in range(8)]key = 0for coeff in coeffs: key &lt;&lt;= 128 key ^= coeffcipher_text = bytes_to_long(FLAG) ^ keyprint(cipher_text)shares = []for _ in range(4): x = randint(0, p) y = randint(0, p) z = randint(0, 2**128) w = calc_f(coeffs, x, y, z, p) packed_share = ((x,y), w) shares.append(packed_share)print(p)print(shares)\t競技時$ w = a_1*x + a_2*x^2 + a_3*x^3+ b_1*y + b_2*y^2 + b_3*y^3+ c*z + s \\mod p $ 、$x,y$は128bit、$p$は512bit、それ以外は128bitで式は4本与えられています。既知の値は、それぞれの式の$x,y,w$だけで、目標は係数$a,b,z,c,s$の復元となります。はじめに、まぁNHPなのでLLLかなと…思って格子を組みます。具体的に組んだ格子は以下のものです。(くそでかいですが)空白部分は0です\\[\\begin{bmatrix} p &amp; &amp; &amp; \\\\ &amp; p &amp;&amp; \\\\ &amp; &amp; p &amp; \\\\ &amp; &amp; &amp; p &amp;&amp;&amp;&amp;\\\\ x_0 &amp; x_1 &amp; x_2 &amp; x_3 &amp; 2^{128}\\\\ x_0^2 &amp; x_1^2 &amp; x_2^2 &amp; x_3^2 &amp;&amp; 2^{128} \\\\ x_0^3 &amp; x_1^3 &amp; x_2^3 &amp; x_3^3 &amp;&amp;&amp; 2^{128} \\\\ y_0 &amp; y_1 &amp; y_2 &amp; y_3 &amp;&amp;&amp;&amp; 2^{128}\\\\ y_1^2 &amp; y_1^2 &amp; y_2^2 &amp; y_3^2 &amp;&amp;&amp;&amp;&amp; 2^{128} \\\\ y_1^3 &amp; y_1^3 &amp; y_2^3 &amp; y_3^3 &amp;&amp;&amp;&amp;&amp;&amp; 2^{128}\\\\ -w_0 &amp; -w_1 &amp; -w_2 &amp; -w_3 &amp;&amp;&amp;&amp;&amp;&amp;&amp; 2^{512} \\\\\\end{bmatrix}\\]ここで $ 0\\simeq c*z + s = a_1*x + a_2*x^2 + a_3*x^3+ b_1*y + b_2*y^2 + b_3*y^3 -w +kp$と$a,b$の係数が128bitレベルなので対角成分に$1*2^{128}$を、$w$は一度しか使いたくないので$1*2^{512}$を与えてやってLLLを行う。そうするとどこかの行ベクトルに今回用いた$a,b$の値に$2^{128}$されたものと、$2^{512}$が出てくるので探せば今回用いた値を求めることができた。よって今回求まった係数は$a,b,c,s$の内$a,b$となり残りの$c,s$については別途求めなければならない。ここから行列の成分から$c*z_i + s$の値は求まるがすべての変数が未知数でどうするのかわからなくて詰んだ…orzm = matrix(ZZ,N,N)for i in range(4): m[4,i] = x[i] m[5,i] = pow(x[i],2,p) m[6,i] = pow(x[i],3,p) m[7,i] = y[i] m[8,i] = pow(y[i],2,p) m[9,i] = pow(y[i],3,p) m[10,i] = -w[i]for i in range(N): m[i,i] = 2^128 # m[i,i] = 1for i in range(4): m[i,i] = pm[10,10] = 2^512m = m.LLL()upsolveこれを求めるのは意外と単純でGCDでした。(競技中やった記憶あるんだけどなぁ…???)$h_i \\equiv c*z_i + s \\mod p $とすると$c,z_i,s$は128bitで$p$は512bitより実は、$h_i = c*z_i + s$とも表せれることになる。最大公約数を用いて$c = GCD(h_i -h_{i+1},h_{i+1} -h_{i+2})$で求まります。。。てことで、$h$の式において$c$の値が出ることがわかった。ここで、128bitを128bitで割ると商の大きさはいくつでしょうか…?答えは0 or 1 なので、これを用いると$s$も求まります。$s = h_i\\%c + \\delta_ic$　ここで、$\\delta$は0か1の数です。これですべての係数が出そろったのでkeyを復元してflagが求まります。from Crypto.Util.number import *ct = 115139400156559163067983730101733651044517302092738415230761576068368627143021367186957088381449359016008152481518188727055259259438853550911696408473202582626669824350180493062986420292176306828782792330214492239993109523633165689080824380627230327245751549253757852668981573771168683865251547238022125676591p = 8200291410122039687250292442109878676753589397818032770561720051299309477271228768886216860911120846659270343793701939593802424969673253182414886645533851xyw = [((6086926015098867242735222866983726204461220951103360009696454681019399690511733951569533187634005519163004817081362909518890288475814570715924211956186561, 180544606207615749673679003486920396349643373592065733048594170223181990080540522443341611038923128944258091068067227964575144365802736335177084131200721), 358596622670209028757821020375422468786000283337112662091012759053764980353656144756495576189654506534688021724133853284750462313294554223173599545023200), ((1386358358863317578119640490115732907593775890728347365516358215967843845703994105707232051642221482563536659365469364255206757315665759154598917141827974, 4056544903690651970564657683645824587566358589111269611317182863269566520886711060942678307985575546879523617067909465838713131842847785502375410189119098), 7987498083862441578197078091675653094495875014017487290616050579537158854070043336559221536943501617079375762641137734054184462590583526782938983347248670), ((656537687734778409273502324331707970697362050871244803755641285452940994603617400730910858122669191686993796208644537023001462145198921682454359699163851, 7168506530157948082373212337047037955782714850395068869680326068416218527056283262697351993204957096383236610668826321537260018440150283660410281255549702), 1047085825033120721880384312942308021912742666478829834943737959325181775143075576517355925753610902886229818331095595005460339857743811544053574078662507), ((5258797924027715460925283932681628978641108698338452367217155856384763787158334845391544834908979711067046042420593321638221507208614929195171831766268954, 4425317882205634741873988391516678208287005927456949928854593454650522868601946818897817646576217811686765487183061848994765729348913592238613989095356071), 866086803634294445156445022661535120113351818468169243952864826652249446764789342099913962106165135623940932785868082548653702309009757035399759882130676)]x = []y = []w = []for i in range(4): x.append(xyw[i][0][0]) y.append(xyw[i][0][1]) w.append(xyw[i][1])N = 11m = matrix(ZZ,N,N)for i in range(4): m[4,i] = x[i] m[5,i] = pow(x[i],2,p) m[6,i] = pow(x[i],3,p) m[7,i] = y[i] m[8,i] = pow(y[i],2,p) m[9,i] = pow(y[i],3,p) m[10,i] = -w[i]for i in range(N): m[i,i] = 2^128 # m[i,i] = 1for i in range(4): m[i,i] = pm[10,10] = 2^512m = m.LLL()#cz+ scz_s = []coffs = []for k in range(4):\tcz_s.append(abs(m[-1,k]))for k in range(4,N-1):\tcoffs.append(m[-1,k]//2^128)c = GCD(cz_s[0]-cz_s[1],cz_s[1]-cz_s[2])coffs.append(c)s = cz_s[0]%ccoffs.append(s)print(cz_s)print(coffs)key = 0for coff in coffs: key &lt;&lt;= 128 key ^^= coff cipher_text = int(ct) ^^ keyprint(long_to_bytes(cipher_text))b'SECCON{Unfortunately_I_could_not_come_up_with_a_more_difficult_problem_than_last_year_sorry...-6fc18307d3ed2e7673a249abc2e0e22c}'this_is_not_lsbchallfrom Crypto.Util.number import *from flag import flagp = getStrongPrime(512)q = getStrongPrime(512)e = 65537n = p * qphi = (p - 1) * (q - 1)d = pow(e, -1, phi)print(f\"n = {n}\")print(f\"e = {e}\")print(f\"flag_length = {flag.bit_length()}\")# Oops! encrypt without padding!c = pow(flag, e, n)print(f\"c = {c}\")# padding format: 0b0011111111........def check_padding(c): padding_pos = n.bit_length() - 2 m = pow(c, d, n) m = c return (m &gt;&gt; (padding_pos - 8)) == 0xFFwhile True: c = int(input(\"c = \")) print(check_padding(c))競技中なんかDownunderctfのRSA oracle iv とか sekaictfのEZmazeとかで見たことあるなぁと思いつつisufficientと同じ感じで格子組んでました…from sage.modules.free_module_integer import IntegerLatticefrom pwn import *from Crypto.Util.number import *# Directly taken from rbtree's LLL repository# From https://oddcoder.com/LOL-34c3/, https://hackmd.io/@hakatashi/B1OM7HFVIdef Babai_CVP(mat, target):\tM = IntegerLattice(mat, lll_reduce=True).reduced_basis\tG = M.gram_schmidt()[0]\tdiff = target\tfor i in reversed(range(G.nrows())):\t\tdiff -= M[i] * ((diff * G[i]) / (G[i] * G[i])).round()\treturn target - diffdef solve(mat, lb, ub, weight = None):\tnum_var = mat.nrows()\tnum_ineq = mat.ncols()\tmax_element = 0 \tfor i in range(num_var):\t\tfor j in range(num_ineq):\t\t\tmax_element = max(max_element, abs(mat[i, j]))\tif weight == None:\t\tweight = num_ineq * max_element # sanity checker\tif len(lb) != num_ineq:\t\tprint(\"Fail: len(lb) != num_ineq\")\t\treturn\tif len(ub) != num_ineq:\t\tprint(\"Fail: len(ub) != num_ineq\")\t\treturn\tfor i in range(num_ineq):\t\tif lb[i] &gt; ub[i]:\t\t\tprint(\"Fail: lb[i] &gt; ub[i] at index\", i)\t\t\treturn \t# heuristic for number of solutions\tDET = 0\tif num_var == num_ineq:\t\tDET = abs(mat.det())\t\tnum_sol = 1\t\tfor i in range(num_ineq):\t\t\tnum_sol *= (ub[i] - lb[i])\t\tif DET == 0:\t\t\tprint(\"Zero Determinant\")\t\telse:\t\t\tnum_sol //= DET\t\t\t# + 1 added in for the sake of not making it zero...\t\t\tprint(\"Expected Number of Solutions : \", num_sol + 1)\t# scaling process begins\tmax_diff = max([ub[i] - lb[i] for i in range(num_ineq)])\tapplied_weights = []\tfor i in range(num_ineq):\t\tineq_weight = weight if lb[i] == ub[i] else max_diff // (ub[i] - lb[i])\t\tapplied_weights.append(ineq_weight)\t\tfor j in range(num_var):\t\t\tmat[j, i] *= ineq_weight\t\tlb[i] *= ineq_weight\t\tub[i] *= ineq_weight\t# Solve CVP\ttarget = vector([(lb[i] + ub[i]) // 2 for i in range(num_ineq)])\tresult = Babai_CVP(mat, target)\tfor i in range(num_ineq):\t\tif (lb[i] &lt;= result[i] &lt;= ub[i]) == False:\t\t\tprint(\"Fail : inequality does not hold after solving\")\t\t\tbreak \t# recover x\tfin = None\tif DET != 0:\t\tmat = mat.transpose()\t\tfin = mat.solve_right(result)\t\t## recover your result\treturn result, applied_weights, finwhile True: conn = remote('this-is-not-lsb.seccon.games', 8080) # conn = process([\"python3\",\"problem.py\"]) n = int(conn.recvline().decode().strip().split('n = ')[1]) e = int(conn.recvline().decode().strip().split('e = ')[1]) flag_length = int(conn.recvline().decode().strip().split('flag_length =')[1]) c = int(conn.recvline().decode().strip().split('c = ')[1]) print(n,e,c) print(flag_length) def query(c): conn.sendlineafter(b\"c = \",str(c).encode()) return eval( conn.recvline().decode()) def blinded_query(r, c): return query((pow(r, e, n) * c) % n) rs_and_Us = [] while len(rs_and_Us) &lt; 50: r = randint(1, n) r_ = r if blinded_query(r, c): rs_and_Us.append([r, int(n).bit_length() - 2]) print('got!', len(rs_and_Us)) N = len(rs_and_Us)+1 m = matrix(ZZ,N,N) for i in range(N-1): m[0,i+1] = rs_and_Us[i][0] for i in range(N): m[i,i] = n m[0,0] = 1 ub = [u for _,u in rs_and_Us] sol = solve(m,[0]*N, [flag_length]+ub) print(sol) sol = sol[0] print(sol) print(long_to_bytes(abs(sol))) conn.close() try: if \"SECCON\" in long_to_bytes(abs(sol)): exit() if sol &gt; 2^flag_length: sol = -sol % n print(long_to_bytes(abs(sol))) if \"SECCON\" in long_to_bytes(abs(sol)): exit() except: continueupsolveただ、これだと求まらなかったので色々なupsolve拝見させてもらって得たアイディアを用いて組んで見ましたがどれもダメでした。。。(泣)やっぱりLLLのお気持ちは難しいですねぇ…これなら動きましたよ的なアドバイスあればお待ちしてます。。m(_ _)m" }, { "title": "buckeye CTF 2022 writeup", "url": "/posts/buckeye-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-11-07 10:00:00 +0900", "snippet": "初めにNu1L ctf でpocかけなくて撃沈。。。[crypto] megaxord [312 solve]challbytesのファイルのみsolve順に探索して終わりdef bxor(a,b): return bytes([_a^b for _a in a])f = open(\"megaxord.txt\",\"rb\").read()for i in range(256): if b\"buckeye{\" in bxor(f,i): for x in bxor(f,i).decode().split(\" \"): if \"buckeye{\" in x: print(x) exit() # buckeye{m1gh7y_m0rph1n_w1k1p3d14_p4g3}[crypto] Twin prime RSA [ 167 solve]challimport Crypto.Util.number as cunwhile True: p = cun.getPrime(1024) q = p + 2 if cun.isPrime(q): breakn = p * qe = 0x10001phi = (p - 1) * (q - 1)d = pow(e, -1, phi)FLAG = cun.bytes_to_long(b\"buckeye{?????????????????????????????????????????????????????????????}\")c = pow(FLAG, e, n)assert pow(c, d, n) == FLAGprint(f\"n = {n}\")print(f\"c = {c}\")\"\"\"Output:n = 20533399299284046407152274475522745923283591903629216665466681244661861027880216166964852978814704027358924774069979198482663918558879261797088553574047636844159464121768608175714873124295229878522675023466237857225661926774702979798551750309684476976554834230347142759081215035149669103794924363457550850440361924025082209825719098354441551136155027595133340008342692528728873735431246211817473149248612211855694673577982306745037500773163685214470693140137016315200758901157509673924502424670615994172505880392905070519517106559166983348001234935249845356370668287645995124995860261320985775368962065090997084944099c = 786123694350217613420313407294137121273953981175658824882888687283151735932871244753555819887540529041840742886520261787648142436608167319514110333719357956484673762064620994173170215240263058130922197851796707601800496856305685009993213962693756446220993902080712028435244942470308340720456376316275003977039668016451819131782632341820581015325003092492069871323355309000284063294110529153447327709512977864276348652515295180247259350909773087471373364843420431252702944732151752621175150127680750965262717903714333291284769504539327086686569274889570781333862369765692348049615663405291481875379224057249719713021\"\"\"solve二次方程式組み立てて$p,q$求めて終わり最近グレブナーでサボってたから真面目にやりましたまる…from Crypto.Util.number import *from gmpy2 import irootn = 20533399299284046407152274475522745923283591903629216665466681244661861027880216166964852978814704027358924774069979198482663918558879261797088553574047636844159464121768608175714873124295229878522675023466237857225661926774702979798551750309684476976554834230347142759081215035149669103794924363457550850440361924025082209825719098354441551136155027595133340008342692528728873735431246211817473149248612211855694673577982306745037500773163685214470693140137016315200758901157509673924502424670615994172505880392905070519517106559166983348001234935249845356370668287645995124995860261320985775368962065090997084944099c = 786123694350217613420313407294137121273953981175658824882888687283151735932871244753555819887540529041840742886520261787648142436608167319514110333719357956484673762064620994173170215240263058130922197851796707601800496856305685009993213962693756446220993902080712028435244942470308340720456376316275003977039668016451819131782632341820581015325003092492069871323355309000284063294110529153447327709512977864276348652515295180247259350909773087471373364843420431252702944732151752621175150127680750965262717903714333291284769504539327086686569274889570781333862369765692348049615663405291481875379224057249719713021p = (-2+iroot(4+4*n,2)[0])//2q =n//passert n == p*qphi = (p-1)*(q-1)e = 0x10001print(long_to_bytes(pow(c, pow(e,-1,phi), n)))# buckeye{B3_TH3R3_OR_B3_SQU4R3__abcdefghijklmonpqrstuvwxyz__0123456789}[crypto] fastfor [ 111 solve]challfrom PIL import Imageimport numpydef check_hash(fi): image = numpy.asarray(Image.open('static/IMG.png')) submission = numpy.asarray(Image.open(fi)) if image.shape != submission.shape: return False same = numpy.bitwise_xor(image, submission) if (numpy.sum(same) == 0): return False im_alt = numpy.fft.fftn(image) in_alt = numpy.fft.fftn(submission) im_hash = numpy.std(im_alt) in_hash = numpy.std(in_alt) if im_hash - in_hash &lt; 1 and im_hash - in_hash &gt; -1: return True return Falsesolve2つの画像の入力から近い標準偏差の値を求めろらしいです。お試し感覚でIMG.pngの0,0チャンクの値を+1したものを突っ込んだらフラグ出た…import check_hashfrom PIL import Imageimg2 = Image.open('static/IMG.png')img2.putpixel((0,0),(159, 227, 255, 118))img2.save(\"test.png\")print(check_hash.check_hash(\"test.png\"))# buckeye{D33p_w0Rk_N07_WhY_574ND4RD_d3V}[crypto] powerball [ 78 solve]challimport express from 'express'import http from 'http'import { Server } from 'socket.io'import crypto from 'crypto'function nextRandomNumber () { return (multiplier * seed) % modulus}function areArraysEqual (a, b) { return ( a.length === b.length &amp;&amp; a.every((x, i) =&gt; { return x === b[i] }) )}function seedToBalls (n) { const balls = [] for (let i = 0; i &lt; 10; i++) { balls.push(Number(n % 100n)) n = n / 100n } return balls}const app = express()app.use(express.static('static'))const server = http.createServer(app)const io = new Server(server)const modulus = crypto.generatePrimeSync(128, { safe: true, bigint: true })const multiplier = (2n ** 127n) - 1nlet seed = 2nfor (let i = 0; i &lt; 1024; i++) { seed = nextRandomNumber()}let winningBalls = seedToBalls(seed)let lastLotteryTime = Date.now()setInterval(() =&gt; { seed = nextRandomNumber() winningBalls = seedToBalls(seed) lastLotteryTime = Date.now()}, 60 * 1000)io.on('connection', (socket) =&gt; { socket.ticket = { balls: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], submissionTime: 0 } socket.on('updateRequest', () =&gt; { let flag = '' if ( areArraysEqual(socket.ticket.balls, winningBalls) &amp;&amp; socket.ticket.submissionTime &lt; lastLotteryTime ) { flag = process.env.FLAG } socket.emit('update', { last_winning_seed: seed.toString(), flag: flag }) }) socket.on('submitBalls', (balls) =&gt; { if (!(Array.isArray(balls) &amp;&amp; balls.length === 10)) return for (let i = 0; i &lt; 10; i++) { if (typeof balls[i] !== 'number') return } socket.ticket = { balls: balls, submissionTime: Date.now() } })})server.listen(3000, () =&gt; { console.log('Ready')})const socket = io() // eslint-disable-line no-undeflet seenFlag = falsefunction seedToBalls (n) { const balls = [] for (let i = 0; i &lt; 10; i++) { balls.push(Number(n % 100n)) n = n / 100n } return balls}function handleUpdate (update) { console.log(update) if (update.flag &amp;&amp; !seenFlag) { alert(update.flag) seenFlag = true } const balls = seedToBalls(BigInt(update.last_winning_seed)) for (let i = 0; i &lt; 10; i++) { document.getElementById(`ball${i}`).innerText = balls[i] }}function initSocket () { socket.on('update', handleUpdate) socket.emit('updateRequest') setInterval(() =&gt; { console.log(Date.now() / 1000) socket.emit('updateRequest') }, 5000)}function sendBallsIfAvailable () { const balls = [] for (let i = 0; i &lt; 10; i++) { const a = parseInt(document.getElementById(`input-ball${i}`).value) if (isNaN(a) || a &lt; 0 || a &gt;= 100) return balls.push(a) } console.log(`Submitting balls ${balls}`) socket.emit('submitBalls', balls)}function initInput () { for (let i = 0; i &lt; 10; i++) { document.getElementById(`input-ball${i}`).onkeypress = (event) =&gt; { const n = parseInt(event.key) if (isNaN(n)) return false setTimeout(sendBallsIfAvailable, 100) } document.getElementById(`input-ball${i}`).onpaste = (event) =&gt; { const n = event.clipboardData.getData('Text') if (isNaN(n)) return false setTimeout(sendBallsIfAvailable, 100) } }}initSocket()initInput()solve個人的にはnode jsの仕様を理解するのに時間がかかった…(console.log使えると思ってなくてこれがeasyなわけないやろとか思ってたとか、思ってなかったとかorz)クライアント側で動いているのはmain.jsなのでconsole.logからupdate.last_winning_seedを求めることができる。よって二項間漸化式$ball_{n+1} \\equiv a*ball_n \\pmod p$から$p$の値が求まる。この問題の目標として、画面に表示されている乱数よりも後の乱数を求めて入力する必要があるので、今が何項目か調べてやればOKfrom sage.all import *from Crypto.Util.number import *def int_to_ball(a): ret = [] for i in range(10): # print(a%100) ret.append(a%100) a = a//100 return ret[::-1]a = 2**127 -1s1 = 38386045261155976433540741815806908550s2 = 43312535513384515088100925378630654634s3 = 201038737730550603713123190637463026163nowball = 76544625579486203475251392218240548059p = factor(gcd(s2*a-s3,s1*a-s2))[-1][0]nowball = GF(p)(nowball)win = GF(p)(2)a = GF(p)(a)for i in range(2**26): if int(win)==int(nowball): print(int_to_ball(int(win))[::-1]) win = win*a print(int_to_ball(int(win))[::-1]) win = win*a print(int_to_ball(int(win))[::-1]) win = win*a print(int_to_ball(int(win))[::-1]) break win = win*a# buckeye{y3ah_m4yb3_u51nG_A_l1N34r_c0nGru3Nt1al_G3n3r4t0r_f0r_P0w3rB4lL_wA5nt_tH3_b3st_1d3A}[crypto] bounce [ 97 solve]challimport randomwith open('sample.txt') as file: line = file.read()with open('flag.txt') as file: flag = file.read()samples = [line[i:i+28] for i in range(0, len(line) - 1 - 28, 28)]samples.insert(random.randint(0, len(samples) - 1), flag)i = 0while len(samples) &lt; 40: samples.append(samples[len(samples) - i - 2]) i = random.randint(0, len(samples) - 1)encrypted = []for i in range(len(samples)): x = samples[i] if i &lt; 10: nonce = str(i) * 28 else: nonce = str(i) * 14 encrypted.append(''.join(str(ord(a) ^ ord(b)) + ' ' for a,b in zip(x, nonce)))with open('output.txt', 'w') as file: for i in range(0, 4): file.write('input: ' + samples[i] + '\\noutput: ' + encrypted[i] + '\\n') file.write('\\n') for i in range(4, len(samples)): file.write('\\ninput: ???\\n' + 'output: ' + encrypted[i])solveそのまま突っ込んで終わり…f = open(\"output.txt\").readlines()part1_input = [f[i][7:-1] for i in range(0,8,2)]part1_output = [[ k for k in f[i+1][8:-2].split(\" \") ]for i in range(0,8,2)]part2_output = [[ int(k) for k in f[i+1][8:-2].split(\" \") ]for i in range(10,len(f),2)]output = part1_output+part2_outputfor i in range(len(output)): x = output[i] if i &lt; 10: nonce = str(i) * 28 else: nonce = str(i) * 14 if \"eye\" in ''.join(chr(int(a) ^ ord(b)) for a,b in zip(x, nonce)): print(''.join(chr(int(a) ^ ord(b)) for a,b in zip(x, nonce)))# buckeye{some_say_somefish:)}[crypto] SSSHIT [ 41 solve]cahllimport Crypto.Util.number as cunimport randomimport astdef evaluate_polynomial(polynomial: list, x: int, p: int): return ( sum( (coefficient * pow(x, i, p)) % p for i, coefficient in enumerate(polynomial) ) % p )N_SHARES = 3def main(): print( f\"I wrote down a list of people who are allowed to get the flag and split it into {N_SHARES} using Shamir's Secret Sharing.\" ) MESSAGE = cun.bytes_to_long(b\"qxxxb, BuckeyeCTF admins, and NOT YOU\") p = cun.getPrime(512) polynomial = [MESSAGE] + [random.randrange(1, p) for _ in range(N_SHARES - 1)] points = [(i, evaluate_polynomial(polynomial, i, p)) for i in range(1, N_SHARES + 1)] print(\"Your share is:\") print(points[0]) print(\"The other shares are:\") for i in range(1, len(points)): print(points[i]) print() print(\"Now submit your share for reconstruction:\") your_input = ast.literal_eval(input(\"&gt;&gt;&gt; \")) if ( type(your_input) is not tuple or len(your_input) != 2 or type(your_input[0]) is not int or type(your_input[1]) is not int or your_input[0] != 1 or not (0 &lt;= your_input[1] &lt; p) ): print(\"Bad input\") return points[0] = your_input xs = [point[0] for point in points] ys = [point[1] for point in points] y_intercept = 0 for j in range(N_SHARES): product = 1 for i in range(N_SHARES): if i != j: product = (product * xs[i] * pow(xs[i] - xs[j], -1, p)) % p y_intercept = (y_intercept + ys[j] * product) % p reconstructed_message = cun.long_to_bytes(y_intercept) if reconstructed_message == b\"qxxxb, BuckeyeCTF admins, and ME\": print(\"Here's your flag:\") print(\"buckeye{?????????????????????????????????????????}\") else: print(f\"Sorry, only these people can see the flag: {reconstructed_message}\")main()solve2つの乱数を$r_1,r_2$とし、メッセージを$m$とすると最初の多項式の部分で$points_i = i^{2} *r_2 + i*r_1 + m \\pmod p, (1 \\leq i\\leq 3)$を求めているが、それぞれのpointsの値はわかるのでそれをうまく用いることで$p$を復元でき、そこから$r_1,r_2$を求められる。暗号を求めている部分を関数として、入力に、$points_i,i$を与え$f(points_1,points_2,points_3,1,2,3)$とできる。ここで$points_1$はこちらで指定できる任意の値で出力として”qxxxb, BuckeyeCTF admins, and ME”を出すように変化させてやればOKfrom pwn import *from Crypto.Util.number import *from sage.all import *io = remote(\"pwn.chall.pwnoh.io\" ,13382)# io = process([\"python3\",\"chall.py\"])#295 bitMESSAGE = bytes_to_long(b\"qxxxb, BuckeyeCTF admins, and NOT YOU\")#255 bitreconstructed_message = bytes_to_long(b\"qxxxb, BuckeyeCTF admins, and ME\")def recover(points): y = points[1] p = factor(y[2]-3*y[1]+3*y[0]-MESSAGE)[-1][0] assert int(p).bit_length() == 512 return pdef catch(): points = [[],[]] io.recvline() io.recvline() p = eval(io.recvline().decode()) points[0].append(p[0]) points[1].append(p[1]) io.recvline() p = eval(io.recvline().decode()) points[0].append(p[0]) points[1].append(p[1]) p = eval(io.recvline().decode()) points[0].append(p[0]) points[1].append(p[1]) return pointsdef calc(points,p): N_SHARES = 3 xs = points[0] y = [0]+points[1][1:] pro = 0 pro += (xs[0]*pow(xs[0]-xs[1],-1,p)*xs[2]*pow(xs[2]-xs[1],-1,p)*y[1])%p pro += (xs[0]*pow(xs[0]-xs[2],-1,p)*xs[1]*pow(xs[1]-xs[2],-1,p)*y[2])%p y0 = ((reconstructed_message - pro)*pow(xs[1]*pow(xs[1]-xs[0],-1,p)*xs[2]*pow(xs[2]-xs[0],-1,p),-1,p))%p return y0points = catch()p = recover(points)io.recvuntil(b\"&gt; \")y0 = calc(points,int(p))io.sendline(f\"(1,{y0})\".encode())io.interactive()# buckeye{tH1s_SSS_sch3Me_c0uLd_u5e_s0M3_S1gna7Ur3s}[crypto] Quad prime RSA [ 23 solve]challimport Crypto.Util.number as cunp = cun.getPrime(500)while True: q = cun.getPrime(1024) r = q + 2 if cun.isPrime(r): breaks = cun.getPrime(500)n_1 = p * qn_2 = r * se = 0x10001d_1 = pow(e, -1, (p - 1) * (q - 1))d_2 = pow(e, -1, (r - 1) * (s - 1))FLAG = cun.bytes_to_long(b\"buckeye{??????????????????????????????????????????????????????????????????????}\")c_1 = pow(FLAG, e, n_1)c_2 = pow(FLAG, e, n_2)assert pow(c_1, d_1, n_1) == FLAGassert pow(c_2, d_2, n_2) == FLAGprint(f\"n_1 = {n_1}\")print(f\"n_2 = {n_2}\")print(f\"c_1 = {c_1}\")print(f\"c_2 = {c_2}\")\"\"\"Output:n_1 = 266809852588733960459210318535250490646048889879697803536547660295087424359820779393976863451605416209176605481092531427192244973818234584061601217275078124718647321303964372896579957241113145579972808278278954608305998030194591242728217565848616966569801983277471847623203839020048073235167290935033271661610383018423844098359553953309688771947405287750041234094613661142637202385185625562764531598181575409886288022595766239130646497218870729009410265665829n_2 = 162770846172885672505993228924251587431051775841565579480252122266243384175644690129464185536426728823192871786769211412433986353757591946187394062238803937937524976383127543836820456373694506989663214797187169128841031021336535634504223477214378608536361140638630991101913240067113567904312920613401666068950970122803021942481265722772361891864873983041773234556100403992691699285653231918785862716655788924038111988473048448673976046224094362806858968008487c_1 = 90243321527163164575722946503445690135626837887766380005026598963525611082629588259043528354383070032618085575636289795060005774441837004810039660583249401985643699988528916121171012387628009911281488352017086413266142218347595202655520785983898726521147649511514605526530453492704620682385035589372309167596680748613367540630010472990992841612002290955856795391675078590923226942740904916328445733366136324856838559878439853270981280663438572276140821766675c_2 = 111865944388540159344684580970835443272640009631057414995719169861041593608923140554694111747472197286678983843168454212069104647887527000991524146682409315180715780457557700493081056739716146976966937495267984697028049475057119331806957301969226229338060723647914756122358633650004303172354762801649731430086958723739208772319851985827240696923727433786288252812973287292760047908273858438900952295134716468135711755633215412069818249559715918812691433192840\"\"\"solve少し式変形してやると$n_1 = p*q, n_2 = (q+2)*r $となり少し展開して$n_1 = p*q, n_2 = q*r + 2*r $これは$n_i = p_i*q + r_i$の形で表せれられるので、Approximate GCD Problemと見て解くことができます…scriptはこれを使いました。便利…!!実際は連分数を想定していたそう…???なるほど…n_1 = 266809852588733960459210318535250490646048889879697803536547660295087424359820779393976863451605416209176605481092531427192244973818234584061601217275078124718647321303964372896579957241113145579972808278278954608305998030194591242728217565848616966569801983277471847623203839020048073235167290935033271661610383018423844098359553953309688771947405287750041234094613661142637202385185625562764531598181575409886288022595766239130646497218870729009410265665829n_2 = 162770846172885672505993228924251587431051775841565579480252122266243384175644690129464185536426728823192871786769211412433986353757591946187394062238803937937524976383127543836820456373694506989663214797187169128841031021336535634504223477214378608536361140638630991101913240067113567904312920613401666068950970122803021942481265722772361891864873983041773234556100403992691699285653231918785862716655788924038111988473048448673976046224094362806858968008487c_1 = 90243321527163164575722946503445690135626837887766380005026598963525611082629588259043528354383070032618085575636289795060005774441837004810039660583249401985643699988528916121171012387628009911281488352017086413266142218347595202655520785983898726521147649511514605526530453492704620682385035589372309167596680748613367540630010472990992841612002290955856795391675078590923226942740904916328445733366136324856838559878439853270981280663438572276140821766675c_2 = 111865944388540159344684580970835443272640009631057414995719169861041593608923140554694111747472197286678983843168454212069104647887527000991524146682409315180715780457557700493081056739716146976966937495267984697028049475057119331806957301969226229338060723647914756122358633650004303172354762801649731430086958723739208772319851985827240696923727433786288252812973287292760047908273858438900952295134716468135711755633215412069818249559715918812691433192840from Crypto.Util.number import *# n1 = q*p + 0*s# n2 = (q+2)+r = q*s + 2*s# I use https://github.com/jvdsn/crypto-attacks/blob/master/attacks/acd/ol.pydef attack(x, rho): \"\"\" Solves the ACD problem using the orthogonal based approach. More information: Galbraith D. S. et al., \"Algorithms for the Approximate Common Divisor Problem\" (Section 4) :param x: the x samples, with xi = p * qi + ri :param rho: the bit length of the r values :return: the secret integer p and a list containing the r values, or None if p could not be found \"\"\" def symmetric_mod(x, m): \"\"\" Computes the symmetric modular reduction. :param x: the number to reduce :param m: the modulus :return: x reduced in the interval [-m/2, m/2] \"\"\" return int((x + m + m // 2) % m) - int(m // 2) assert len(x) &gt;= 2, \"At least two x values are required.\" R = 2 ** rho B = matrix(ZZ, len(x), len(x) + 1) for i, xi in enumerate(x): B[i, 0] = xi B[i, i + 1] = R B = B.LLL() K = B.submatrix(row=0, col=1, nrows=len(x) - 1, ncols=len(x)).right_kernel() q = K.an_element() r0 = symmetric_mod(x[0], q[0]) p = abs((x[0] - r0) // q[0]) r = [symmetric_mod(xi, p) for xi in x] if all(-R &lt; ri &lt; R for ri in r): return int(p), r q,s = attack([n_1,n_2], 513)p = n_1//qphi = (p-1)*(q-1)e = 0x10001print(long_to_bytes(int(pow(c_1, pow(e,-1,phi), n_1))))# buckeye{I_h0p3_y0u_us3D_c0nt1nu3d_fr4ct10Ns...th4nk5_d0R5A_f0r_th3_1nsp1r4t10n}" }, { "title": "ASIS CTF 2022 writeup", "url": "/posts/ASIS-CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-10-15 15:59:00 +0900", "snippet": "初めにASISです。祭りと被って死ぬかと思いましたまる。。[crypto] Binned　[148 solve]chall#!/usr/bin/env python3from Crypto.Util.number import *from gensafeprime import *from flag import flagdef keygen(nbit):\tp, q = [generate(nbit) for _ in range(2)]\treturn (p, q)def encrypt(m, pubkey):\treturn pow(pubkey + 1, m, pubkey ** 3)p, q = keygen(512)n = p * qflag = bytes_to_long(flag)enc = encrypt(flag, n)print(f'pubkey = {n}')print(f'enc = {enc}')solveencryptで$enc = (pubkey+1)^m \\pmod {pubkey^3}$ で暗号されているので式変形を施す。\\(enc =(pub+1)^m \\pmod {pub^3} \\\\= \\sum_{i=0}^m \\ _m C_i(pub^i+1^{m-i}) \\pmod {pub^3}\\\\= 1 +m*pub + \\frac{m*(m-1)}{2}pub^2\\\\\\)となるので、方程式を解いてやれば$m$が求まる。from Crypto.Util.number import *pubkey = 125004899806380680278294077957993138206121343727674199724251084023100054797391533591150992663742497532376954423241741439218367086541339504325939051995057848301514908377941815605487168789148131591458301036686411659334843972203243490288676763861925647147178902977362125434420265824374952540259396010995154324589enc = 789849126571263315208956108629196540107771075292285804732934458641661099043398300667318883764744131397353851782194467024270666326116745519739176492710750437625345677766980300328542459318943175684941281413218985938348407537978884988013947538034827562329111515306723274989323212194585378159386585826998838542734955059450048745917640814983343040930383529332576453845724747105810109832978045135562492851617884175410194781236450629682032219153517122695586503298477875749138129517477339813480115293124316913331705913455692462482942654717828006590051944205639923326375814299624264826939725890226430388059890231323791398412019416647826367964048142887158552454494856771139750458462334678907791079639005383932256589768726730285409763583606927779418528562990619985840033479201147509241313757191997545174262930707521451438204766627975109619779824255444258160PR.&lt;m,n&gt; = QQ[]polys = [ 2*m*n + (m^2 - m )*n*n - 2 *(enc -1) , pubkey - n,]I = Ideal(polys)ans = I.variety(ring=ZZ)[0]print(ans)m, n = ans[m], ans[n]print(long_to_bytes(m))[crypto] Chaffymasking　[61 solve]chall#!/usr/bin/env python3import numpy as npimport binasciiimport os, sysfrom flag import FLAGdef die(*args):\tpr(*args)\tquit()def pr(*args):\ts = \" \".join(map(str, args))\tsys.stdout.write(s + \"\\n\")\tsys.stdout.flush()def sc(): \treturn sys.stdin.buffer.readline()def pad(inp, length):\tresult = inp + os.urandom(length - len(inp))\treturn resultdef byte_xor(a, b):\treturn bytes(_a ^ _b for _a,_b in zip(a,b)) def chaffy_mask(salt, LTC, m, n):\tq = n ** 2\thalf1_salt = salt[:m // 8]\thalf2_salt = salt[m // 8:]\txor_salts = int.from_bytes(byte_xor(half1_salt, half2_salt), \"big\")\tif xor_salts == 0:\t\thalf1_salt = byte_xor(half1_salt, os.urandom(m))\thalf1_binStr = \"{:08b}\".format(int(half1_salt.hex(),16))\tif(len(half1_binStr) &lt; m):\t\thalf1_binStr = \"0\" * (m - len(half1_binStr)%m) + half1_binStr\thalf2_binStr = \"{:08b}\".format(int(half2_salt.hex(),16))\tif(len(half2_binStr) &lt; m):\t\thalf2_binStr = \"0\" * (m - len(half2_binStr)%m) + half2_binStr\t\tvec_1 = np.array(list(half1_binStr), dtype=int)\tvec_1 = np.reshape(vec_1, (m,1))\tvec_2 = np.array(list(half2_binStr), dtype=int)\tvec_2 = np.reshape(vec_2, (m,1))\t\tout_1 = LTC.dot(vec_1) % q\tout_2 = LTC.dot(vec_2) % q\t\tflag_vector = np.array([ord(i) for i in FLAG])\tflag_vector = np.reshape(flag_vector, (n,1))\tmasked_flag = (flag_vector ^ out_1 ^ out_2) % 256\tmasked_flag = np.reshape(masked_flag, (n,))\tmasked_flag = ''.join([hex(_)[2:].zfill(2) for _ in masked_flag])\treturn masked_flag.encode('utf-8')def main():\tborder = \"|\"\tpr(border*72)\tpr(border, \" Welcome to chaffymask combat, we implemented a masking method to \", border)\tpr(border, \" hide our secret. Masking is done by your 1024 bit input salt. Also \", border)\tpr(border, \" I noticed that there is a flaw in my method. Can you abuse it and \", border)\tpr(border, \" get the flag? In each step you should send salt and get the mask. \", border)\tpr(border*72)\tm, n = 512, 64 \tIVK = [\t3826, 476, 3667, 2233, 1239, 1166, 2119, 2559, 2376, 1208, 2165, 2897, 830, 529, 346, 150, 2188, 4025, \t3667, 1829, 3987, 952, 3860, 2574, 959, 1394, 1481, 2822, 3794, 2950, 1190, 777, 604, 82, 49, 710, 1765, \t3752, 2970, 952, 803, 873, 2647, 2643, 1096, 1202, 2236, 1492, 3372, 2106, 1868, 535, 161, 3143, 3370, \t1, 1643, 2147, 2368, 3961, 1339, 552, 2641, 3222, 2505, 3449, 1540, 2024, 618, 1904, 314, 1306, 3173, \t4040, 1488, 1339, 2545, 2167, 394, 46, 3169, 897, 4085, 4067, 3461, 3444, 118, 3185, 2267, 3239, 3612, \t2775, 580, 3579, 3623, 1721, 189, 650, 2755, 1434, 35, 3167, 323, 589, 3410, 652, 2746, 2787, 3665, 828, \t3200, 1450, 3147, 720, 3741, 1055, 505, 2929, 1423, 3629, 3, 1269, 4066, 125, 2432, 3306, 4015, 2350, \t2154, 2623, 1304, 493, 763, 1765, 2608, 695, 30, 2462, 294, 3656, 3231, 3647, 3776, 3457, 2285, 2992, \t3997, 603, 2342, 2283, 3029, 3299, 1690, 3281, 3568, 1927, 2909, 1797, 1675, 3245, 2604, 1272, 1146, \t3301, 13, 3712, 2691, 1097, 1396, 3694, 3866, 2066, 1946, 3476, 1182, 3409, 3510, 2920, 2743, 1126, 2154, \t3447, 1442, 2021, 1748, 1075, 1439, 3932, 3438, 781, 1478, 1708, 461, 50, 1881, 1353, 2959, 1225, 1923, \t1414, 4046, 3416, 2845, 1498, 4036, 3899, 3878, 766, 3975, 1355, 2602, 3588, 3508, 3660, 3237, 3018, \t1619, 2797, 1823, 1185, 3225, 1270, 87, 979, 124, 1239, 1763, 2672, 3951, 984, 869, 3897, 327, 912, 1826, \t3354, 1485, 2942, 746, 833, 3968, 1437, 3590, 2151, 1523, 98, 164, 3119, 1161, 3804, 1850, 3027, 1715, \t3847, 2407, 2549, 467, 2029, 2808, 1782, 1134, 1953, 47, 1406, 3828, 1277, 2864, 2392, 3458, 2877, 1851, \t1033, 798, 2187, 54, 2800, 890, 3759, 4085, 3801, 3128, 3788, 2926, 1983, 55, 2173, 2579, 904, 1019, \t2108, 3054, 284, 2428, 2371, 2045, 907, 1379, 2367, 351, 3678, 1087, 2821, 152, 1783, 1993, 3183, 1317, \t2726, 2609, 1255, 144, 2415, 2498, 721, 668, 355, 94, 1997, 2609, 1945, 3011, 2405, 713, 2811, 4076, \t2367, 3218, 1353, 3957, 2056, 881, 3420, 1994, 1329, 892, 1577, 688, 134, 371, 774, 3855, 1461, 1536, \t1824, 1164, 1675, 46, 1267, 3652, 67, 3816, 3169, 2116, 3930, 2979, 3166, 3944, 2252, 2988, 34, 873, \t1643, 1159, 2822, 1235, 2604, 888, 2036, 3053, 971, 1585, 2439, 2599, 1447, 1773, 984, 261, 3233, 2861, \t618, 465, 3016, 3081, 1230, 1027, 3177, 459, 3041, 513, 1505, 3410, 3167, 177, 958, 2118, 326, 31, 2663, \t2026, 2549, 3026, 2364, 1540, 3236, 2644, 4050, 735, 280, 798, 169, 3808, 2384, 3497, 1759, 2415, 3444, \t1562, 3472, 1151, 1984, 2454, 3167, 1538, 941, 1561, 3071, 845, 2824, 58, 1467, 3807, 2191, 1858, 106, \t3847, 1326, 3868, 2787, 1624, 795, 3214, 1932, 3496, 457, 2595, 3043, 772, 2436, 2160, 3428, 2005, 2597, \t1932, 101, 3528, 1698, 3663, 900, 3298, 1872, 1179, 3987, 3695, 3561, 1762, 3785, 3005, 2574, 6, 1524, \t2738, 1753, 2350, 558, 800, 3782, 722, 886, 2176, 3050, 221, 1925, 564, 1271, 2535, 3113, 1310, 2098, \t3011, 964, 3281, 6, 1326, 741, 189, 2632, 373, 1176, 548, 64, 1445, 2376, 1524, 2690, 1316, 2304, 1336, \t2257, 3227, 2542, 3911, 3460\t]\tLTC = np.zeros([n, m], dtype=(int))\tLTC[0,:] = IVK\tfor i in range(1, n):\t\tfor j in range(m // n + 1):\t\t\tLTC[i,j*n:(j+1)*n] = np.roll(IVK[j*n:(j+1)*n], i)\tfor _ in range(5):\t\tpr(border, \"Give me your salt: \")\t\tSALT = sc()[:-1]\t\tSALT = pad(SALT, m // 4)\t\tMASKED_FLAG = chaffy_mask(SALT, LTC, m, n)\t\tpr(border, f'masked_flag = {MASKED_FLAG}')if __name__ == '__main__':\tmain()solve気にすべきなのは、ランダムが入る部分の以下の二か所def pad(inp, length):\tresult = inp + os.urandom(length - len(inp))\treturn result\t# line 33xor_salts = int.from_bytes(byte_xor(half1_salt, half2_salt), \"big\")if xor_salts == 0: half1_salt = byte_xor(half1_salt, os.urandom(m))pad関数は$length = len(inp)$でランダム性が消去でき、xor_saltsは $half1salt \\neq half2salt$にすればいい。あとはMITHみたく上から$out1 ,out2$が、下から$maskedflag$が求まるので順に逆算して以下のxorで答えを出せばいいmasked_flag = (flag_vector ^ out_1 ^ out_2) % 256ただ、なんで5回もリクエストを受付してるのか…import numpy as npimport binasciiimport os, sysfrom pwn import *io = remote(\"65.21.255.31\" ,31377)# io = process([\"python3\",'chaffymasking.py'])io.recvuntil(b\"| Gi\")def send(slt): io.recvline() io.sendline(slt) # print(io.recvline()) # io.interactive() masked_flag = eval(io.recvline(None).decode()[16:]) return masked_flagm, n = 512, 64 IVK = [\t3826, 476, 3667, 2233, 1239, 1166, 2119, 2559, 2376, 1208, 2165, 2897, 830, 529, 346, 150, 2188, 4025, \t3667, 1829, 3987, 952, 3860, 2574, 959, 1394, 1481, 2822, 3794, 2950, 1190, 777, 604, 82, 49, 710, 1765, \t3752, 2970, 952, 803, 873, 2647, 2643, 1096, 1202, 2236, 1492, 3372, 2106, 1868, 535, 161, 3143, 3370, \t1, 1643, 2147, 2368, 3961, 1339, 552, 2641, 3222, 2505, 3449, 1540, 2024, 618, 1904, 314, 1306, 3173, \t4040, 1488, 1339, 2545, 2167, 394, 46, 3169, 897, 4085, 4067, 3461, 3444, 118, 3185, 2267, 3239, 3612, \t2775, 580, 3579, 3623, 1721, 189, 650, 2755, 1434, 35, 3167, 323, 589, 3410, 652, 2746, 2787, 3665, 828, \t3200, 1450, 3147, 720, 3741, 1055, 505, 2929, 1423, 3629, 3, 1269, 4066, 125, 2432, 3306, 4015, 2350, \t2154, 2623, 1304, 493, 763, 1765, 2608, 695, 30, 2462, 294, 3656, 3231, 3647, 3776, 3457, 2285, 2992, \t3997, 603, 2342, 2283, 3029, 3299, 1690, 3281, 3568, 1927, 2909, 1797, 1675, 3245, 2604, 1272, 1146, \t3301, 13, 3712, 2691, 1097, 1396, 3694, 3866, 2066, 1946, 3476, 1182, 3409, 3510, 2920, 2743, 1126, 2154, \t3447, 1442, 2021, 1748, 1075, 1439, 3932, 3438, 781, 1478, 1708, 461, 50, 1881, 1353, 2959, 1225, 1923, \t1414, 4046, 3416, 2845, 1498, 4036, 3899, 3878, 766, 3975, 1355, 2602, 3588, 3508, 3660, 3237, 3018, \t1619, 2797, 1823, 1185, 3225, 1270, 87, 979, 124, 1239, 1763, 2672, 3951, 984, 869, 3897, 327, 912, 1826, \t3354, 1485, 2942, 746, 833, 3968, 1437, 3590, 2151, 1523, 98, 164, 3119, 1161, 3804, 1850, 3027, 1715, \t3847, 2407, 2549, 467, 2029, 2808, 1782, 1134, 1953, 47, 1406, 3828, 1277, 2864, 2392, 3458, 2877, 1851, \t1033, 798, 2187, 54, 2800, 890, 3759, 4085, 3801, 3128, 3788, 2926, 1983, 55, 2173, 2579, 904, 1019, \t2108, 3054, 284, 2428, 2371, 2045, 907, 1379, 2367, 351, 3678, 1087, 2821, 152, 1783, 1993, 3183, 1317, \t2726, 2609, 1255, 144, 2415, 2498, 721, 668, 355, 94, 1997, 2609, 1945, 3011, 2405, 713, 2811, 4076, \t2367, 3218, 1353, 3957, 2056, 881, 3420, 1994, 1329, 892, 1577, 688, 134, 371, 774, 3855, 1461, 1536, \t1824, 1164, 1675, 46, 1267, 3652, 67, 3816, 3169, 2116, 3930, 2979, 3166, 3944, 2252, 2988, 34, 873, \t1643, 1159, 2822, 1235, 2604, 888, 2036, 3053, 971, 1585, 2439, 2599, 1447, 1773, 984, 261, 3233, 2861, \t618, 465, 3016, 3081, 1230, 1027, 3177, 459, 3041, 513, 1505, 3410, 3167, 177, 958, 2118, 326, 31, 2663, \t2026, 2549, 3026, 2364, 1540, 3236, 2644, 4050, 735, 280, 798, 169, 3808, 2384, 3497, 1759, 2415, 3444, \t1562, 3472, 1151, 1984, 2454, 3167, 1538, 941, 1561, 3071, 845, 2824, 58, 1467, 3807, 2191, 1858, 106, \t3847, 1326, 3868, 2787, 1624, 795, 3214, 1932, 3496, 457, 2595, 3043, 772, 2436, 2160, 3428, 2005, 2597, \t1932, 101, 3528, 1698, 3663, 900, 3298, 1872, 1179, 3987, 3695, 3561, 1762, 3785, 3005, 2574, 6, 1524, \t2738, 1753, 2350, 558, 800, 3782, 722, 886, 2176, 3050, 221, 1925, 564, 1271, 2535, 3113, 1310, 2098, \t3011, 964, 3281, 6, 1326, 741, 189, 2632, 373, 1176, 548, 64, 1445, 2376, 1524, 2690, 1316, 2304, 1336, \t2257, 3227, 2542, 3911, 3460\t]LTC = np.zeros([n, m], dtype=(int))LTC[0,:] = IVKfor i in range(1, n):\tfor j in range(m // n + 1):\t\tLTC[i,j*n:(j+1)*n] = np.roll(IVK[j*n:(j+1)*n], i)def byte_xor(a, b):\treturn bytes(_a ^ _b for _a,_b in zip(a,b)) def pad(inp, length):\tassert len(inp) == length\tresult = inp + os.urandom(length - len(inp))\treturn resultdef make_chaffy_mask(salt, LTC, m, n):\tq = n ** 2\thalf1_salt = salt[:m // 8]\thalf2_salt = salt[m // 8:]\txor_salts = int.from_bytes(byte_xor(half1_salt, half2_salt), \"big\")\tif xor_salts == 0:\t\treturn None,None\t\t# half1_salt = byte_xor(half1_salt, os.urandom(m))\thalf1_binStr = \"{:08b}\".format(int(half1_salt.hex(),16))\tif(len(half1_binStr) &lt; m):\t\thalf1_binStr = \"0\" * (m - len(half1_binStr)%m) + half1_binStr\thalf2_binStr = \"{:08b}\".format(int(half2_salt.hex(),16))\tif(len(half2_binStr) &lt; m):\t\thalf2_binStr = \"0\" * (m - len(half2_binStr)%m) + half2_binStr\t\tvec_1 = np.array(list(half1_binStr), dtype=int)\tvec_1 = np.reshape(vec_1, (m,1))\tvec_2 = np.array(list(half2_binStr), dtype=int)\tvec_2 = np.reshape(vec_2, (m,1))\t\tout_1 = LTC.dot(vec_1) % q\tout_2 = LTC.dot(vec_2) % q\treturn out_1, out_2def mith(mask_enc,out1,out2):\tenc = []\tfor i in range(0,len(mask_enc)//2):\t\tprint(i,mask_enc[2*i:2*(i+1)])\t\t\ttmp = int(mask_enc[2*i:2*(i+1)],16)\t\tenc.append(tmp)\tenc_vector = np.array(enc)\tenc_vector = np.reshape(enc_vector, (n,1))\tans_vec = (enc_vector^out1^out2)%256\tans_vec = np.reshape(ans_vec, (n))\tans = [chr(i) for i in ans_vec]\tprint(\"\".join(ans))SALT = os.urandom(m // 4)salt = pad(SALT, m // 4)out1,out2 = make_chaffy_mask(salt, LTC, m, n)enc = send(SALT)mith(enc.decode(),out1,out2)# ASIS{Lattice_based_hash_collision_it_was_sooooooooooooooo_easY!}[crypto] Mariana [56 solve]chall#!/usr/bin/env python3from Crypto.Util.number import *import sys# from flag import flagdef die(*args):\tpr(*args)\tquit()def pr(*args):\ts = \" \".join(map(str, args))\tsys.stdout.write(s + \"\\n\")\tsys.stdout.flush()def sc():\treturn sys.stdin.buffer.readline()def main():\tborder = \"|\"\tpr(border*72)\tpr(border, \"Welcome to MARIANA cryptography battle, the mission is solving super\", border)\tpr(border, \"hard special DLP problem in real world, are you ready to fight? \", border)\tpr(border*72)\tNBIT = 32\tSTEP = 40\tpr(border, \"In each step solve the given equation and send the solution for x. \", border)\tc = 1\twhile c &lt;= STEP:\t\tnbit = NBIT * c\t\tp = getPrime(nbit)\t\tg = getRandomRange(3, p)\t\tpr(border, f'p = {p}')\t\tpr(border, f'g = {g}')\t\tpr(border, 'Send the solution x = ')\t\tans = sc()\t\ttry:\t\t\tx = int(ans)\t\texcept:\t\t\tdie(border, 'Given number is not integer!')\t\tif x &gt;= p:\t\t\tdie(border, \"Kidding me!? Your solution must be smaller than p :P\")\t\tif (pow(g, x, p) - x) % p == 0:\t\t\tif c == STEP:\t\t\t\tdie(border, f\"Congratz! the flag is: {flag}\")\t\t\telse:\t\t\t\tpr(border, \"Good job, try to solve the next level!\")\t\t\t\tc += 1\t\telse:\t\t\tdie(border, \"Try harder and smarter to find the solution!\")if __name__ == '__main__':\tmain()solveなにも考えずに、条件で$x &lt; p$ が通ることが確認できるので、 $1-p$投げておしまいです。from pwn import *io = remote(\"65.21.255.31\" ,32066)io.recvuntil(b\"x. |\")print(io.recvline())ps = []gs = []anss = 1cnt = 1while cnt &lt; 40: # recv p = int(io.recvline(None).decode()[5:]) g = int(io.recvline(None).decode()[5:]) ps.append(p) gs.append(g) io.recvline() # calc ans = 1-p io.sendline(str(ans).encode()) result = io.recvline() print(\"[+] result... \",result) if b\"ASIS\" in result: exit()# ASIS{fiX3d_pOIn7s_f0r_d!5Cret3_l0g4riThmS!}[crypto] Mindseat [33 solve]chall#!/usr/bin/env python3from Crypto.Util.number import *from secret import params, flagdef keygen(nbit, k): # Pubkey function\t_p = 1\twhile True:\t\tp, q = [_p + (getRandomNBitInteger(nbit - k) &lt;&lt; k) for _ in '01']\t\tif isPrime(p) and isPrime(q):\t\t\twhile True:\t\t\t\ts = getRandomRange(2, p * q)\t\t\t\tif pow(s, (p - 1) // 2, p) * pow(s, (q - 1) // 2, q) == (p - 1) * (q - 1):\t\t\t\t\tpubkey = p * q, s\t\t\t\t\treturn pubkeydef encrypt(pubkey, m):\tn, s = pubkey\tr = getRandomRange(2, n)\treturn pow(s, m, n) * pow(r, 2 ** k, n) % nflag = flag.lstrip(b'ASIS{').rstrip(b'}')nbit, k = paramsPUBKEYS = [keygen(nbit, k) for _ in range(4)]flag = [bytes_to_long(flag[i*8:i*8 + 8]) for i in range(4)]ENCS = [encrypt(PUBKEYS[_], flag[_]) for _ in range(4)]print(f'PUBKEYS = {PUBKEYS}')print(f'ENCS = {ENCS}')solve今回の時間食った元凶君(まじで)さておき、この問題は2 パートに分かれます $n$から$p,q$の復元 $enc = s^m * r^{2 ^ k} \\pmod n$ から $m$ の復元part 1手始めにgetRandomNBitIntegerの $k$ の値を知る必要があるが、単純に $p*q = (r_p*2^k+1)*(r_q*2^k+1) $ を考えれば、$ n$ の下位ビットを見て$0$ が続く長さを考えれば $k$ の値を決め打ちできる。今回は $134$ だった。それにより $r_p,r_q$ の長さも見えてくる。$n$ が$512$ビットより$p,q$ のそれぞれの乱数部分の長さは $256-k$ ビットとなり。defundパイセンのcoppersmithで復元できる。def dec_para(PUB,ENC): N,s = PUB k = 134 P.&lt;x, y&gt; = PolynomialRing(Zmod(N)) _p = 1 poly3 = (x*2^k + _p)*(y*2^k + _p) bounds = (2^(256-k), 2^(256-k)) roots = small_roots(poly3, bounds, m=2, d=2)[0] print(roots) p = roots[0]*2^k + _p q = roots[1]*2^k + _p assert isPrime(int(p)) assert isPrime(int(q)) assert p*q==Npart 2$enc = s^m * r^{2 ^ k} \\pmod n$ より $r$ が邪魔なので$enc^{\\frac{\\phi(n)}{2^k}} = s^{\\frac{m\\phi(n)}{2^k}} * r^{\\phi(n)} \\pmod n = s^{\\frac{m\\phi(n)}{2^k}} \\pmod n$ になり、dis_cretelogで求めてしまい。今回は、念のため $p,q$分けて行った。def decrypt(p,q,s,c): n = p*q k =134 phi = (p-1)*(q-1) e = pow(2,k) e_ = int(p-1)//int(e) m = discrete_log(GF(p)(c)^e_,GF(p)(s)^e_, operation=\"*\") print(long_to_bytes(m)) return long_to_bytes(m)from Crypto.Util.number import *import itertoolsPUBKEYS = [(10342840547250370454282840290754052390564265157174829726645242904324433774727630591803186632486959590968595230902808369991240437077297674551123187830095873, 5179654005441544601140101875149402241567866059199512232495766031194848985776186595289740052214499657697650832860279375151687044465018028876445070588827777), (6015512135462554031390611730578383462516861987731833360559070749140159284050335604168414434218196369921956160353365713819898567416920672209509202941444097, 2116441415129068001049624780654272734931672052541246678702416144768611225693039503554945326959705314527114860312641379671935648337975482830939466425225421), (6396980904648302374999086102690071222661654639262566535518341836426544747072554109709902085144158785649143907600058913175220229111171441332366557866622977, 1760317994074087854211747561546045780795134924237097786412713825282874589650448491771874326890983429137451463523250670379970999252639812107914977960011738), (9158217300815233129401608406766983222991414185115152402477702381950519098200234724856258589693986849049556254969769863821366592458050807400542885348638721, 6564146847894132872802575925374338252984765675686108816080170162797938388434600448954826704720292576935713424103133182090390089661059813982670332877677256)]ENCS = [4595268033054096192076432659360373235610019564489694608733743330870893803828258295069937060360520598446948290913045781945314108935153236291467160667601985, 3390637292181370684803039833768819598968576813582112632809296088618666221278429695211004046274005776653775480723833818255766663573061866194380012311184611, 5197599582013327040903216369733466147938613487439777125659892779696104407398257678982801768761973934713675657188014051286238194316997970299887749668838196, 5093835186720390391696398671365109925058893544530286148616117890366909889206952477053316867658405460457795493886317792695055944930027477761411273933822112]def small_roots(f, bounds, m=1, d=None):\tif not d:\t\td = f.degree()\tR = f.base_ring()\tN = R.cardinality()\t\tf /= f.coefficients().pop(0)\tf = f.change_ring(ZZ)\tG = Sequence([], f.parent())\tfor i in range(m+1):\t\tbase = N^(m-i) * f^i\t\tfor shifts in itertools.product(range(d), repeat=f.nvariables()):\t\t\tg = base * prod(map(power, f.variables(), shifts))\t\t\tG.append(g)\tB, monomials = G.coefficient_matrix()\tmonomials = vector(monomials)\tfactors = [monomial(*bounds) for monomial in monomials]\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, factor)\tB = B.dense_matrix().LLL()\tB = B.change_ring(QQ)\tfor i, factor in enumerate(factors):\t\tB.rescale_col(i, 1/factor)\tH = Sequence([], f.parent().change_ring(QQ))\tfor h in filter(None, B*monomials):\t\tH.append(h)\t\tI = H.ideal()\t\tif I.dimension() == -1:\t\t\tH.pop()\t\telif I.dimension() == 0:\t\t\troots = []\t\t\tfor root in I.variety(ring=ZZ):\t\t\t\troot = tuple(R(root[var]) for var in f.variables())\t\t\t\troots.append(root)\t\t\treturn roots\treturn []def decrypt(p,q,s,c): n = p*q k =134 phi = (p-1)*(q-1) e = pow(2,k) e_ = int(p-1)//int(e) m = discrete_log(GF(p)(c)^e_,GF(p)(s)^e_, operation=\"*\") print(long_to_bytes(m)) return long_to_bytes(m)def dec_para(PUB,ENC): N,s = PUB k = 134 P.&lt;x, y&gt; = PolynomialRing(Zmod(N)) _p = 1 poly3 = (x*2^k + _p)*(y*2^k + _p) bounds = (2^(256-k), 2^(256-k)) roots = small_roots(poly3, bounds, m=2, d=2)[0] print(roots) p = roots[0]*2^k + _p q = roots[1]*2^k + _p assert isPrime(int(p)) assert isPrime(int(q)) assert p*q==N return decrypt(int(p),int(q),int(s),int(ENC)) flag = b\"\"for i in range(4): flag +=dec_para(PUBKEYS[i],ENCS[i]) print(b\"ASIS{\"+flag+b\"}\")# ASIS{N3w_CTF_nEW_Joye_Libert_CrYpt0_5}[crypto] Desired curve　[16 solve]chall#!/usr/bin/env sageimport sysfrom Crypto.Util.number import *from flag import flagdef die(*args):\tpr(*args)\tquit()def pr(*args):\ts = \" \".join(map(str, args))\tsys.stdout.write(s + \"\\n\")\tsys.stdout.flush()def sc():\treturn sys.stdin.buffer.readline()def main():\tborder = \"|\"\tpr(border*72)\tpr(border, \"Hi all, now it's time to solve a relatively simple challenge about \", border)\tpr(border, \"relatively elliptic curves! We will generate an elliptic curve with \", border)\tpr(border, \"your desired parameters, are you ready!? \", border)\tpr(border*72)\tnbit = 256\tq = getPrime(nbit)\tF = GF(q)\twhile True:\t\tpr(border, \"Send the `y' element of two points in your desired elliptic curve: \")\t\tans = sc()\t\ttry:\t\t\ty1, y2 = [int(_) % q for _ in ans.split(b',')]\t\texcept:\t\t\tdie(border, \"Your parameters are not valid! Bye!!\")\t\tA = (y1**2 - y2**2 - 1337**3 + 31337**3) * inverse(-30000, q) % q\t\tB = (y1**2 - 1337**3 - A * 1337) % q\t\tE = EllipticCurve(GF(q), [A, B])\t\tG = E.random_point()\t\tm = bytes_to_long(flag)\t\tassert m &lt; q\t\tC = m * G\t\tpr(border, f'The parameters and encrypted flag are:')\t\tpr(border, f'q = {q}')\t\tpr(border, f'G = ({G.xy()[0]}, {G.xy()[1]})')\t\tpr(border, f'm * G = ({C.xy()[0]}, {C.xy()[1]})')\t\tpr(border, f'Now find the flag :P')if __name__ == '__main__':\tmain()solveやることは簡単で、 invalid curve attack でsubgroupのオーダーが小さいものを見つける。 それを、集めてCRTで復元する。from pwn import *from timeout_decorator import timeoutfrom random import randintfrom Crypto.Util.number import *io = remote(\"65.21.255.31\" ,10101)io.recvuntil(b\"| Se\")def send(y1,y2): io.recvline() io.sendline((str(y1)+\",\"+str(y2)).encode()) io.recvline() q = int(io.recvline(None).decode()[5:]) G = io.recvline(None).decode()[2+4+1:].split(\",\") mG = io.recvline(None).decode()[2+8+1:].split(\",\") Gx = int(G[0]) Gy = int(G[1].replace(\")\",\"\")) mGx = int(mG[0]) mGy = int(mG[1].replace(\")\",\"\")) io.recvline() return q , (Gx,Gy) ,(mGx,mGy)# I adjusted to https://furutsuki.hatenablog.com/entry/2020/05/05/112207def search_para(P): @timeout(10, timeout_exception=Exception, use_signals=False) def factorize(n): return prime_factors(n) F = GF(P) while True: y1 = randint(2,P-1) y2 = randint(2,P-1) A = (y1**2 - y2**2 - 1337**3 + 31337**3) * pow(-30000,-1, q) % q B = (y1**2 - 1337**3 - A * 1337) % q EC = EllipticCurve(F, [A, B]) order = EC.order() try: factors = factorize(order) except Exception: continue suborder = 1 for f in factors: if f &lt; 10**10: suborder = f else: break g = EC.gen(0) * int(order // suborder) # print({ # \"generator\": g.xy(), # \"order\": suborder, # \"y1\": y1, # \"y2\":y2, # \"q\": q, # }, \",\") return y1,y2,subordery1,y2 = 1,1q, G, mG= send(y1,y2)A = (y1**2 - y2**2 - 1337**3 + 31337**3) * pow(-30000,-1, q) % qB = (y1**2 - 1337**3 - A * 1337) % qE = EllipticCurve(GF(q),[A,B])dlog = []odr = []phimation = 1while True: y1,y2,suborder = search_para(q) q, G, mG= send(y1,y2) A = (y1**2 - y2**2 - 1337**3 + 31337**3) * pow(-30000,-1, q) % q B = (y1**2 - 1337**3 - A * 1337) % q E = EllipticCurve(GF(q),[A,B]) G = E(G) mG = E(mG) phimation *= suborder print(\"[*] subord =\", suborder) print(\"[*] persentage =\", (100*int(phimation).bit_length())//int(E.order()).bit_length(),\"%\") print(\"[*] start dlog\") dlog.append(discrete_log(mG*(E.order()//suborder),G*(E.order()//suborder), operation=\"+\",ord=E.order())) odr.append(suborder) m = long_to_bytes(int(CRT(dlog, odr))) print(\"[+] find dlog ...\",m, end = \"\\n\\n\") if b\"ASIS\" in m: exit()# ASIS{(e$l6LH_JfsJ:~&lt;}1v&amp;}" }, { "title": "GDG Algiers CTF 2022 writeup", "url": "/posts/GDG_Algiers_CTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-10-10 02:00:00 +0900", "snippet": "初めにSEKAICTFで疲れたので息抜きに…[crypto] The_Messagerchallfrom Crypto.Util.number import bytes_to_long, getStrongPrimefrom math import gcdfrom flag import FLAGfrom Crypto.Random import get_random_bytesdef encrypt(m): return pow(m,e,N)e = 65537p = getStrongPrime(512)q = getStrongPrime(512)# generate secure keysresult = 0while (result !=1): p = getStrongPrime(512) q = getStrongPrime(512) result = gcd(e,(p-1)*(q-1)) \tN = p * qprint(\"N = \" + str(N))print(\"e = \" + str(e))ct= []for car in FLAG:\tct.append(encrypt(car))print(\"ct = \"+str(ct))solve$p,q$が512bitからなる素因数分解は結構だるいので、逆から考える。フラグの文字列におけるASCIIの範囲が$0x20-0x7f$までであることを利用し1文字づつ復号しておしまい。N = 98104793775314212094769435239703971612667878931942709323496314311667226421821897454047455384364608911477616865967419199078405667657976292973268348872702988831334377069809925141829484522654208638838107410232921531587371072553811548927714437673444716295120279177952417246053452081185183736591850104338774924467e = 65537ct = [snipped...]from Crypto.Util.number import bytes_to_long, getStrongPrimefrom math import gcdfrom Crypto.Random import get_random_bytesm = \"\"for c in ct: for i in range(0x20,0x7f): if c == pow(i,e,N): m+=chr(i) print(m)# CyberErudites{RSA_1S_S1MPL3}[crypto] The Matrixchallimport jsonfrom os import urandomfrom Crypto.Hash import SHA256from Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom sage.all import *from Crypto.Util.number import getPrimefrom random import randintp = getPrime(64)def read_matrix(file_name): data = open(file_name, 'r').read().strip() rows = [list(eval(row)) for row in data.splitlines()] return Matrix(GF(p), rows)def encrypt(plaintext,key): iv = urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) ciphertext = cipher.encrypt(pad(plaintext,16)) return iv,ciphertextG = read_matrix('matrix.txt')priv = randint(1,p-1)pub = G**privkey = SHA256.new(data=str(priv).encode()).digest()[:2**8]flag = b'CyberErudites{???????????????????????????????}'iv,encrypted_flag = encrypt(flag,key)with open('public_key.txt', 'wb') as f: for i in range(N): f.write((str(list(pub[i])).encode())+b'\\n')json.dump({ \"iv\": iv.hex(), \"ciphertext\": encrypted_flag.hex(), \"p\":str(p)}, open('encrypted_flag.txt', 'w'))solve正方行列における離散対数問題を解くシンプルな問題。そもそもとして、離散対数問題は基本的に解くのは難関だが、ある条件下において容易化する。今回の場合それに当てはまり、ジョルダン標準形を用いて簡単に行う。ある行列$G, P$を用いて$ G = P^{-1}*G_j*P $というジョルダン標準形を構成する。このとき$ A = G^{priv} $は$ A = P^{-1}*G_j^{priv}*P $となり、$G_j$が三角行列(今回の場合は対角行列)であることを考えると$A_{-1,-1} = G_{-1,-1}^{priv} \\pmod p$であることより、行列の離散対数問題は素体上の離散対数問題に落ち容易に求められる。import jsonfrom os import urandomfrom Crypto.Hash import SHA256from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom sage.all import *from Crypto.Util.number import getPrimefrom random import randintiv = bytes.fromhex(\"c534df3e87713beace67144f85aca107\")ciphertext = bytes.fromhex(\"c843230a54cc51d7b7ce2b47b0da5f8b98a04c3baad4bdae20f3fdcb5747f81c34a6962aef330f0d244116650c4305fd\")p = 12143520799543738643def read_matrix(file_name): data = open(file_name, 'r').read().strip() rows = [list(eval(row)) for row in data.splitlines()] return Matrix(GF(p), rows)def decrypt(ct,key,iv): cipher = AES.new(key, AES.MODE_CBC, iv) pt = unpad(cipher.decrypt(ct),16) return pt_G = read_matrix('matrix.txt')Gj, P = _G.jordan_form(transformation=True)_pub = read_matrix(\"public_key.txt\")G_jordan = P.inverse()*_G*Ppub_jordan = P.inverse()*_pub*Pprint(G_jordan)print(pub_jordan)print(discrete_log(pub_jordan[-1][-1],G_jordan[-1][-1]))priv = 7619698002081645976assert _G**priv == _pubkey = SHA256.new(data=str(priv).encode()).digest()[:2**8]print(decrypt(ciphertext,key,iv))# b'CyberErudites{Di4g0n4l1zabl3_M4tric3s_d4_b3st}'[crypto] Eddychallfrom pure25519.basic import (bytes_to_clamped_scalar,scalar_to_bytes, bytes_to_scalar, bytes_to_element, Base)import hashlib, binasciiimport osdef H(m): return hashlib.sha512(m).digest()def publickey(seed): # turn first half of SHA512(seed) into scalar, then into point assert len(seed) == 32 a = bytes_to_clamped_scalar(H(seed)[:32]) A = Base.scalarmult(a) return A.to_bytes()def Hint(m): h = H(m) return int(binascii.hexlify(h[::-1]), 16)def signature(m, sk, pk): assert len(sk) == 32 # seed assert len(pk) == 32 h = H(sk[:32]) a_bytes, inter = h[:32], h[32:] a = bytes_to_clamped_scalar(a_bytes) r = Hint(inter + m) R = Base.scalarmult(r) R_bytes = R.to_bytes() S = r + Hint(R_bytes + pk + m) * a e = Hint(R_bytes + pk + m) return R_bytes, S, edef checkvalid(s, m, pk): if len(s) != 64: raise Exception(\"signature length is wrong\") if len(pk) != 32: raise Exception(\"public-key length is wrong\") R = bytes_to_element(s[:32]) A = bytes_to_element(pk) S = bytes_to_scalar(s[32:]) h = Hint(s[:32] + pk + m) v1 = Base.scalarmult(S) v2 = R.add(A.scalarmult(h)) return v1 == v2def create_signing_key(): seed = os.urandom(32) return seeddef create_verifying_key(signing_key): return publickey(signing_key)#!/usr/bin/python3import sysfrom challenge import *from Crypto.Util.number import *with open(\"flag.txt\",\"r\") as f: flag = f.read()flag = flag.encode()sk = create_signing_key()pk = create_verifying_key(sk)R_flag,S_flag,e_flag = signature(flag,sk,pk)def start(): print(\"Welcom to my singing server !\") print(\"-\" * 10 + \"Menu\" + \"-\" * 10) print(\"1- Sign a message with a random private key \") print(\"2- Sign a message with your private key \") print(\"3- Verify the flag\") print(\"4- Quit\") print(\"-\" * 24) try: while True: c = input(\"&gt; \") if c == '1': msg =input(\"Enter your message : \").encode() pk = create_verifying_key(sk) R,S,e = signature(msg,sk,pk) out = {\"R\":R,\"S\": S,\"e\":e} print(out) elif c == '2': msg = input(\"Enter your message : \").encode() privk = int(input(\"Enter your private key : \")) privk = long_to_bytes(privk) pk = create_verifying_key(privk) R, S, e = signature(msg, sk, pk) out = {\"R\": R, \"S\": S, \"e\": e} print(out) elif c == '3': pk = int(input(\"Enter your public key : \")) pk = long_to_bytes(pk) if checkvalid(R_flag+scalar_to_bytes(S_flag),flag,pk): print(\"You are an admin, Here's your flag \", flag) else: print(\"Sorry , you can't get your flag !\") sys.exit() elif c == '4': print(\"Goodbye :)\") sys.exit() except Exception: print(\"System error.\") sys.exit()start()solveoracle問題で、flagを出すためにはpkを求める必要がある。pkを求めるには、skを求める必要がある。skはランダムな値と、一見求めるのが不可能に思える。def publickey(seed): # turn first half of SHA512(seed) into scalar, then into point assert len(seed) == 32 a = bytes_to_clamped_scalar(H(seed)[:32]) A = Base.scalarmult(a) return A.to_bytes()def signature(m, sk, pk): assert len(sk) == 32 # seed assert len(pk) == 32 --------snipped--------publickey関数とignature関数で比較する。 publickey関数の引数seedにはskの値が入ることを考慮すればsignature関数のaはpkの値になる。よって、次はaからpkを求めればよいことになる。def signature(m, sk, pk): --------snipped-------- h = H(sk[:32]) a_bytes, inter = h[:32], h[32:] a = bytes_to_clamped_scalar(a_bytes) r = Hint(inter + m) R = Base.scalarmult(r) R_bytes = R.to_bytes() S = r + Hint(R_bytes + pk + m) * a e = Hint(R_bytes + pk + m) return R_bytes, S, esignature関数の後半においてS,eが既知であることを用いればaが求まる。bytes_to_clamped_scalar関数(先頭2bitが01,下位3bitは000になるようにする)を戻すものを実装するdef bytes_to_clamped_scalar(s): # Ed25519 private keys clamp the scalar to ensure two things: # 1: integer value is in L/2 .. L, to avoid small-logarithm # non-wraparaound # 2: low-order 3 bits are zero, so a small-subgroup attack won't learn # any information # set the top two bits to 01, and the bottom three to 000 a_unclamped = bytes_to_scalar(s) AND_CLAMP = (1&lt;&lt;254) - 1 - 7 OR_CLAMP = (1&lt;&lt;254) a_clamped = (_unclamped &amp; AND_CLAMP) | OR_CLAMP return a_clamped以上でpkの候補が絞り込めたので確認してflagを取って終わり。面倒なので、候補の1つを入力してだめなら繋ぎ直した。(bruteforceでないのでok)import sysfrom challenge import *from Crypto.Util.number import *from pwn import *m = \"CyberErudites{\"while True: io = remote(\"crypto.chal.ctf.gdgalgiers.com\" ,1000) # io = process([\"python3\",\"server.py\"]) print(io.recvuntil(b\"&gt; \").decode()) io.sendline(b\"1\") pk = io.recvuntil(b\": \").decode() io.sendline(b\"12\") # io.recvline().decode() tmp = io.recvline(None).decode().replace(\"}\",\"\").split(\": \") print(tmp) R = eval(tmp[1][:-5]) s = eval(tmp[2][:-5]) e = eval(tmp[3]) # print(R) # print(s) # print(e) a = s //e # print(bin(a)) # print(s//e) print(a) # rev_bytes_to_clamped_scalar(s): for i in range(2**3): for k in range(2**2): pk = int(bin(k)[2:] + bin(a)[2:]+bin(i)[2:],2) A = Base.scalarmult(a) A2 = bytes_to_long(A.to_bytes()) print(A2) print(io.recvuntil(b\"&gt; \").decode()) io.sendline(b\"3\") print(io.recvuntil(b\": \").decode()) io.sendline(str(A2).encode()) tmp = io.recvline().decode() print(tmp) if tmp.endswith(b\"}\") : print(tmp)# CyberErudites{ed25519_Uns4f3_L1b5}[crypto] Nitrochall#!/usr/bin/sagefrom sage.all import *from nitro import Nitrowith open(\"flag.txt\",\"r\") as f: flag = f.readline()assert len(flag)==32def str2bin(s): return ''.join(bin(ord(i))[2:].zfill(8) for i in s)def main(): print(\"********** NITRO ORCALE **********\") print(\" Welcome to the nitro oracle \") print(\"After getting inspired by some encryption services, i tried to built my own server\") print(\"My idea is based on using polynomials to make an affine encryption\") print(\"Keep in mind that i can only encrypt a specific byte each time\") print(\"You can send me the position of the byte and i send the encrypted byte with the used public key \") N, p, q, d = 8, 2, 29, 2 assert gcd(N, q) == 1 and gcd(p, q) == 1 and q &gt; (6 * d + 1) * p cipher = Nitro(N, p, q, d) print(\"------------------------------\") print(\"| MENU |\") print(\"| a) encrypt the ith byte |\") print(\"| b) exit |\") print(\"------------------------------\") while True: menu= input(\"choose an option \\n\") try: if menu == \"a\": i = int(input(\"enter the byte index: \")) assert i&lt;32 m = list(str2bin(flag[i])) e,h = cipher.encrypt(m) print(e) print(h) elif menu == \"b\": print(\" Good Bye !! \") exit() else: print(\"Error: invalid menu option.\") raise Exception except Exception as ex: print(\"\\nSomething went wrong......try again?\\n\")if __name__ == \"__main__\": main()from sage.all import *class Nitro: f_x = None g_x = None Fp_x = None Fq_x = None hx = None R = None Rq = None Rp = None def __init__(self, N, p, q, d): self.N = N self.p = p self.q = q self.d = d def random_poly(self, N, d1, d2): coef_list = [1] * d1 + [-1] * d2 + [0] * (N - d1 - d2) shuffle(coef_list) return coef_list def keygen(self): RR= ZZ['x'] Cyc = RR([-1]+[0]*(self.N - 1)+[1])#x^N-1 R = RR.quotient(Cyc) Rq = RR.change_ring(Integers(self.q)).quotient(Cyc) Rp = RR.change_ring(Integers(self.p)).quotient(Cyc) while True: try: f_x = R(self.random_poly(self.N, self.d + 1, self.d)) g_x = R(self.random_poly(self.N, self.d, self.d)) Fp_x = Rp(lift(1 / Rp(f_x))) Fq_x = Rq(lift(1 / Rq(f_x))) break except: continue assert Fp_x * f_x == 1 and Fq_x * f_x == 1 h_x = Rq(Fq_x * g_x) self.f_x, self.g_x, self.Fp_x, self.Fq_x, self.h_x = f_x, g_x, Fp_x, Fq_x, h_x self.R, self.Rq, self.Rp = R, Rq, Rp def encrypt(self, m: list): self.keygen() r_x = self.Rq(self.random_poly(self.N, self.d, self.d)) m_x = self.Rp(m) m_x = m_x.lift() m_x = self.Rq(m_x) e_x = self.Rq(self.p * self.h_x * r_x + m_x) return e_x.list(), self.h_x.list()solve剰余環の問題です。まぁ、素数2つ使っているのでNTRUかとは思います。暗号化方針としては、flagを1文字ずつバイナリに変換して$\\mod 2$の多項式にして、$p * h_x * r_x + m_x$ で行っています。そもそもとして、多項式の次数$N$は8なので、ASCII1文字を暗号化することを考えれば$2^8$通り、$r_x$は係数が$-1,0,1$の三種類より$3^8$通りであることを考えれば全探索できる範囲であり、全探索で終わらしてしまった….from sage.all import *from nitro import Nitrofrom pwn import *from Crypto.Util.number import *import collectionsio = remote(\"crypto.chal.ctf.gdgalgiers.com\" ,1001)# io = process([\"python3\",\"nitro_server.py\"])N, p, q, d = 8, 2, 29, 2def str2bin(s): return ''.join(bin(ord(i))[2:].zfill(8) for i in s)def bin2str(s): try: s = [str(i) for i in s] return chr(int(\"\".join(s),2)) except: return Nonedef all_poly( N, d1, d2): coef_list_lists = [] for i in range(3**N): coef_list=[] for k in range(N): if i % 3 == 2: coef_list.append(-1) else: coef_list.append(i % 3) i = i // 3 coef_list_lists.append(coef_list) # print(coef_list_lists) return coef_list_listsdef catch(i): io.recvuntil(b\"choose an option\").decode() io.sendline(b\"a\") io.recvuntil(b\": \") io.sendline(str(i).encode()) e_x = eval( io.recvline(None).decode()) h_x = eval(io.recvline(None).decode()) return e_x,h_xRR= ZZ['x']Cyc = RR([-1]+[0]*(N - 1)+[1])#x^N-1R = RR.quotient(Cyc)Rq = RR.change_ring(Integers(q)).quotient(Cyc)Rp = RR.change_ring(Integers(p)).quotient(Cyc)flag = \"\"for i in range(32): mss = [ [] for _ in range(3)] for m in range(3): e_x,h_x = catch(i) for k,poly in enumerate(all_poly(N ,d ,d)): r_x = Rq(poly) e_x = Rq(e_x) h_x = Rq(h_x) # m_x = Rp(m) # m_x = m_x.lift() # m_x = Rq(m_x) mss[m].append(bin2str(Rq(-1*p * h_x * r_x + e_x).list())) print(collections.Counter(mss[0]+mss[1]+mss[2]).keys()[2])print(flag)# CyberErudites{_NTRU_LLL_4tt4ck_}答え的にはLLLで解けるらしい、後でやってみます。[crypto] franklin-last-wordschallfrom Crypto.Util.number import bytes_to_long, getStrongPrimefrom math import gcdfrom flag import FLAGfrom Crypto.Random import get_random_bytesdef encrypt_message(m): return pow(m,e,N)def advanced_encrypt(a,m):\treturn encrypt_message(pow(a,3,N)+(m &lt;&lt; 24))e = 3p = getStrongPrime(512)q = getStrongPrime(512)# generate secure keysresult = 0while (result !=1): p = getStrongPrime(512) q = getStrongPrime(512) result = gcd(e,(p-1)*(q-1)) \tN = p * qprint(\"N = \" + str(N))print(\"e = \" + str(e))rand = bytes_to_long(get_random_bytes(64))ct = []ct.append(encrypt_message(rand &lt;&lt; 24))for car in FLAG:\tct.append(advanced_encrypt(car,rand))print(\"ct = \"+str(ct))solveThe_Messagerの難度高め?の問題まぁ、名前の通りfranklin-reiter related message attackとは思います。ですが、なんか面倒なので多項式gcdで$ r$ 出して、全探索で終わりです。pgcdの関数はここからお借りしました。すんげ―便利N = 128704452311502431858930198880251272310127835853066867118127724648453996065794849896361864026440048456920428841973494939542251652347755395656512696329757941393301819624888067640984628166587498928291226622894829126692225620665358415985778838076183290137030890396001916620456369124216429276076622486278042629001e = 3ct = [21340757543584301785921441484183053451553315439245254915339588451884106542258661009436759738472587801036386643847752005362980150928908869053740830266273664899424683013780904331345502086236995074501779725358484854206059302399319323859279240268722523450455802058257892548941510959997370995292748578655762731064,----------snipped----------]from Crypto.Util.number import *e = 3pgcd = lambda g1, g2: g1.monic() if not g2 else pgcd(g2, g1%g2) P.&lt;r&gt; = PolynomialRing(Zmod(N))f1 = (bytes_to_long(b\"y\")^3 + r)^3 -ct[2]f2 = (bytes_to_long(b\"C\")^3 + r)^3 -ct[1]re_m2 = pgcd(f1,f2)rnd = N-re_m2[0]m = \"\"for c in ct[1:]: for k in range(0x20,0x7f): if c == pow(k^3+rnd,3,N): m =m+ chr(k)print(m)# CyberErudites{Fr4nkl1n_W3_n33d_an0th3R_S3450N_A54P}" }, { "title": "SEKAI CTF 2022 misc writeup", "url": "/posts/SEKAICTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, writeup", "date": "2022-10-04 01:00:00 +0900", "snippet": "xsxsxsxはじめにSEKAICTFが10/1-10/3までの計48時間で開催されました。ボカロが好きなのもあって色々期待してましたが、UIしかり、問題しかり想像以上でした。そしてSatoooonさんと初チーム「Double Lariat」で組んで出ましたが、ものすごく楽しかったし、面白かったです!!更に結果は16位で上々もいいところでした!!さて前置きはこれくらいにして、今回Cryptoのwriteupは要らないかなと思う(難しいのが解けなかったorz)ので解けたmiscだけでいいですか…?どちらかというと問題の凝り方に感激してたもので…問題ボカロ好きにはたまらない問題セットでした…!!Console Port内容はコンソール版のKeep Talking and Nobody Explodesで、これ作るの大変じゃない???と思いつつ仕様書とにらめっこして解きました。何も変な部分はなかったはずなので、特に気を付けるのは集中力を切らさないことでしたね…flag : SEKAI{SenkouToTomoniHibikuBakuon!}flag見て色々納得したサイバーサンダーサイダー　サイバーサンダーサイダーいいよね～Sus拡張子がsusのファイルを調べると音ゲーの拡張子であることがわかります。しかも、内容は譜面らしくどう読み込ませるのかうなっていたら、名前的になんかこれじゃん的なものを見つけ食わせたらビンゴでした。flag : SEKAI{SbtnFmnW2HnYbdDkryunTkrrtims}flagも音楽の記号?で凝ってましたねVocaloid Heardleflagのmp3とそれを作ったであろうpythonファイルが渡されます。とりあえずflagのmp3を聞いてみると3秒ごとに音楽が切り替わってました。次にpythonファイルを覗くとflagのmp3は650個ほどの曲のリストを取ってきてflagの文字から対応する曲をつなげて返す感じでした。リストが多すぎるのでshazamパイセンにお願いすることに…まず、flagをそれぞれ一曲ごとに分割しshazamに曲の判別をしてもらい固有のIDを返却してもらいました。ただ、これでも「ニア」・「自傷無色」は判別してくれなかったので歌詞を頼りに名前を当てIDを調べる。これで準備が整ったのでshazamに全ての曲を食わせてIDの比較を行うとflagが特定できます。ちなみに、途中バグリ散らかしてたのでリソースにある曲のリストを作ってました。0,Tell Your World (feat. Hatsune Miku) - livetune1,ロキ - みきとP2,ROKI (feat. 星乃一歌 &amp; Hatsune Miku) - Leo/need3,Teo - Omoi4,Teo (feat. 星乃一歌 &amp; Hatsune Miku) - Leo/need5,ヒバナ -Reloaded- - DECO*276,HIBANA - Reloaded - (feat. 星乃一歌 &amp; Hatsune Miku) - Leo/need7,Timemachine (feat. Hatsune Miku) - Senroppyaku yonjuu meter P8,Time Machine (feat. 星乃一歌, 天馬咲希 &amp; Hatsune Miku) - Leo/need9,Happy Synthesizer (feat. Megurine Luka&amp;GUMI) - EasyPop10,Happy Synthesizer (feat. 花里みのり, 桐谷遥, 桃井愛莉 &amp; 日野森雫) - MORE MORE JUMP!11,Viva Happy (feat. Hatsune Miku) - Mitchie M12,Viva Happy (feat. Hatsune Miku) - Mitchie M13,Nostalogic (MEIKO-SAN mix) feat.MEIKO - yuukiss14,Nostalogic (feat. 桐谷遥, 日野森雫 &amp; MEIKO) - MORE MORE JUMP!15,Drop Pop Candy (feat. Giga) - Reol16,drop pop candy (feat. 小豆沢こはね, 白石杏, 鏡音リン &amp; 巡音ルカ) - Vivid BAD SQUAD17,Night Sky Patrol of Tomorrow (feat. 星乃一歌) - Leo/need18,Charles - Balloon19,Charles (feat. 東雲絵名 &amp; 暁山瑞希) - Nightcord at 25:0020,脱法ロック - Neru21,Law-evading Rock (feat. 天馬司, 神代類 &amp; 鏡音レン) - ワンダーランズ×ショウタイム22,Inochi ni Kirawarete Iru. - Mafumafu23,Hated by Life (feat. 宵崎奏 &amp; Hatsune Miku) - Nightcord at 25:0024,劣等上等 feat. 鏡音リン・レン - Giga25,劣等上等 feat. 鏡音リン・レン - Gigaこれ曲名が重なってるところは歌っている人のバージョンが違うみたいでしたね…これ用意したのえぐない????作問者に頭が上がりません…flag :SEKAI{v0CaloId&lt;3u}ごめんなさい、flagの最後が読めなかったです…vocaloid ceu??ですかね…読める方こっそり教えてください…" }, { "title": "manger attackについて", "url": "/posts/DUCTF-rsa-interval-oracle/", "categories": "ctf", "tags": "ctf, cryptography", "date": "2022-09-26 15:30:00 +0900", "snippet": "初めにDownUnderCTF で rsa-interval-oracle が出題された。主な解法は以下に纏められるし、公式解説でも同じようなことが書いてある。 rsa-interval-oracle-i →　bitごとの復号 or LSB oracle attack rsa-interval-oracle-ii →　Manger attack or LSB oracle attack rsa-interval-oracle-iii →　EHNP(HNP) or LSB oracle attack rsa-interval-oracle-iv →　EHNP(HNP)ソースコード(参考)rsa-interval-oracle-iv のソースコード#!/usr/bin/env python3import signal, timefrom os import urandom, pathfrom Crypto.Util.number import getPrime, bytes_to_longFLAG = open(path.join(path.dirname(__file__), 'flag.txt'), 'r').read().strip()N_BITS = 384TIMEOUT = 3 * 60MAX_INTERVALS = 4MAX_QUERIES = 4700def main(): p, q = getPrime(N_BITS//2), getPrime(N_BITS//2) N = p * q e = 0x10001 d = pow(e, -1, (p - 1) * (q - 1)) secret = bytes_to_long(urandom(N_BITS//9)) c = pow(secret, e, N) print(N) print(c) intervals = [(0, 2**(N_BITS - 11)), (0, 2**(N_BITS - 10)), (0, 2**(N_BITS - 9)), (0, 2**(N_BITS - 8))] queries_used = 0 while True: print('1. Add interval\\n2. Request oracle\\n3. Get flag') choice = int(input('&gt; ')) if choice == 1: if len(intervals) &gt;= MAX_INTERVALS: print('No more intervals allowed!') continue lower = int(input(f'Lower bound: ')) upper = int(input(f'Upper bound: ')) intervals.insert(0, (lower, upper)) elif choice == 2: if queries_used &gt; 0: print('No more queries allowed!') continue queries = input('queries: ') queries = [int(c.strip()) for c in queries.split(',')] queries_used += len(queries) if queries_used &gt; MAX_QUERIES: print('No more queries allowed!') continue results = [] for c in queries: m = pow(c, d, N) for i, (lower, upper) in enumerate(intervals): in_interval = lower &lt; m &lt; upper if in_interval: results.append(i) break else: results.append(-1) print(','.join(map(str, results)), flush=True) elif choice == 3: secret_guess = int(input('Enter secret: ')) if secret == secret_guess: print(FLAG) else: print('Incorrect secret :(') exit() else: print('Invalid choice')if __name__ == '__main__': signal.alarm(TIMEOUT) main()問題点問題となるのは choice == 1 の指定数と choice == 2 の応答時間である。 問題 難点 i なし ii クエリが1つ iii 応答時間が長い・ クエリが4つ iv クエリが4つ指定 ,1回で全て送信 公式解説でiii,ivは詳しく解説されているのでここでは、ii の manger attack について軽く解説したいと思います。 現時点での私が理解したものを書き綴っているため、一部誤解している可能性もあります。その場合、指摘してくださるとありがたいです。manger attack とはii の攻撃にある Manger’s attack とはManger さんが2001年に出した論文に起因して Manger attack と呼ばれます。これは、OAEPというパディングに対する攻撃に用いられるそうですが、ここでは内容をメインでするため省略します。攻撃手法の要約STEP1解の範囲を大まかに絞る。(2分探索)2枚目STEP2mの存在範囲を $[iN,iN+2B)$ に移動・拡大or縮小する。STEP3oracleで判定し二分探索する。二分探索後は範囲の場所である $[iN,iN+2B)$ を満たさない。よって3.3で求める$f_{tmp}$で最小値と最大値の差を$2B$にするように範囲の縮尺を拡大する。次に、$f_3$において平行移動を行い最小値を $iN$ のところまでにする。結果として、oracleの$B$以上か以下かの判定をうまく用いることができる。これを繰り返し、min と max の値が同じになれば終了し min が答えの$m$となるここで、rsa-interval-oracle の値設定は $N = 2^{348}$ よりmanger attack を使用する際の $B$ の値は$B = 2^{( \\lceil \\log_{256} N \\rceil-1)}=376$となる。よってiiのバージョンにおいて、クエリに376を投げてやれば manger attack が成立でき flag を得ることができる。誤字・脱字・訂正等ありましたら、twitterでお知らせください…" }, { "title": "2022-09-12-cakectf2022参加記", "url": "/posts/cakectf2022/", "categories": "ctf", "tags": "ctf", "date": "2022-09-12 01:00:00 +0900", "snippet": "初めに2022年9月3日(土)から2022年9月4日(日)まで開催されたcakectfに「kanon」で参加しまして、順位は154でした。(cryptoしか解いてないからあれなんですけども…)といいつつ去年は、全く何も解けなかったことを考えると成長してるなーという気分でした。競技中ぶっちゃけタイムスタンプ取ってないのでうる覚えで書いてます(fileの保存時間見て書いてます)…余りあてに出来ません競技開始(14:00)とりあえず、家にあったチーズケーキ食べながら1 wavの問題(frozen cake,brand new crypto)を確認。frozen cake (14:20??)frozen cakeをみてとりあえず、フェルマーの小定理で書き出してみるかで、式を書き出したらなんかうまくいってflagをget…!serverに提出したら、エラー?吐いたのでdiscordで確認すると修正するので待っててねとのことなので、brand new crypto を取り組むことに…brand new crypto (14:50??)初見ぽい暗号方式?だったので、一度式に書き出して考えてみる。最初は、何かうまく消えるのかなと思っていたけど、乱数$r$でうまくいかない…と思っていたら、式変形して $m$ のべき乗が表せることができたので 1 文字ずつ復号して flag を get 出来ました。四番目に解けたので「うおー」ってテンション爆上がり(3位に入れたこと一度もないんですけど、なんでそんなはやいんすか…)ここから16時までyoutubeみて時間つぶし…(他のジャンルは基礎知識がなさ過ぎてちらっと見ただけで全く分かってません…)rock door (16:00)lunaticの問題が解放され、 rock door を見ると、DSA・hashの組み合わせで一瞬戸惑いましたが、とりあえずコードとにらめっこしながら実行して内容の把握すると s しか返さないdsaで初めて見ましたが、とりあえず立式するとhash取ってるのでbitが小さいなーと思いつつ LLL を行うのなら $s = k^{-1}*(z + xr) mod q$ を $sk = z + xr + Aq $ $s,q$ は既知と考えて$x r$の処理をどうすればいいのかわからず撃沈しました。敗因は $x r$ を分離してしまったことで2変数になってしまい＼(^o^)／ｵﾜﾀこの問題に約2時間30分かけて解けなかったのと、この後に用事があったのでここでcakectfは断念しました。まとめ多分、実力的に rock door は解いておきたかった問題でしたね…あと、write up は他の方を参照された方がいいと思います。(時間もたってるし、クオリティが低いしで…)なんだかんだ、自分の成長を感じながら上には上がいることを改めて実感しましたので、とても楽しめましたし、悔しい思いをしました。そんなこんなもありながら、cakectf 2022 を開催してくださった方々ありがとうございました。" }, { "title": "TFC CTF 2022 writeup", "url": "/posts/TFCCTF-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-07-31 19:00:00 +0900", "snippet": "息抜きに…cryptoctfが重すぎた…てか、そろそろfirst bloodをとりたいすね…EXCLUSIVE_ORACLE [75 solve]繋いで適当な値を入れまくってみると、返り値が80文字以上増えなくなる。よって、flagは半分の40文字と推測でき、入力値が40文字で、flagが40文字で共通鍵暗号的に何ができるかというとxorかなぁと…keyを復元し、flagも復元するとフラグが取れるいやこの問題辛くない????え、そうでもない、、そうですか。。。solvefrom pwn import *from Crypto.Util.number import *io = remote( \"01.linux.challenges.ctf.thefewchosen.com\" ,54784)io.recvuntil(b\"&gt; \")io.sendline(b\"1\"*40)ret = eval(io.recvline(None).decode())key = bytes_to_long(ret[:40])^bytes_to_long(b\"1\"*40)print(long_to_bytes(bytes_to_long(ret[40:])^key))#TFCCTF{wh4t's_th3_w0rld_w1th0u7_3n1gm4?}TRAIN_TO_PADDINGTON [132 solves]challimport osBLOCK_SIZE = 16FLAG = b'|||REDACTED|||'def pad_pt(pt): amount_padding = 16 if (16 - len(pt) % 16) == 0 else 16 - len(pt) % 16 return pt + (b'\\x3f' * amount_padding)pt = pad_pt(FLAG)key = os.urandom(BLOCK_SIZE)ct = b''j = 0for i in range(len(pt)): ct += (key[j] ^ pt[i]).to_bytes(1, 'big') j += 1 j %= 16with open('output.txt', 'w') as f: f.write(ct.hex())solveまあ普通のxorの問題で、先頭と後ろでそれぞれ TFCCTF{ と\\x3f*16 でxor取って出てきた値が被っていれば簡単に復元できるから被りがいいなぁとか思っていたら普通に被ってたので簡単にkeyが手に入った。このkeyを使って復元しておしまい!from Crypto.Util.number import *from Crypto.Util.strxor import strxorct = bytes.fromhex(\"b4b55c3ee34fac488ebeda573ab1f974bf9b2b0ee865e45a92d2f14b7bdabb6ed4872e4dd974e803d9b2ba1c77baf725\")BLOCK_SIZE = 16cts = []for i in range(len(ct)//16): cts.append(ct[i*16:(i+1)*16])flag = b\"TFCCTF{\"len = len(flag)key = strxor(cts[0][:len], flag)key += strxor(cts[2], b\"\\x3f\"*16)[7:]flag = b\"\"for i in range(3): flag += strxor(cts[i], key)print(flag)# TFCCTF{th3_tr41n_h4s_l3ft_th3_st4t10n}ADMIN PANELchallimport osimport randomfrom Crypto.Cipher import AESKEY = os.urandom(16)PASSWORD = os.urandom(16)FLAG = os.getenv('FLAG')menu = \"\"\"========================1. Access Flag2. Change Password========================\"\"\"def xor(byte, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([byte ^ bytes_second[i]]) return ddef decrypt(ciphertext): iv = ciphertext[:16] ct = ciphertext[16:] cipher = AES.new(KEY, AES.MODE_ECB) pt = b'' state = iv for i in range(len(ct)): b = cipher.encrypt(state)[0] c = b ^ ct[i] pt += bytes([c]) print(b,c,pt) state = state[1:] + bytes([ct[i]]) return ptif __name__ == \"__main__\": while True: print(menu) option = int(input(\"&gt; \")) if option == 1: password = bytes.fromhex(input(\"Password &gt; \")) if password == PASSWORD: print(FLAG) exit(0) else: print(\"Wrong password!\") continue elif option == 2: token = input(\"Token &gt; \") if len(token) != 64: print(\"Wrong length!\") continue hex_token = bytes.fromhex(token) # r_byte = random.randbytes(1) r_byte = os.urandom(1) print(f\"XORing with: {r_byte.hex()}\") xorred = xor(r_byte[0], hex_token) PASSWORD = decrypt(xorred)solve初手適当に手元で2*64代入したら初めのバイト以外全てのバイト列が同じものが出てきた…何も考えずにAccess Flagで初めの値のブルートフォースで終わり。はい、ちゃんとやります。decrypt関数において1回目のAESでの平文にあたるものはciphertext[:16]で、2回目のAESでの平文にあたるものはciphertext[1:17]とi回目の平文はciphertext[i-1:15+i]となる。今回はこれの値を一定にすると\\(c\\)の値も一定になりすごーくうれしい(PASSWORDの文字列が一定の文字種が制限できる)from pwn import *from Crypto.Util.number import *from tqdm import tqdm# io = process(\"./main.py\")io = remote(\"01.linux.challenges.ctf.thefewchosen.com\", 54928)io.recvuntil(b\"&gt; \")io.sendline(b\"2\")io.recvuntil(b\"&gt; \")io.sendline(b\"2\"*64)for i in tqdm(range(256)): io.recvuntil(b\"&gt; \") io.sendline(b\"1\") # print(io.recvuntil(b\"&gt; \")) # print((long_to_bytes(1)*16).hex()) io.sendline((long_to_bytes(i)*16).hex().encode()) tmp = io.recvline() if b\"{\" in tmp: print(tmp) exit()# TFCCTF{l0g0n_z3r0_w1th_3xtr4_st3ps!}ADMIN PANEL BUT HARDER　[78 solves]challimport osimport randomfrom Crypto.Cipher import AESKEY = os.urandom(16)PASSWORD = os.urandom(16)FLAG = os.getenv('FLAG')menu = \"\"\"========================1. Access Flag2. Change Password========================\"\"\"def xor(bytes_first, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([bytes_first[i] ^ bytes_second[i]]) return ddef decrypt(ciphertext): iv = ciphertext[:16] ct = ciphertext[16:] cipher = AES.new(KEY, AES.MODE_ECB) pt = b'' state = iv for i in range(len(ct)): b = cipher.encrypt(state)[0] c = b ^ ct[i] pt += bytes([c]) state = state[1:] + bytes([ct[i]]) return ptif __name__ == \"__main__\": while True: print(menu) option = int(input(\"&gt; \")) if option == 1: password = bytes.fromhex(input(\"Password &gt; \")) if password == PASSWORD: print(FLAG) exit(0) else: print(\"Wrong password!\") continue elif option == 2: token = input(\"Token &gt; \") if len(token) != 64: print(\"Wrong length!\") continue hex_token = bytes.fromhex(token) r_bytes = random.randbytes(32) print(f\"XORing with: {r_bytes.hex()}\") xorred = xor(r_bytes, hex_token) PASSWORD = decrypt(xorred)solveADMIN PANELから変化した部分はChange Passwordの乱数の部分が増加した。これでは一定値に定めるのが極めてしんどい。。なので、Change Passwordで乱数の値が返ってくることを利用して乱数予測を行う!帰ってくる乱数は32bytesより約80回程度集めれば乱数予測が可能となる。あとはADMIN PANELと同じimport randomfrom mt19937predictor import MT19937Predictorfrom pwn import *from Crypto.Util.number import *from tqdm import tqdm# io = process(\"./main.py\")io = remote(\"01.linux.challenges.ctf.thefewchosen.com\", 55172)def xor(bytes_first, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([bytes_first[i] ^ bytes_second[i]]) return dpredictor = MT19937Predictor()for _ in tqdm(range(120)): io.recvuntil(b\"&gt; \") io.sendline(b\"2\") io.recvuntil(b\"&gt; \") io.sendline(b\"2\"*64) x = bytes.fromhex(io.recvline(None).decode().split(\": \")[1]) # print(x) predictor.setrandbits(int.from_bytes(x, byteorder='little'), 8*32)next_rnd = predictor.getrandbits(8*32).to_bytes(32, 'little')io.recvuntil(b\"&gt; \")io.sendline(b\"2\")io.recvuntil(b\"&gt; \")msg = xor(b\"2\"*64 ,next_rnd)io.sendline(msg.hex().encode())ret = bytes.fromhex(io.recvline(None).decode().split(\": \")[1])# print(ret,next_rnd, long_to_bytes(tst))assert ret== next_rndprint(\"[+] YES!!!!! find seed \")# part2 for i in tqdm(range(256)): io.recvuntil(b\"&gt; \") io.sendline(b\"1\") # print(io.recvuntil(b\"&gt; \")) # print((long_to_bytes(1)*16).hex()) io.sendline((long_to_bytes(i)*16).hex().encode()) tmp = io.recvline() if b\"{\" in tmp: print(tmp) exit()# TFCCTF{n0_th3_fl4g_1s_n0t_th3_0ld_0n3_plus-Th3-w0rd_h4rd3r!}ADMIN PANEL BUT HARDER FIXED　[50 solves ・56 solves]challimport osimport randomfrom Crypto.Cipher import AESKEY = os.urandom(16)PASSWORD = os.urandom(16)FLAG = os.getenv('FLAG')menu = \"\"\"========================1. Access Flag2. Change Password========================\"\"\"def xor(bytes_first, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([bytes_first[i] ^ bytes_second[i]]) return ddef decrypt(ciphertext): iv = ciphertext[:16] ct = ciphertext[16:] cipher = AES.new(KEY, AES.MODE_ECB) pt = b'' state = iv for i in range(len(ct)): b = cipher.encrypt(state)[0] c = b ^ ct[i] pt += bytes([c]) state = state[1:] + bytes([ct[i]]) return ptif __name__ == \"__main__\": while True: print(menu) option = int(input(\"&gt; \")) if option == 1: password = bytes.fromhex(input(\"Password &gt; \")) if password == PASSWORD: print(FLAG) exit(0) else: print(\"Wrong password!\") continue elif option == 2: token = input(\"Token &gt; \").strip() if len(token) != 64: print(\"Wrong length!\") continue hex_token = bytes.fromhex(token) r_bytes = random.randbytes(32) print(f\"XORing with: {r_bytes.hex()}\") xorred = xor(r_bytes, hex_token) PASSWORD = decrypt(xorred)solve非想定解があったみたいだけどADMIN PANEL BUT HARDERで作った解法には影響なかったので、そのままlet’s go!!import randomfrom mt19937predictor import MT19937Predictorfrom pwn import *from Crypto.Util.number import *from tqdm import tqdm# io = process(\"./main.py\")io = remote(\"01.linux.challenges.ctf.thefewchosen.com\", 55225)def xor(bytes_first, bytes_second): d = b'' for i in range(len(bytes_second)): d += bytes([bytes_first[i] ^ bytes_second[i]]) return dpredictor = MT19937Predictor()for _ in tqdm(range(120)): io.recvuntil(b\"&gt; \") io.sendline(b\"2\") io.recvuntil(b\"&gt; \") io.sendline(b\"2\"*64) x = bytes.fromhex(io.recvline(None).decode().split(\": \")[1]) # print(x) predictor.setrandbits(int.from_bytes(x, byteorder='little'), 8*32)next_rnd = predictor.getrandbits(8*32).to_bytes(32, 'little')io.recvuntil(b\"&gt; \")io.sendline(b\"2\")io.recvuntil(b\"&gt; \")msg = xor(b\"2\"*64 ,next_rnd)io.sendline(msg.hex().encode())ret = bytes.fromhex(io.recvline(None).decode().split(\": \")[1])# print(ret,next_rnd, long_to_bytes(tst))assert ret== next_rndprint(\"[+] YES!!!!! find seed \")# part2 for i in tqdm(range(256)): io.recvuntil(b\"&gt; \") io.sendline(b\"1\") # print(io.recvuntil(b\"&gt; \")) # print((long_to_bytes(1)*16).hex()) io.sendline((long_to_bytes(i)*16).hex().encode()) tmp = io.recvline() if b\"{\" in tmp: print(tmp) exit()# TFCCTF{4pp4r3ntly_sp4ces_br34ks_th3_0ld_0ne}" }, { "title": "Access Denied CTF 2022 writeup", "url": "/posts/Access-Denied-CTF-2022-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-06-12 19:30:00 +0900", "snippet": "最近勉強したresultantで解けたのでよかったなぁ…あと、まじでそろそろctfのチームはいりたいよ…気を取り直して、正解が少ない2問あげます…(乱数予測は解けなかったorz)[crypto] MITM-2 (17 solve)challalicefrom AES import encrypt, decrypt, paddingfrom binascii import hexlify, unhexlifyfrom hashlib import md5import osflag = b\"XXXXXX\"msg = b\"here_is_my_code!\"keys = [ b'XXXXXXXXXXXXXXXX', b'XXXXXXXXXXXXXXXX' ]g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977p = 174807157365465092731323561678,522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843private_key = 0 # Alice Private Keydef main():\tpublic_key = pow(g, private_key, p)\tprint(\"&gt; Here is my public key: {}\".format(public_key))\tkey = int(input(\"&gt; Your public key: \"))\tif(key == 0 or key == 1 or key == p - 1):\t\tprint(\"&gt; Ohhh...... Weak Keys\")\t\texit(0)\taes_key = md5(unhexlify(hex(pow(key, private_key, p))[2:])).digest()\tkeys.append(aes_key)\tencrypted_msg = encrypt(msg, keys, b\"A\"*16, b\"B\"*16)\tencrypted_flag = encrypt(flag[:32], keys, b\"A\"*16, b\"B\"*16)\tprint(\"&gt; Your output: {} {}\".format(hexlify(encrypted_msg), hexlify(encrypted_flag)))if __name__ == '__main__':\tmain()bobfrom AES import encrypt, decrypt, paddingfrom binascii import hexlify, unhexlifyfrom hashlib import md5import os# Alice and Bob keys are generated by [md5(os.urandom(3)).digest() for _ in rand]flag = b\"XXXXXX\" # flagkeys = [ b'XXXXXXXXXXXXXXXX', b'XXXXXXXXXXXXXXXX' ]msg = b\"thank_you_here_is_remaining_part\"g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977p = 174807157365465092731323561678522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843private_key = 0 # Bob private Keydef main():\tpublic_key = pow(g, private_key, p)\tprint(\"&gt; Here is my public key: {}\".format(public_key))\tkey = int(input(\"&gt; Your public key: \"))\t\tif(key == 0 or key == 1 or key == p - 1):\t\tprint(\"&gt; Ohhh...... Weak Keys\")\t\texit(0)\taes_key = md5(unhexlify(hex(pow(key, private_key, p))[2:])).digest()\tkeys.append(aes_key)\t\tcode = input(\"&gt; Give me the code(encrypted hex): \")\tdecrypted_code = decrypt(unhexlify(code), keys, b\"A\"*16, b\"B\"*16)\tif(decrypted_code[:32] == flag[:32]):\t\tencrypted_msg = encrypt(msg, keys, b\"A\"*16, b\"B\"*16)\t\tencrypted_flag = encrypt(flag[32:], keys, b\"A\"*16, b\"B\"*16)\t\tprint(\"&gt; Your output: {} {}\".format(hexlify(encrypted_msg), hexlify(encrypted_flag)))\telse:\t\tprint(\"&gt; You have given the wrong code\")if __name__ == '__main__':\tmain()AESfrom Crypto.Cipher import AESfrom binascii import hexlify, unhexlifyfrom hashlib import md5import osimport signaldef get_ciphers(keys, iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_ECB), AES.new(keys[1], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[2], mode=AES.MODE_CBC, iv=iv2) ]def padding(m): return m + os.urandom(16 - (len(m) % 16))def encrypt(m, keys, iv1, iv2): m = padding(m) ciphers = get_ciphers(keys, iv1, iv2) c = m for cipher in ciphers: c = cipher.encrypt(c) return cdef decrypt(c, keys, iv1, iv2): assert len(c) % 16 == 0 ciphers = get_ciphers(keys, iv1, iv2) m = c for cipher in ciphers[::-1]: m = cipher.decrypt(m) return msolveこの問題はDH鍵共有のman-in-the-middleとAESのmeet-in-the-middleをかけ合わせた問題。DH鍵共有のpartはこちらの共有鍵が\\(p-1,1,0\\)の場合以外に通るので\\(-1\\)で通過させて解決。AESのpartは鍵がos.urandom(3)で決まるので\\(256^3\\)のうちのどれか一つなのでmeet-in-the-middleで鍵推定を行う鍵がわかればAES.pyを用いてflag出して終わりfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom binascii import hexlify, unhexlifyfrom hashlib import md5from tqdm import tqdmfrom pwn import *import os from AES import encrypt, decrypt, paddingp = 174807157365465092731323561678522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843a_pub = 119411071723122444381767470125626227123727573250251216315907714124627930184475306091652961747380924296747933021923661790680670240155231816516457033069067832914869305822175715488571133446537348467810750635631617119618614773943953032009463487011337635599632404459399646451549811120239365019103442516813610951801g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977# Alice and Bob keys are generated by [md5(os.urandom(3)).digest() for _ in rand]def conection_alice(io): io.recvuntil(b\"ey: \") a_pub = int(io.recvline(None).decode()) io.recvuntil(b\"key: \") io.sendline(str(-1).encode()) io.recvuntil(b\"Your output: \") a = io.recvline(None).decode().split(\" \") encrypted_msg = bytes.fromhex( eval(a[0]).decode()) encrypted_flag =bytes.fromhex(eval(a[1]).decode()) io.close() print(\"[+] encrypted_msg\",encrypted_msg) print(\"[+] encrypted_flag\",encrypted_flag) return encrypted_msg,encrypted_flagdef conection_bob(io,enc): io.recvuntil(b\"ey: \") a_pub = int(io.recvline(None).decode()) io.recvuntil(b\"key: \") io.sendline(str(-1).encode()) io.recvuntil(b\"hex): \") io.sendline(enc.hex().encode()) io.recvuntil(b\"Your output: \") a = io.recvline(None).decode().split(\" \") encrypted_msg = bytes.fromhex( eval(a[0]).decode()) encrypted_flag =bytes.fromhex(eval(a[1]).decode()) io.close() print(\"[+] encrypted_msg\",encrypted_msg) print(\"[+] encrypted_flag\",encrypted_flag) return encrypted_msg,encrypted_flagdef MITM(encrypted_msg): aes_key =md5(unhexlify(hex(pow(-1, 1, p))[2:])).digest() # decrypt AES3 cipher3 = AES.new(aes_key, mode=AES.MODE_CBC, iv=b\"B\"*16) encrypted_msg = cipher3.decrypt(encrypted_msg) # ecrypt AES1 AES1 = [] for key in tqdm(range(0,256^3)): chipher = AES.new(md5(long_to_bytes(key)).digest(), mode=AES.MODE_ECB) AES1.append(chipher.encrypt(a_msg)) # decrypt AES2 AES2 =[] for key in tqdm(range(0,256^3)): chipher2 = AES.new(md5(long_to_bytes(key)).digest(), mode=AES.MODE_CBC, iv=b\"A\"*16) AES2.append(chipher2.decrypt(encrypted_msg)) AES3 = AES1+AES2 same = [k for k, v in collections.Counter(AES3).items() if v &gt; 1] if same!=None: print(\"[+] find meessage\") key1 = AES1.index(same[0]) key2 = AES2.index(same[0]) print(\"[+] find key1\",key1) print(\"[+] find key2\",key2) return key1 ,key2#----------------alice----------------------------io = remote(\"34.123.4.102\" ,4000)encrypted_msg,encrypted_flag = conection_alice(io)a_msg = b\"here_is_my_code!\"key1,key2 = MITM(encrypted_msg[:16])# key1 = 8148705# key2 = 14049457keys = [md5(long_to_bytes(key1)).digest(),md5(long_to_bytes(key2)).digest(),md5(unhexlify(hex(pow(-1, 1, p))[2:])).digest()]flag1 = decrypt(encrypted_flag, keys, b\"A\"*16, b\"B\"*16)[:-16]print(\"[+] flag &gt;\",flag1)#----------------bob----------------------------io = remote(\"34.123.4.102\" ,8000)encrypted_msg,encrypted_flag = conection_bob(io,encrypted_flag)print(\"[+] msg &gt;\",decrypt(encrypted_msg, keys, b\"A\"*16, b\"B\"*16))flag2 = decrypt(encrypted_flag, keys, b\"A\"*16, b\"B\"*16)[:-16]print(\"[+] flag &gt;\",flag2)print(\"[+] flag &gt;\",flag1+flag2)# accessdenied{m4n_1n_th3_m1ddl3_4nd_m33t_1n_th3_m1ddl3!_931a52e4}[crypto] ECC (19 solve)challimport tinyec.ec as ecimport tinyec.registry as regfrom hashlib import sha256from random import randintclass RNG: def __init__(self, seed): self.state = seed def next(self): self.state = self.state + 1 return self.statedef hashInt(msg): h = sha256(msg).digest() return int.from_bytes(h, 'big')def sign(msg): m = hashInt(msg) k = rand.next() R = k * G r = R.x s = pow(k, -1, n) * (m + r * d) % n return (r, s) def verify(msg, sig): r, s = sig m = hashInt(msg) sinv = pow(s, -1, n) u1 = m * sinv % n u2 = r * sinv % n R_ = u1 * G + u2 * Q r_ = R_.x return r_ == rC = reg.get_curve(\"secp256r1\")G = C.gn = C.field.nd = int(open(\"flag.txt\", \"rb\").read().hex(), 16)Q = d * Grand = RNG(randint(2, n-1))# Let's sign some msgsm1 = b\"crypto means cryptography\"m2 = b\"may the curve be with you\"m3 = b\"the annoying fruit equation\"sig1 = sign(m1)sig2 = sign(m2)sig3 = sign(m3)assert verify(m1, sig1)assert verify(m2, sig2)assert verify(m3, sig3)open(\"out.txt\", \"w\").write(f\"{sig1 = }\\n{sig2 = }\\n{sig3 = }\")solvesignの式が\\(s_i={k_i}^{-1}(H(m_i)+r_{i}d) \\ \\ mod \\ \\ n\\)であり未知の変数は\\(k_i,d\\)となる。ここで、RNGの性質で\\(k_{i+1}=k_i + 1\\)となることから、未知の変数\\(k_0,d\\)の2変数となる。なので、resultantを計算してdを求めればflagが手に入る後、当たり前のようにグレブナー基底でも解けた…本当にグレブナー基底の解ける条件考えないと…import tinyec.ec as ecimport tinyec.registry as regfrom hashlib import sha256from random import randintfrom Crypto.Util.number import *def hashInt(msg): h = sha256(msg).digest() return int.from_bytes(h, 'big')m0 = hashInt(b\"crypto means cryptography\")m1 = hashInt(b\"may the curve be with you\")m2 = hashInt(b\"the annoying fruit equation\")r,s = [0,0,0],[0,0,0]r[0],s[0] = (104643007282746168593080909181608136842069989473568245529813036758771329973363, 64857484327908680037110311008974831697501603147734264713321850573005484948766)r[1],s[1] = (103100238141753471646305398545577342208947972057548356113817050903685018825164, 68180337315087533969740301361624519816597436690234900639676209985924490588183)r[2],s[2] = (102982255637408147467745136566528008388200085481044044672245245459397287601125, 90628876174756318095385459486067833878236505125282311602737298420398366610196)C = reg.get_curve(\"secp256r1\")G = C.gn = C.field.nP.&lt;k, d&gt; = PolynomialRing(GF(n))def resultant(f1, f2, var): return Matrix(f1.sylvester_matrix(f2, var)).determinant()poly1 = m0 + r[0]*d - s[0]*kpoly2 = m1 + r[1]*d - s[1]*(k+1)poly12 = resultant(poly1, poly2, k)print(long_to_bytes(poly12.univariate_polynomial().roots()[0][0]))# b'accessdenied{ECDSA_w34k_RNG}'" }, { "title": "seccon beginners 2022 writeup", "url": "/posts/seccon-beginners-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-06-05 14:00:00 +0900", "snippet": "さすがに去年よりは成長したかなぁと思います…[crypto] CoughingFox (404 solve)challfrom random import shuffleflag = b\"ctf4b{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}\"cipher = []for i in range(len(flag)): f = flag[i] c = (f + i)**2 + i cipher.append(c)shuffle(cipher)print(\"cipher =\", cipher)solve多項式で計算した後に\\(shuffle\\)で配列の中身をランダムに入れ替えているここで、適切な\\(i\\)以外はrootを取る際に虚数になることを利用して総当たりで求めるfrom Crypto.Util.number import *from sage.all import *import gmpy2 cipher = [12147, 20481, 7073, 10408, 26615, 19066, 19363, 10852, 11705, 17445, 3028, 10640, 10623, 13243, 5789, 17436, 12348, 10818, 15891, 2818, 13690, 11671, 6410, 16649, 15905, 22240, 7096, 9801, 6090, 9624, 16660, 18531, 22533, 24381, 14909, 17705, 16389, 21346, 19626, 29977, 23452, 14895, 17452, 17733, 22235, 24687, 15649, 21941, 11472]# print(gmpy2.iroot(12147,2))for i in range(len(cipher)): for k in range(len(cipher)): if gmpy2.iroot(cipher[k]-i,2)[1]==True: print(chr(gmpy2.iroot(cipher[k]-i,2)[0]-i),end=\"\") # ctf4b{Hey,Fox?YouCanNotTearThatHouseDown,CanYou?}[crypto] PrimeParty (57 solve)challfrom Crypto.Util.number import *from secret import flagfrom functools import reducefrom operator import mulbits = 256flag = bytes_to_long(flag.encode())assert flag.bit_length() == 455GUESTS = []def invite(p): global GUESTS if isPrime(p): print(\"[*] We have been waiting for you!!! This way, please.\") GUESTS.append(p) else: print(\"[*] I'm sorry... If you are not a Prime Number, you will not be allowed to join the party.\") print(\"-*-*-*-*-*-*-*-*-*-*-*-*-\")invite(getPrime(bits))invite(getPrime(bits))invite(getPrime(bits))invite(getPrime(bits))for i in range(3): print(\"[*] Do you want to invite more guests?\") num = int(input(\" &gt; \")) invite(num)n = reduce(mul, GUESTS)e = 65537cipher = pow(flag, e, n)print(\"n =\", n)print(\"e =\", e)print(\"cipher =\", cipher)solveサーバ側で256bitの素数4つとクライアント側で3つの素数を用いてRSA暗号を行う ただ、3つの素数の選び方によっては4つの素数を使わなくても復号できる場合があり、今回の場合3つの素数の合計bitが455bitを少し超えるように設定するとクライアント側だけの素数で復号できるfrom traceback import print_tbfrom Crypto.Util.number import *from pwn import *from sage.all import *from tqdm import tqdmbit = 160p = []for i in range(3): a = getPrime(bit) p.append(a) print(\"[+] prime &gt;\",a)io = remote( \"primeparty.quals.beginners.seccon.jp\" ,1336) io.recvuntil(b\" &gt; \")io.sendline(str(p[0]).encode())io.recvuntil(b\" &gt; \")io.sendline(str(p[1]).encode())io.recvuntil(b\" &gt; \")io.sendline(str(p[2]).encode())io.recvuntil(b\"n = \")n = int(io.recvline(None).decode())io.recvuntil(b\"e = \")e = int(io.recvline(None).decode())io.recvuntil(b\"cipher = \")ct = int(io.recvline(None).decode())inv =(p[0]-1)*(p[1]-1)*(p[2]-1)print(\"[+] inverse \",n//inv) d = pow(e,-1,inv)ct = ct%(p[0]*p[1]*p[2])print(long_to_bytes(pow(ct,d,p[0]*p[1]*p[2])))# ctf4b{HopefullyWeCanFindSomeCommonGroundWithEachOther!!!}[crypto] Command (85 solve)chall#! /usr/bin/env python3from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Util.number import isPrimefrom secret import FLAG, keyimport osdef main(): while True: print('----- Menu -----') print('1. Encrypt command') print('2. Execute encrypted command') print('3. Exit') select = int(input('&gt; ')) if select == 1: encrypt() elif select == 2: execute() elif select == 3: break else: pass print()def encrypt(): print('Available commands: fizzbuzz, primes, getflag') cmd = input('&gt; ').encode() if cmd not in [b'fizzbuzz', b'primes', b'getflag']: print('unknown command') return if b'getflag' in cmd: print('this command is for admin') return iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) enc = cipher.encrypt(pad(cmd, 16)) print(f'Encrypted command: {(iv+enc).hex()}')def execute(): inp = bytes.fromhex(input('Encrypted command&gt; ')) iv, enc = inp[:16], inp[16:] cipher = AES.new(key, AES.MODE_CBC, iv) try: cmd = unpad(cipher.decrypt(enc), 16) if cmd == b'fizzbuzz': fizzbuzz() elif cmd == b'primes': primes() elif cmd == b'getflag': getflag() except ValueError: print(\"pass\") passdef fizzbuzz(): for i in range(1, 101): if i % 15 == 0: print('FizzBuzz') elif i % 3 == 0: print('Fizz') elif i % 5 == 0: print('Buzz') else: print(i)def primes(): for i in range(1, 101): if isPrime(i): print(i)def getflag(): print(FLAG)if __name__ == '__main__': main()AESのCBCモードを利用してgetflagの暗号化したものを送るようにしたいAESのCBCの特徴として初めの1ブロックは復号の最後にivとXOR取って平文を返すようにしているこれを逆手にとって任意のivを送ることで復号結果にgetflagを出すようにすればいいsolvefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Util.number import *from pwn import *io = remote(\"command.quals.beginners.seccon.jp\", 5555)io.recvuntil(b\"&gt; \")io.sendline(b\"1\")io.recvuntil(b\"&gt; \")io.sendline(b\"fizzbuzz\")io.recvuntil(b\"Encrypted command: \")tmp = io.recvline(None)iv,ct = int(tmp[:32],16),tmp[32:].decode()print(tmp)print(\"iv,ct\",iv,ct)mf = bytes_to_long(pad(b\"fizzbuzz\", 16))mg = bytes_to_long(pad(b\"getflag\", 16))new_iv = long_to_bytes(mf^iv^mg)print(new_iv)new_iv = new_iv.hex()print(new_iv)io.recvuntil(b\"&gt; \")io.sendline(b\"2\")io.recvuntil(b\"Encrypted command&gt; \") print(new_iv,ct)io.sendline((new_iv+ct).encode())io.interactive()# ctf4b{b1tfl1pfl4ppers}[crypto] omni-RSA (13 solve)challfrom Crypto.Util.number import *# from flag import flagp, q, r = getPrime(512), getPrime(256), getPrime(256)n = p * q * rphi = (p - 1) * (q - 1) * (r - 1)e = 2003d = inverse(e, phi)flag = bytes_to_long(flag.encode())cipher = pow(flag, e, n)s = d % ((q - 1)*(r - 1)) &amp; (2**470 - 1)print(\"rq =\", r % q)print(\"e =\", e)print(\"n =\", n)print(\"s =\", s)print(\"cipher =\", cipher)solve普段のRSAに付随して\\(d\\)の下位469bitと\\(r\\)を\\(q\\)で割ったあまりが与えられている方針として、\\(d_{qr}\\)は\\(d\\)を\\((q-1)(r-1)\\)で割ったあまり、\\(0 \\leq k \\leq e\\)とすると\\(d_{qr} = d_0 * 2^{470} + s - k*(q-1)*(r-1)\\)という式が成立するここで、\\(q\\)の大きさは256bitであることを考えると \\(d_{qr} \\equiv s - k*(q-1)*(r-1) mod(2^{256})\\)でも成立し、\\(r\\)を\\(q\\)で割ったあまりに置き換えると\\(d_{qr} \\equiv s - k*(q-1)*(q+rq-1) mod(2^{256})\\) これを満たす\\(q\\)のどれかが今回の問題で使われた素数\\(q\\)となるfrom Crypto.Util.number import *from tqdm import tqdmrq = 7062868051777431792068714233088346458853439302461253671126410604645566438638e = 2003n = 140735937315721299582012271948983606040515856203095488910447576031270423278798287969947290908107499639255710908946669335985101959587493331281108201956459032271521083896344745259700651329459617119839995200673938478129274453144336015573208490094867570399501781784015670585043084941769317893797657324242253119873s = 1227151974351032983332456714998776453509045403806082930374928568863822330849014696701894272422348965090027592677317646472514367175350102138331cipher = 82412668756220041769979914934789463246015810009718254908303314153112258034728623481105815482207815918342082933427247924956647810307951148199551543392938344763435508464036683592604350121356524208096280681304955556292679275244357522750630140768411103240567076573094418811001539712472534616918635076601402584666def find(d0, kbits, e, n): X = var('X') for k in tqdm(range(e+1, 1, -1)): results = solve_mod([k*(X-1)*(X+rq-1)+1 ==e*d0 ], 2^kbits) for x in results: if int(n)%int(x[0])==0: print(\"[+] find q --------\") print(\"q\",x[0]) print(\"------------\") return x[0]if __name__ == '__main__': # d0 = d &amp; (2^kbits-1) # print (\"lower %d bits (of %d bits) is given\" % (kbits, nbits)) # p = find_p(s, int(s).bit_length(), e, n) q = find(s,256, e, n) q = 108719400953000878740030929903618126158486070837750092259928673760881189657243 r = rq+q p = n//(r*q) assert n == p*q*r print (\"[+] good primes !!\") print (long_to_bytes(pow(cipher,inverse_mod(e, (p-1)*(q-1)*(r-1)),n))) # ctf4b{GoodWork!!!YouAreTrulyOmniscientAndOmnipotent!!!} " }, { "title": "Hero CTF v4 2022 writeup", "url": "/posts/HeroCTF-v4-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-05-29 23:00:00 +0900", "snippet": "息抜きにただ、cryptoが少なくて残念…[crypto] Poly321chall#!/usr/bin/env python3FLAG = \"****************************\"enc = []for c in FLAG: v = ord(c) enc.append( v + pow(v, 2) + pow(v, 3) )print(enc)\"\"\"$ python3 encrypt.py[378504, 1040603, 1494654, 1380063, 1876119, 1574468, 1135784, 1168755, 1534215, 866495, 1168755, 1534215, 866495, 1657074, 1040603, 1494654, 1786323, 866495, 1699439, 1040603, 922179, 1236599, 866495, 1040603, 1343210, 980199, 1494654, 1786323, 1417584, 1574468, 1168755, 1380063, 1343210, 866495, 188499, 127550, 178808, 135303, 151739, 127550, 112944, 178808, 1968875]\"\"\"ただの多項式だからsageに解かせて終わりsolvefrom Crypto.Util.number import *from sage.all import *cts = [378504, 1040603, 1494654, 1380063, 1876119, 1574468, 1135784, 1168755, 1534215, 866495, 1168755, 1534215, 866495, 1657074, 1040603, 1494654, 1786323, 866495, 1699439, 1040603, 922179, 1236599, 866495, 1040603, 1343210, 980199, 1494654, 1786323, 1417584, 1574468, 1168755, 1380063, 1343210, 866495, 188499, 127550, 178808, 135303, 151739, 127550, 112944, 178808, 1968875]for ct in cts: var(\"v\") f = v + v**2+v**3-ct print(chr(int(str(solve(f,v)[2]).replace(\"v == \",\"\"))),end=\"\")# Hero{this_is_very_weak_encryption_92835208}[crypto] The oracle’s apprenticechall#!/usr/bin/env python3from Crypto.Util.number import getStrongPrime, bytes_to_longimport randomFLAG = open('flag.txt','rb').read()encrypt = lambda m: pow(m, e, n)decrypt = lambda c: pow(c, d, n)e = random.randrange(3, 65537, 2)p = getStrongPrime(1024, e=e)q = getStrongPrime(1024, e=e)n = p * qφ = (p-1) * (q-1)d = pow(e, -1, φ)c = encrypt(bytes_to_long(FLAG))#print(f\"{n=}\")#print(f\"{e=}\")print(f\"{c=}\")for _ in range(3): t = int(input(\"c=\")) print(decrypt(t)) if c != t else None体の準同型の性質を利用する\\((a*b)^e=a^e*b^e\\)ここで、1回目に送信するものを\\(c1\\),1回目に受信するものを\\(t1\\)と置く \\(n\\)の復元 \\(c1=-1 \\ mod \\ (n) ⇒ t1=n-1 \\ mod \\ (n)\\) \\(2^d\\)を求める \\(c2=2\\ mod\\ (n) ⇒ t2=2^d \\ mod \\ (n)\\)　 \\((2*ct)^d\\)を求める \\(c3=2*ct \\ mod \\ (n) ⇒ t3=(2*ct)^d \\ mod \\ (n)\\)最後に\\(m = t3*t2^{-1} \\ mod \\ (n)\\)で復元できるsolvefrom pwn import *from Crypto.Util.number import *io = remote(\"crypto.heroctf.fr\",9000)c = int(io.recvline(None).decode().replace(\"c=\",\"\"))io.recvuntil(b\"c=\")io.sendline(b\"-1\")n = int(io.recvline(None).decode())+1io.recvuntil(b\"c=\")io.sendline(b\"2\")d2 = int(io.recvline(None).decode())io.recvuntil(b\"c=\")io.sendline(str(2*c).encode())c2 = int(io.recvline(None).decode())print(long_to_bytes((c2*pow(d2,-1,n))%n))# Hero{m4ybe_le4ving_the_1nt3rn_run_th3_plac3_wasnt_a_g00d_id3a}" }, { "title": "cyberapocarypse 2022 writeup", "url": "/posts/cyberapocarypse-writeup/", "categories": "ctf, writeup", "tags": "ctf, cryptography, writeup", "date": "2022-05-23 12:33:00 +0900", "snippet": "去年初めて参加した大会がこの大会で1問しか解けなかった。でも、今年はcrypto 7/10解けたんで割と満足してます..[crypto] Android-In-The-Middle [505 solve]challfrom Crypto.Cipher import AESfrom Crypto.Util.number import long_to_bytesimport hashlibimport randomimport socketserverimport signalFLAG = \"HTB{--REDACTED--}\"DEBUG_MSG = \"DEBUG MSG - \"p = 0x509efab16c5e2772fa00fc180766b6e62c09bdbd65637793c70b6094f6a7bb8189172685d2bddf87564fe2a6bc596ce28867fd7bbc300fd241b8e3348df6a0b076a0b438824517e0a87c38946fa69511f4201505fca11bc08f257e7a4bb009b4f16b34b3c15ec63c55a9dac306f4daa6f4e8b31ae700eba47766d0d907e2b9633a957f19398151111a879563cbe719ddb4a4078dd4ba42ebbf15203d75a4ed3dcd126cb86937222d2ee8bddc973df44435f3f9335f062b7b68c3da300e88bf1013847af1203402a3147b6f7ddab422d29d56fc7dcb8ad7297b04ccc52f7bc5fdd90bf9e36d01902e0e16aa4c387294c1605c6859b40dad12ae28fdfd3250a2e9g = 2class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): passdef sendMessage(s, msg): s.send(msg.encode())def recieveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip()def decrypt(encrypted, shared_secret): key = hashlib.md5(long_to_bytes(shared_secret)).digest() cipher = AES.new(key, AES.MODE_ECB) message = cipher.decrypt(encrypted) return messagedef main(s): sendMessage(s, DEBUG_MSG + \"Generating The Global DH Parameters\\n\") sendMessage(s, DEBUG_MSG + f\"g = {g}, p = {p}\\n\") sendMessage(s, DEBUG_MSG + \"Calculation Complete\\n\\n\") sendMessage(s, DEBUG_MSG + \"Generating The Public Key of CPU...\\n\") c = random.randrange(2, p - 1) C = pow(g, c, p) sendMessage(s, DEBUG_MSG + \"Calculation Complete\\n\") sendMessage(s, DEBUG_MSG + \"Public Key is: ???\\n\\n\") M = recieveMessage(s, \"Enter The Public Key of The Memory: \") try: M = int(M) except: sendMessage(s, DEBUG_MSG + \"Unexpected Error Occured\\n\") exit() sendMessage(s, \"\\n\" + DEBUG_MSG + \"The CPU Calculates The Shared Secret\\n\") shared_secret = pow(M, c, p) sendMessage(s, DEBUG_MSG + \"Calculation Complete\\n\\n\") encrypted_sequence = recieveMessage( s, \"Enter The Encrypted Initialization Sequence: \") try: encrypted_sequence = bytes.fromhex(encrypted_sequence) assert len(encrypted_sequence) % 16 == 0 except: sendMessage(s, DEBUG_MSG + \"Unexpected Error Occured\\n\") exit() sequence = decrypt(encrypted_sequence, shared_secret) if sequence == b\"Initialization Sequence - Code 0\": sendMessage(s, \"\\n\" + DEBUG_MSG + \"Reseting The Protocol With The New Shared Key\\n\") sendMessage(s, DEBUG_MSG + f\"{FLAG}\") else: exit()if __name__ == '__main__': socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), Handler) server.serve_forever()solve典型的なAES暗号と、DHの値を一意に定めよう問題from Crypto.Util.number import *from Crypto.Cipher import AESimport hashlibp = 0x509efab16c5e2772fa00fc180766b6e62c09bdbd65637793c70b6094f6a7bb8189172685d2bddf87564fe2a6bc596ce28867fd7bbc300fd241b8e3348df6a0b076a0b438824517e0a87c38946fa69511f4201505fca11bc08f257e7a4bb009b4f16b34b3c15ec63c55a9dac306f4daa6f4e8b31ae700eba47766d0d907e2b9633a957f19398151111a879563cbe719ddb4a4078dd4ba42ebbf15203d75a4ed3dcd126cb86937222d2ee8bddc973df44435f3f9335f062b7b68c3da300e88bf1013847af1203402a3147b6f7ddab422d29d56fc7dcb8ad7297b04ccc52f7bc5fdd90bf9e36d01902e0e16aa4c387294c1605c6859b40dad12ae28fdfd3250a2e9g = 2m = b\"Initialization Sequence - Code 0\"print(isPrime(p))def encrypt(message, shared_secret): key = hashlib.md5(long_to_bytes(shared_secret)).digest() cipher = AES.new(key, AES.MODE_ECB) encrypted = cipher.encrypt(message) return encryptedprint(encrypt(m, 1).hex())# HTB{7h15_p2070c0l_15_pr0tec73d_8y_D@nb3er_c0pyr1gh7_1aws}[crypto] Jenny From The Block [312 solve]challfrom hashlib import sha256from Crypto.Util.Padding import pad, unpadimport signalimport subprocessimport socketserverimport osallowed_commands = [b'whoami', b'ls', b'cat secret.txt', b'pwd']BLOCK_SIZE = 32def encrypt_block(block, secret): enc_block = b'' for i in range(BLOCK_SIZE): val = (block[i]+secret[i]) % 256 enc_block += bytes([val]) return enc_blockdef encrypt(msg, password): h = sha256(password).digest() print(\"firse_pass\",h) if len(msg) % BLOCK_SIZE != 0: msg = pad(msg, BLOCK_SIZE) blocks = [msg[i:i+BLOCK_SIZE] for i in range(0, len(msg), BLOCK_SIZE)] ct = b'' for block in blocks: enc_block = encrypt_block(block, h) h = sha256(enc_block + block).digest() ct += enc_block print(\"ct\",ct) return ct.hex()def run_command(cmd): if cmd in allowed_commands: try: resp = subprocess.run( cmd.decode().split(' '), capture_output=True) output = resp.stdout return output except: return b'Something went wrong!\\n' else: return b'Invalid command!\\n'def challenge(req): req.sendall(b'This is Jenny! I am the heart and soul of this spaceship.\\n' + b'Welcome to the debug terminal. For security purposes I will encrypt any responses.') while True: req.sendall(b'\\n&gt; ') command = req.recv(4096).strip() output = run_command(command) response = b'Command executed: ' + command + b'\\n' + output password = os.urandom(32) ct = encrypt(response, password) print(\"ct.hex\",ct) req.sendall(ct.encode())class incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(30) req = self.request challenge(req)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): passdef main(): socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever()if __name__ == \"__main__\": main()solve“Command executed: cat secret.txt”が丁度32文字なので鍵が復元できるこれを繰り返して平文特定from hashlib import sha256from Crypto.Util.Padding import pad, unpadfrom pwn import *from Crypto.Util.number import *BLOCK_SIZE = 32io = remote(\"159.65.49.107\",31207)# io = remote(\"localhost\",1337)def decrypt_block_i(block,plain): return (block-plain) % 256def search_password(ct,plain): secret = b\"\" for i in range(BLOCK_SIZE): k = decrypt_block_i(ct[i],plain[i]) secret+=bytes([k]) print(secret) return secret def encrypt_block(block, secret): enc_block = b'' for i in range(BLOCK_SIZE): val = (block[i]-secret[i]) % 256 enc_block += bytes([val]) return enc_blockdef encrypt(msg, password): # h = sha256(password).digest() h = password if len(msg) % BLOCK_SIZE != 0: msg = pad(msg, BLOCK_SIZE) blocks = [msg[i:i+BLOCK_SIZE] for i in range(0, len(msg), BLOCK_SIZE)] ct = b'' # for block in blocks: for i in range(len(blocks)): dec_block = encrypt_block(blocks[i], h) h = sha256(blocks[i] + dec_block ).digest() ct += dec_block return ct def connection(io): io.recvuntil(\"&gt; \") command = b'cat secret.txt' io.sendline(command) ct = bytes.fromhex(io.recvline(None).decode()) response = b'Command executed: ' + command + b'\\n' + b'Invalid command!\\n' print(\"ct\",ct) print(\"ct[:32]\",ct[:32]) password = search_password(ct[:32],response[:32]) print(encrypt(ct,password)) connection(io)io.close()[crypto] The Three-Eyed Oracle [264 solve]challfrom tarfile import BLOCKSIZEfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport randomimport signalimport subprocessimport socketserverimport os# FLAG = b''FLAG = b'HTB{--REDACTED--}'# prefix = random.randbytes(12)# key = random.randbytes(16)prefix = os.urandom(12)key = os.urandom(16)print(prefix)BLOCKSIZE = 16def encrypt(key, msg): msg = bytes.fromhex(msg) crypto = AES.new(key, AES.MODE_ECB) padded = pad(prefix + msg + FLAG, 16) # print(\"padded\",padded) print(\"padded\",[padded[i*BLOCKSIZE:(i+1)*BLOCKSIZE] for i in range(len(padded)//BLOCKSIZE)]) print(\"enc\",[crypto.encrypt(padded)[i*BLOCKSIZE:(i+1)*BLOCKSIZE] for i in range(len(crypto.encrypt(padded))//BLOCKSIZE)]) return crypto.encrypt(padded).hex()def challenge(req): req.sendall(b'Welcome to Klaus\\'s crypto lab.\\n' + b'It seems like there is a prefix appended to the real firmware\\n' + b'Can you somehow extract the firmware and fix the chip?\\n') while True: req.sendall(b'&gt; ') # try: msg = req.recv(4096).decode() print(\"msg decode \",msg) ct = encrypt(key, msg) # except: # req.sendall(b'An error occurred! Please try again!') req.sendall(ct.encode() + b'\\n')class incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(1500) req = self.request challenge(req)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): passdef main(): socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever()if __name__ == \"__main__\": main()AES ECBのplaintext recovery attack詳しくはggってもらってsolvefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *from tqdm import tqdmimport randomfrom pwn import *io = remote(\"134.209.29.182\",30681)# io = remote(\"localhost\",1337)BLOCKSIZE = 16PTSIZE = 32def send_m(m): io.recvuntil(b\"&gt; \") # print(\"send_m\",(b\"1\"*4+m).hex().encode()) io.sendline((b\"a\"*4+m).hex().encode()) re = bytes.fromhex(io.recvline(None).decode()) return [re[i*BLOCKSIZE:(i+1)*BLOCKSIZE] for i in range(len(re)//BLOCKSIZE)]def plaintxt_recavary(): PTSIZE = 9 print(\"PTSIZE\",PTSIZE) # list m = b\"\" for i in range(1,PTSIZE): target = send_m(b\"0\"*(BLOCKSIZE-i))[1] for k in tqdm(range(70,0x100)): a = b\"0\"*(BLOCKSIZE-i)+m+bytes([k]) tmp = send_m(a)[1] if tmp== target: m =m + bytes([k]) break return mprint(plaintxt_recavary())[crypto] How The Columns Have Turned [239 solve]challimport oswith open('super_secret_messages.txt', 'r') as f: SUPER_SECRET_MESSAGES = [msg.strip() for msg in f.readlines()]def deriveKey(key): derived_key = [] for i, char in enumerate(key): previous_letters = key[:i] new_number = 1 for j, previous_char in enumerate(previous_letters): if previous_char &gt; char: derived_key[j] += 1 else: new_number += 1 derived_key.append(new_number) return derived_keydef transpose(array): return [row for row in map(list, zip(*array))]def flatten(array): return \"\".join([i for sub in array for i in sub])def twistedColumnarEncrypt(pt, key): derived_key = deriveKey(key) print(derived_key) width = len(key) blocks = [pt[i:i + width] for i in range(0, len(pt), width)] print(blocks) blocks = transpose(blocks) print(\"blocks\",blocks) print(derived_key.index(2)) for i in range(width): print(derived_key.index(i + 1),blocks[derived_key.index(i + 1)]) ct = [blocks[derived_key.index(i + 1)][::-1] for i in range(width)] print(ct) ct = flatten(ct) print(ct) return ctclass PRNG: def __init__(self, seed): self.p = 0x2ea250216d705 self.a = self.p # self.b = int.from_bytes(os.urandom(16), 'big') self.b = 729513912306026 self.rn = seed def next(self): self.rn = ((self.a * self.rn) + self.b) % self.p return self.rndef main(): seed = int.from_bytes(os.urandom(16), 'big') rng = PRNG(seed) cts = \"\" for message in SUPER_SECRET_MESSAGES: key = str(rng.next()) ct = twistedColumnarEncrypt(message, key) cts += ct + \"\\n\" with open('encrypted_messages.txt', 'w') as f: f.write(cts) dialog = \"Miyuki says:\\n\" dialog += \"Klaus it's your time to sign!\\n\" dialog += \"All we have is the last key of this wierd encryption scheme.\\n\" dialog += \"Please do your magic, we need to gather more information if we want to defeat Draeger.\\n\" dialog += f\"The key is: {str(key)}\\n\" with open('dialog.txt', 'w') as f: f.write(dialog)if __name__ == '__main__': main()solvePNRGかと思いきや\\(a=p\\)よりnext関数の出力値は\\(b\\)固定になり関係なくなるあとはブロック暗号を元に戻していくだけkey = 729513912306026import osclass PRNG: def __init__(self, seed): self.p = 0x2ea250216d705 self.a = self.p self.b = 729513912306026 self.rn = seed def next(self): self.rn = ((self.a * self.rn) + self.b) % self.p return self.rndef deriveKey(key): derived_key = [] # print(\"key\",key) for i, char in enumerate(key): # print(\" i, char\", i, char) previous_letters = key[:i] new_number = 1 for j, previous_char in enumerate(previous_letters): # print(\"i,j, previous_char \",i,j, previous_char ) if previous_char &gt; char: derived_key[j] += 1 else: new_number += 1 # print(\"new_number\",new_number) # print(\"derived_key\",derived_key) derived_key.append(new_number) return derived_keydef transpose(array): return [row for row in map(list, zip(*array))]def flatten(array): return \"\".join([i for sub in array for i in sub])def twistedColumnarEncrypt(pt, key): derived_key = deriveKey(key) print(derived_key) width = len(key) blocks = [pt[i:i + width] for i in range(0, len(pt), width)] print(blocks) blocks = transpose(blocks) print(blocks) print(derived_key.index(1)) print(blocks[derived_key.index(1)][::-1]) ct = [blocks[derived_key.index(i + 1)][::-1] for i in range(width)] print(ct) ct = flatten(ct) print(ct) return cttwistedColumnarEncrypt(\"123456789012345543210987654321\", str(key))[crypto] MOVs Like Jagger [107 solve]challfrom ecdsa import ellipticcurve as eccfrom random import randinta = -35b = 98p = 434252269029337012720086440207Gx = 16378704336066569231287640165Gy = 377857010369614774097663166640ec_order = 434252269029337012720086440208E = ecc.CurveFp(p, a, b)G = ecc.Point(E, Gx, Gy, ec_order)def generateKeyPair(): private = randint(1, 2**64) public = G * private return(public, private)def calculatePointsInSpace(): Q, nQ = generateKeyPair() P, nP = generateKeyPair() return [Q, nQ, P, nP]def checkCoordinates(data: dict) -&gt; list: if data['destination_x'] == \"\" or data['destination_y'] == \"\": raise ValueError('Empty coordinates...') try: destination_x = int(data['destination_x'], 16) destination_y = int(data['destination_y'], 16) except: raise ValueError('Coordinates are not in the right format (hex)') return (destination_x, destination_y)def checkDestinationPoint(data: dict, P: ecc.Point, nQ: int, E: ecc.CurveFp) -&gt; list: # destination_x, destination_y = checkCoordinates(data) destination_x, destination_y = data destination_point = ecc.Point(E, destination_x, destination_y, ec_order) secret_point = P * nQ print(\"secret_point = P * nQ\",secret_point , P , nQ) same_x = destination_point.x() == secret_point.x() same_y = destination_point.y() == secret_point.y() if (same_x and same_y): return True else: return Falseif \"__main__\"==__name__: Q, nQ, P, nP = calculatePointsInSpace() print(Q, nQ, P, nP ) checkDestinationPoint([Gx, Gy],P,nQ,E)solve典型的なECCの問題。ただ、\\(p\\)が素数でないので因数分解を施すといい感じにばらけたのでPohlig–Hellman algorithmで解いていくfrom sage.all import *#素数は小さければ小さいほうがいいが大きいものも場合によっては必要#[s]P1 = P2# fac = Ep.order())def Pohlig_Hellman(P1,P2,fac): primes = [] for i in range(len(fac)-1): primes.append(fac[i][0]**fac[i][1]) #primes =[ 7 , 11 , 17 , 191 , 317 , 331 , 5221385621 , 5397618469 , 210071842937040101 , 637807437018177170959577732683] dlogs = [] for fac in primes[:]: t = int(P1.order()) // int(fac) dlog = (t*P1).discrete_log(t*P2) #discrete_log(t*sGq, t*Gq, operation=\"+\") dlogs += [dlog] print(\"factor: \"+str(fac)+\", Discrete Log: \"+str(dlog)) #calculates discrete logarithm for each prime order return crt(dlogs, primes[:])a = -35b = 98p = 434252269029337012720086440207Gx = 16378704336066569231287640165Gy = 377857010369614774097663166640ec_order = 434252269029337012720086440208E = EllipticCurve(GF(p),[a,b]){\"departed_x\":\"0x3b41ebf4c4afc44b98bc8542\",\"departed_y\":\"0xd8d92015d026528a7dbc3309\",\"present_x\":\"0x2f8756f6476af7a24952eb8e3\",\"present_y\":\"0x1a61b777121c1d25bfd6c2f48\"}G = E(Gx,Gy)Q = E(0x3b41ebf4c4afc44b98bc8542,0xd8d92015d026528a7dbc3309)P = E(0x2f8756f6476af7a24952eb8e3,0x1a61b777121c1d25bfd6c2f48)nP = Pohlig_Hellman(G,P,factor(ec_order))print(nP,(360301137196997).bit_length())for i in range(360301137196997): if ((ec_order//360301137196997)*i+nP)*G==P: print(i) breaknP = (ec_order//360301137196997)*i+nPnQ = Pohlig_Hellman(G,Q,factor(ec_order))print(nQ,(360301137196997).bit_length())for i in range(360301137196997): if ((ec_order//360301137196997)*i+nQ)*G==Q: print(i) breaknQ=(ec_order//360301137196997)*i+nQprint(nP*(nQ*G))print()[crypto] Find Marher’s Secret [70 solve]challimport randomimport signalimport subprocessimport socketserverimport jsonimport osfrom Crypto.Cipher import ARC4, AESimport osimport hashlibfrom secret import FLAG, KEYdef encrypt(key, iv, pt): return ARC4.new(iv + key).encrypt(pt).hex()def challenge(req): key = bytes.fromhex(KEY) assert(len(key) == 27) req.sendall(b'Connected to the cyborg\\'s debugging interface\\n') while True: req.sendall( b'\\nOptions:\\n1. Encrypt your text.\\n2. Claim the key.\\n&gt; ') try: response = json.loads(req.recv(4096).decode()) if response['option'] == 'encrypt': iv = bytes.fromhex(response['iv']) pt = bytes.fromhex(response['pt']) ct = encrypt(key, iv, pt) payload = {'response': 'success', 'pt': response['pt'], 'ct': ct} payload = json.dumps(payload) req.sendall(payload.encode()) elif response['option'] == 'claim': answer = bytes.fromhex(response['key']) if hashlib.sha256(answer).hexdigest() == hashlib.sha256(key).hexdigest(): payload = {'response': 'success', 'flag': FLAG} payload = json.dumps(payload) req.sendall(payload.encode()) else: payload = {'response': 'fail', 'message': 'Better luck next time.'} payload = json.dumps(payload) req.sendall(payload.encode()) else: payload = {'response': 'error', 'message': 'Invalid option!'} payload = json.dumps(payload) req.sendall(payload.encode()) except Exception as e: payload = json.dumps( {'response': 'error', 'message': 'An error occured!'}) req.sendall(payload.encode()) returnclass incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(6000) req = self.request challenge(req)class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): passdef main(): socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever()if __name__ == \"__main__\": main()solveRC4かつオラクルが無制限に使えるのでFluhrer-Mantin-Shamir attackで終わりfrom Crypto.Cipher import ARC4, AESfrom pwn import *import jsonfrom collections import Counterfrom tqdm import tqdmio = remote(\"157.245.33.77\",32157)io.recvuntil(b\"&gt; \")def encrypt_oracle(iv,pt): # def _encrypt(self, iv, key, p): # return ARC4.new(iv + key).encrypt(p) payload = {'option': 'encrypt', 'iv': iv.hex(), 'pt': pt.hex()} # print(payload) payload = json.dumps(payload) io.sendline(payload.encode()) a = io.recvline(None).decode() # print(a) response = json.loads(a) # print(response['pt']) # print(response['ct']) io.recvuntil(b\"&gt; \") return bytes.fromhex(response['ct']) def possible_key_bit(key, c): s = [i for i in range(256)] j = 0 for i in range(len(key)): j = (j + s[i] + key[i]) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp return (c[0] - j - s[len(key)]) % 256def attack(encrypt_oracle, key_len): \"\"\" Recovers the hidden part of an RC4 key using the Fluhrer-Mantin-Shamir attack. :param encrypt_oracle: the padding oracle, returns the encryption of a plaintext under a hidden key concatenated with the iv :param key_len: the length of the hidden part of the key :return: the hidden part of the key \"\"\" key = bytearray([3, 255, 0]) for a in range(key_len): key[0] = a + 3 possible = Counter() for x in tqdm(range(256)): key[2] = x # iv ,pt c = encrypt_oracle(key[:3], b\"\\x00\") possible[possible_key_bit(key, c)] += 1 key.append(possible.most_common(1)[0][0]) print(key) return key[3:]# print(attack(encrypt_oracle,27))key = b'\\x1f\\xec\\x07\\x87\\xbd\\x1aR\\xad\\xe6:7\\x9a &lt;+\\xe9+\\x98\\x1e\\xb1\\x17\\xda\\xc4\\x03N\\xcc\\xe0'# def _encrypt(self, iv, key, p):# return ARC4.new(iv + key).encrypt(p)payload = {'option': 'claim', 'key': key.hex()}# print(payload)payload = json.dumps(payload)io.sendline(payload.encode())a = io.recvline(None).decode()print(a)response = json.loads(a)print(response['flag'])# print(response['ct'])io.recvuntil(b\"&gt; \")[crypto] Down the Rabinhole [74 solve]challfrom Crypto.Util.number import getPrime, isPrime, bytes_to_longfrom Crypto.Util.Padding import padimport osFLAG = b\"HTB{--REDACTED--}\"def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, qdef encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 64)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2)def main(): coefficient = getPrime(128) out = \"\" message = FLAG[0:len(FLAG)//2] n1, c1, c2 = encrypt(message, coefficient) out += f\"{n1}\\n{c1}\\n{c2}\\n\" message = FLAG[len(FLAG)//2:] n2, c3, c4 = encrypt(message, coefficient) out += f\"{n2}\\n{c3}\\n{c4}\" with open(\"out.txt\", \"w\") as f: f.write(out)if __name__ == '__main__': main()solve\\(n1=(3*coff*a_{1}+2)(3*coff*b_{1}+2)\\),\\(n2=(3*coff*a_2+2)(3*coff*b_2+2)\\)　より\\(coff = gcd(n1-4,n2-4)\\)よって\\(coff\\)が特定できたのでmod \\(n\\) 上の二次多項式を解けば答えが出るfrom tqdm import tqdmfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *n1 = 59695566410375916085091065597867624599396247120105936423853186912270957035981683790353782357813780840261434564512137529316306287245132306537487688075992115491809442873176686026221661043777720872604111654524551850568278941757944240802222861051514726510684250078771979880364039814240006038057748087210740783689350438039317498789505078530402846140787188830971536805605748267334628057592989c1 = 206131769237721955001530863959688756686125485413899261197125641745745636359058664398433013356663394210624150086689905532c2 = 14350341133918883930676906390648724486852266960811870561648194176794020698141189777337348951219934072588842789694987397861496993878758159916334335632468891342228755755695273096621152247970509517996580512069034691932835017774636881861331636331496873041705094768329156701838193429109420730982051593645140188946n2 = 56438641309774959123579452414864548345708278641778632906871133633348990457713200426806112132039095059800662176837023585166134224681069774331148738554157081531312104961252755406614635488382297434171375724135403083446853715913787796744272218693049072693460001363598351151832646947233969595478647666992523249343972394051106514947235445828889363124242280013397047951812688863313932909903047c3 = 429546912004731012886527767254149694574730322956287028161761007271362927652041138366004560890773167255588200792979452452c4 = 29903904396126887576044949247400308530425862142675118500848365445245957090320752747039056821346410855821626622960719507094119542088455732058232895757115241568569663893434035594991241152575495936972994239671806350060725033375704703416762794475486000391074743029264587481673930383986479738961452214727157980946## coff partprint(gcd(n1-4,n2-4),int(gcd(n1-4,n2-4)).bit_length())for i in range(1,1&lt;&lt;(int(gcd(n1-4,n2-4)).bit_length()-128)): if gcd(n1-4,n2-4)%i==0: print(i)coff = 263063435253385937926984981365320113271assert isPrime(coff)# c1 = x(x+coff) mod n# c2 = (x*1&lt;&lt;k+l)*(x*1&lt;&lt;k+l+coff) mod nm_t = []def search(k,N,C1,C2): l = bytes_to_long(pad(b\"1\"*(64-k), 64)[-1*k:]) # print(pad(b\"1\"*(64-k), 64)) # print(pad(b\"1\"*(64-k), 64)[-1*k:]) # print(long_to_bytes(bytes_to_long(b\"1\"*(64-k))&lt;&lt;(8*k))) # print(l) # exit() padding = 1&lt;&lt;(8*k) #c1 C1 = C1 C1_coff = coff # #c2 C2 = (C2-l*(l+coff))*pow(padding,-2,N) C2_coff = (2*l+coff)*pow(padding,-1,N) #C2-C1 = (C2_coff-C1_coff)*m m = ((C2-C1)*pow(C2_coff-C1_coff,-1,N))%N # print(long_to_bytes(m)) return long_to_bytes(m) for i in range(2,64): if b'HTB{' in search(i,n1,c1,c2): print(search(i,n1,c1,c2))for i in range(2,64): if search(i,n2,c3,c4).endswith(b\"}\"): print(search(i,n2,c3,c4))# 'HTB{gcd_+_2_*_R@6in_.|5_thi5_@_cro55over_epi5ode?}" } ]
